<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算理论基础复习笔记</title>
    <link href="/AcceptedHelper/2021/06/24/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/AcceptedHelper/2021/06/24/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算理论基础复习笔记"><a href="#计算理论基础复习笔记" class="headerlink" title="计算理论基础复习笔记"></a>计算理论基础复习笔记</h1><p>待更新</p><h2 id="预备知识与基本文法理论（讲义第一章、第二章）"><a href="#预备知识与基本文法理论（讲义第一章、第二章）" class="headerlink" title="预备知识与基本文法理论（讲义第一章、第二章）"></a>预备知识与基本文法理论（讲义第一章、第二章）</h2><p>第一章大部分内容在其他课程里讲过了，新的内容只有：</p><blockquote><p>前缀性质：L 中任何字符串都不是另一个字符串的真前缀</p></blockquote><p>第二章讲了文法的基本概念。</p><blockquote><p><strong>文法</strong> $G$ 是四元组 $(V, T, P, S)$， V 是变元的有限集，T 是终结符有限集，P 是生成式有限集， S 是开始符号。</p></blockquote><blockquote><p>=&gt; 关系为<strong>直接派生</strong>，多步直接派生为<strong>派生</strong>。</p></blockquote><blockquote><p>文法 $G$ 产生的<strong>语言</strong> $L(G)$ 是 S 派生出来的终结符号串的全体。</p></blockquote><blockquote><p>0型文法（短语结构文法 PSG ）：对生成式无限制。</p><p>1型文法（上下文有关文法 CSG ）：每个生成式左侧长度≤右侧长度</p><p>1°型文法（上下文有关文法的另一种形式）：每个生成式，左侧至少包含一个变元，删去该变元后的前缀与后缀（可为空）也是右侧的前缀与后缀。$\alpha_1A\alpha_2 \rightarrow \alpha1\beta\alpha_2, \beta不为空$，前缀$\alpha_1$和后缀$\alpha_2$即为上下文。</p><p>2型文法（上下文无关文法 CFG ）：每个生成式左侧仅包含一个变元</p><p>3型文法（正规文法 RG ）：每个生成式左侧仅包含一个变元，且右侧必须形如 $a$ 或 $aB$ ，$a \in T \ 或a为空串$</p></blockquote><p>将1型文法转为1°型文法：</p><ol><li>对所有终结符$a$，添加变元$[a]$。</li><li>将原有生成式中所有终结符替换为对应新变元（如将$a$替换为$[a]$）。此时，所有生成式都只含变元。</li><li>对所有终结符$a$，添加生成式$[a]\rightarrow a$。</li><li>对所有不符合1°型文法的生成式，若左侧为$A_1A_2\ …\ A_n$，右侧为$B_1B_2…B_m$ ，则添加$n$个变元，用新的 $2n$ 个生成式替换这个生成式。新的生成式中：<ul><li>第 $i+1$ 个生成式的左侧是第 $i$ 个生成式的右侧；</li><li>前 $n$ 个生成式将 $A_1A_2…A_n$ 逐渐替换为 $C_1C_2…C_n$，每个生成式替换一个最靠前的 $A$（第一个生成式为$A_1A_2…A_n\rightarrow C_1A_2…A_n$）；</li><li>接下来的 $n-1$ 个生成式将 $C_1C_2…C_n$ 逐渐替换为 $B_1B_2…B_{n-1}C_n$， 每个生成式替换一个最靠前的 $C$ （第 $n+1$个生成式为$C_1C_2…C_n\rightarrow B_1C_2…C_n$）；</li><li>最后的生成式将 $C_n$ 替换为 $B_nB_{n+1}…B_m$ 。</li></ul></li></ol><p>2型文法的<strong>派生树</strong>：根节点为 S ；内部节点为变元；某个节点（有标记A）的孩子从左到右收集而成的字符串s，必有$A\rightarrow s$属于生成式集合（对应<em>直接派生</em>）；<strong>边缘</strong>是叶子节点从左到右收集而成的字符串（对应<em>派生</em>）。派生树可对应一个字符串从 S 开始的派生过程。</p><p><strong>最左派生</strong>：派生过程每一步都只替换最左边的变元。（同理有<strong>最右派生</strong>）</p><p><strong>多义</strong>：某个字符串有两种不同派生过程。</p><h2 id="有穷自动机、正规表达式、正规集（讲义第三、四章，MIT教材第一章）"><a href="#有穷自动机、正规表达式、正规集（讲义第三、四章，MIT教材第一章）" class="headerlink" title="有穷自动机、正规表达式、正规集（讲义第三、四章，MIT教材第一章）"></a>有穷自动机、正规表达式、正规集（讲义第三、四章，MIT教材第一章）</h2><blockquote><p><strong>有穷自动机</strong> （FA） 是五元组 $(Q,\Sigma,\delta,q_0,F)$，分别对应：有穷状态集、有穷输入字符表、转移函数、初始状态、终结状态集。</p><p>转移函数的输入为单个字符，可扩充为字符串。</p><p>FA 接收的字符串 s ：以 s 作为 FA 的输入，状态从初始的 $q_0$ 转移到 F 里的状态。</p></blockquote><h3 id="几种转换"><a href="#几种转换" class="headerlink" title="几种转换"></a>几种转换</h3><ol><li><p>$DFA \rightarrow Regular\ Expression$</p><p>讲义上的方法是：</p><ul><li><p>如果有 $k$ 个状态，算出 $k^3$ 个正规表达式 $r_{ij}^k$，表示输入串使状态机从状态 i 到 j 中间不经过编号高于 k 的状态。</p></li><li><p>$k = 0$ 时，状态图中若有从状态 i 到状态 j 的箭头，就把箭头上的字符加到集合里。$i == j$ 时，这个集合里还要包含空串。</p></li><li><p>$k \ne 0$ 时，有递推式 $r_{ij}^k = r_{ik}^{k-1}(r_{kk}^{k-1})^*r_{kj}^{k-1} \cup r_{ij}^{k-1}$</p></li></ul><p>MIT 教材上的方法是：</p><ul><li>将 DFA 转为 GNFA （GNFA的转换条件可以是正规表达式）：添加两个状态 s 和 t ，s 为新的初始状态，t 为新的终结状态。s 通过 $\epsilon$ 动作到原有的每个初始状态，原有的每个终结状态通过 $\epsilon$ 动作到 t</li><li>将 GNFA 的状态数缩减到2：下面的 RE 三种四句的反向操作，可将状态数减1</li><li>将 2-state GNFA 转换为 RE：转换条件即为所求</li></ul></li><li><p>$Regular Expression \rightarrow \epsilon-NFA$</p><p>处理三种类型的子句即可。讲义 p65-p66 的三张图</p><ul><li>$r_1+r_2$：两路分叉、两路归并</li><li>$r_1r_2$：前面的终结状态指向后面的初始状态</li><li>$r_1^*$：终结状态回到初始状态</li></ul></li><li><p>$\epsilon-NFA \rightarrow NFA$</p><p>讲义 p59</p><p>先检查 $q_0$ 是否为终结状态。</p><p>转移函数取一个闭包。</p></li><li><p>$NFA \rightarrow DFA$</p><p>讲义 p55</p><p>NFA 中，$\delta(q, a)$ 的结果是一个状态集。建立状态集到状态元组双射，把状态元组看作一个新的状态。将状态元组作为 $\delta$ 的输入，结果为元组中状态作为输入的结果的并集。一直做下去，直到不产生新的状态。</p></li></ol><p>正规文法转为 $\epsilon-NFA$：</p><ul><li>每个变元为状态，每个终结符为输入字符</li><li>转移函数的输入：派生左侧的变元、派生右侧的终结符（或 $\epsilon$）；输出为派生右侧的变元（或终结状态）</li></ul><p>DFA 转为正规文法：同上。</p><h3 id="缩胀定理"><a href="#缩胀定理" class="headerlink" title="缩胀定理"></a>缩胀定理</h3><p><strong>正规集缩胀定理</strong>：A 是正规集，则存在 p (pumping length) 使长度大于等于 p 的 A 中任意 s，可拆成三部分 $s=xyz$，满足：</p><ul><li>$xy^iz\in A, \forall i \ge 0$</li><li>$|y| \gt 0$</li><li>$|xy|\le p$</li></ul><p>（讲义上的定理给 s 和 $xy^iz$ 加了前缀和后缀，移去了最后一个限制。）</p><p>正规集在并、连接、闭包运算（由正规表达式的定义）、补运算（终结状态取补）、交运算（两个 DFA 的状态集、终结状态集取笛卡尔积）、商运算（ 在 R1/R2 中，R1 状态集为 Q，建立 |Q| 个 DFA，分别以 Q 中每个状态为初始状态，检测这些 DFA 交 R2 是否为空）下封闭。这些性质可以用来判定某个集合 C 不是正规集：取已知正规集 A 和已知非正规集 B，使 A 和 C 在某种封闭运算下变为 B，则 C 不是正规集。</p><p>一些判定问题：具有 n 个状态的 FA 有以下性质</p><ul><li>接受集合非空，iff 接受一个长度小于 n 的串</li><li>接受集合无穷，iff 接受一个长度在 [n, 2n) 之间的串</li><li>是否为空、是否无穷、是否等价 是可判定的</li></ul><h3 id="极小化算法"><a href="#极小化算法" class="headerlink" title="极小化算法"></a>极小化算法</h3><blockquote><p>状态的等价：$\forall x \in \Sigma^*, \delta(p,x)\in F\ \lrarr \ \delta(q,x)\in F$</p><p>商自动机：状态集是 Q 的各等价类；自动机和它的商自动机等价</p></blockquote><p>极小化算法：</p><ul><li>对所有状态对 {p, q} 画一个下三角矩阵</li><li>对 $p\in F,q\notin F$ 的 ${p, q}$，在相应位置做标记</li><li>重复此步直到矩阵不再变化：$\exist a\in\Sigma,{\delta(p,a),\delta(q,a)}$ 被标记，则标记 $(p,q)$</li><li>没被标记的状态对是等价的</li></ul><h3 id="Myhill-Nerode-定理"><a href="#Myhill-Nerode-定理" class="headerlink" title="Myhill-Nerode 定理"></a>Myhill-Nerode 定理</h3><blockquote><p>两个 DFA 同构：状态集存在双射，且满足一些性质</p><p>右不变：对于等价关系 R，xRy 可推出 xzRyz</p><p>关于集合 A 的 <code>Myhill-Nerode</code> 关系：右不变、细分A、具有有穷指数</p></blockquote><p><strong>DFA 与 <code>Myhill-Nerode</code> 的关系</strong>：</p><ul><li><p>DFA M $\rightarrow$ <code>Myhill-Nerode</code> 关系 $R_M$：$xR_My\lrarr\delta(q_0,x)=\delta(q_0,y)$</p></li><li><p><code>Myhill-Nerode</code> 关系 $\rightarrow$ DFA $M_R$ : $Q = {[x]|x\in\Sigma^*}, q_0 = {[e]}, F = {[x]|x\in A}, \delta([x],a)=[xa]$，有 $L(M_R) = A$</p></li></ul><p><strong>反复横跳</strong>：</p><ul><li>$R_{M_R}=R$，R 是 <code>Myhill-Nerode</code> 关系</li><li>$M_{R_M}$ 同构于 $M$，M 是 FA</li></ul><blockquote><p>等价关系 $R_A$：$xR_Ay:\forall z\in\Sigma^*,xz\in A \lrarr yz \in A$. $R_A$ 右不变、细分 A </p></blockquote><p><strong>Myhill-Nerode定理</strong>：</p><ul><li>正规集有一个 <code>Myhill-Nerode</code> 关系 $R_M$</li><li>若 A 有 <code>Myhill-Nerode</code> 关系，则 $R_A$ 有有穷指数</li><li>若 $R_A$ 有有穷指数，则$R_A$ 是 $Myhill-Nerode$ 关系，构造 $M_{R_A}$ 接受 A</li></ul><p>$M_{R_A}$ 是状态数最少的。</p><h3 id="归纳：判定某个集合不是正规集"><a href="#归纳：判定某个集合不是正规集" class="headerlink" title="归纳：判定某个集合不是正规集"></a>归纳：判定某个集合不是正规集</h3><ul><li>缩胀定理</li><li>利用封闭运算</li><li>集合的关系 $R_A$ 没有有穷指数</li></ul><h2 id="上下文无关文法、下推自动机（讲义第五、六章，MIT教材第二章）"><a href="#上下文无关文法、下推自动机（讲义第五、六章，MIT教材第二章）" class="headerlink" title="上下文无关文法、下推自动机（讲义第五、六章，MIT教材第二章）"></a>上下文无关文法、下推自动机（讲义第五、六章，MIT教材第二章）</h2><h3 id="化简-CFG"><a href="#化简-CFG" class="headerlink" title="化简 CFG"></a>化简 CFG</h3><blockquote><p>无用符号：$X\in V\cup T$ 但 $X$ 不出现在 S 派生出的字符串中；$X\in V$ 但 X 不能派生任何终结符号串</p></blockquote><p>消去无用符号的步骤：</p><ul><li>先消去 (2) 类无用符号（引理5.1）：构造新的 $V’$ ，若生成式 $A\rightarrow X_1X_2…X_n$ 右侧的每一 $X_i \in T^*\cup V’$，则把 A 加到 $V’$ 中。</li><li>再消去 (1) 类无用符号（引理5.2）：构造新的 $V’$ 和 $T’$，首先将 S 放入 $V’$ 中，若某个生成式左侧的变元属于 $V’$，则将该生成式右侧的变元放入 $V’$ 中，终结符放入 $T’$ 中。</li></ul><blockquote><p>变元 A 可为零：A 可以派生空串</p><p>$\epsilon$-生成式：右端为空</p></blockquote><p>消去 $\epsilon$-生成式（使 $L(G’) = L(G) -{\epsilon}$）的步骤：</p><ul><li>确定可为零的变元集 Z：先把直接派生空串的变元放入 Z 中，然后检查右侧全为变元的生成式，若右侧变元全在 Z 中，则把该生成式左侧变元放入 Z 中。</li><li>构造新的生成式集合 $P’$：对 $P$ 中所有生成式，检查右侧的每一个符号，如果不属于 Z 则不改变，属于 Z 则改为 $\epsilon$ 或不改变（不改变的情况是防止修改后右侧全为 $\epsilon$）。</li><li>消去无用符号</li></ul><blockquote><p>单一生成式：左右端皆为一个变元</p></blockquote><p>不含空串的 CFL，消去单一生成式的步骤：</p><ul><li>构造新的生成式集合 $P’$：先将 $P$ 中非单一生成式放入 $P’$，对单一生成式 $A\rightarrow B$，如果 $B\rightarrow \alpha$ 是 $P’$ 中元素，则将 $A\rightarrow \alpha$ 放入 $P’$。</li><li>消去无用符号</li></ul><h3 id="CFG-范式"><a href="#CFG-范式" class="headerlink" title="CFG 范式"></a>CFG 范式</h3><blockquote><p><code>Chomksky</code> 范式：每个生成式右侧为两个变元或一个终结符</p></blockquote><p>不含空串的 CFL 转为 <code>Chomsky</code> 范式的步骤：</p><ul><li>消去单一生成式、$\epsilon$-生成式和无用符号</li><li>如果某生成式右侧只有一个符号，则它一定是终结符</li><li>如果某生成式 $p$ 右侧同时包含变元和终结符，则对每个终结符 $a$，添加变元 $C_a$ 和生成式 $C_a \rightarrow a$ ，用这个变元替换掉 $p$ 右侧的对应终结符</li><li>此时，所有生成式除去形如 $A\rightarrow a$ 的，其他生成式右侧不含终结符。如果某个生成式仅包含 $m(m\ge 2)$ 个变元，则添加 $m-2$ 个变元和若干个生成式，使每个生成式右侧仅含2个变元。如 $A\rightarrow B_1B_2B_3$ 可拆成 $A\rightarrow B_1D_1, D_1 \rightarrow B_2B_3$</li></ul><blockquote><p><code>Greibach</code> 范式：每个生成式右侧的第一个符号为终结符</p></blockquote><p>不含空串的 CFL 转为 <code>Greibach</code> 范式的步骤：</p><ul><li>转为 <code>Chomsky</code> 范式</li><li>对变元进行编号。保证每个形如 $A_k \rightarrow A_j\alpha$ 生成式右侧的第一个变元编号 $A_j$ 大于左侧变元，如果不大于则用已检查过的 $A_j \rightarrow A_m\alpha$ 替换，这样右侧第一个变元的编号严格递增，这一步可以在有限次数内完成。如果遇到 $A_k \rightarrow A_k\alpha$ 则加入新的生成式 $B_k \rightarrow \alpha,\ B_k \rightarrow \alpha B_k,\ A_k \rightarrow \beta B_k$，对一切已有的 $A_k \rightarrow \beta$</li><li>处理 $A_i \rightarrow A_j \gamma\ ,j&gt;i$。左部变元编号从大到小开始处理：编号为最大时，生成式右侧第一个符号必为终结符；其他情况，右侧第一个变元用已有生成式代入，代入后编号递增，达到编号最大时，再代入一次，右侧第一个符号也变为终结符。</li><li>处理以新加入的 $B_i$ 变元为左部的生成式。其右侧第一个符号只可能是是终结符或 $A_j$，出现后者时再做一次编号递增即可。</li></ul><h3 id="下推自动机"><a href="#下推自动机" class="headerlink" title="下推自动机"></a>下推自动机</h3><blockquote><p>下推自动机 PDA 是七元组 $(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)$，比 DFA 多了 $\Gamma$ 有穷的栈符号表，$Z_0$ 栈底符号。</p><p>转移函数的形式是 $\delta(q,a,Z) = {(p_1,\gamma_1),…,(p_m,\gamma_m)}$，表示当状态为 q，读入字符 a，且栈顶为 Z 时，将状态改为 p，栈顶改为 $\gamma$。</p><p>瞬时描述 ID 是三元组 $(q,w,\gamma)$，w 为未读过的输入，$\gamma$ 为栈中符号串（左侧为栈顶）。$(p_1,\gamma_1) \in \delta(q,a,Z)$ 可表示为 $(q,aw,Z\alpha) \vdash (p_1, w, \gamma_1\alpha)$</p><p>L(M) 是 M 按终结状态方式接受的语言，N(M) 是 M 按空栈方式接受的语言。它们是等价的。</p></blockquote><p>已知 $M_1$， 构造 $M_2$ 使 $L(M_1) = N(M_2)$：</p><ul><li>添加两个状态 $q_e, q_0’$，$q_e$为接受完毕并准备清空栈，$q_0’$为新的初始状态。添加栈符号 $X_0$ 作为栈底符号</li><li>初始：$\delta’(q_0,\epsilon,X_0)={(q_0,Z_0X_0)}$，$Z_0$ 为 $M_1$ 栈底符号</li><li>终结：$\delta’(q,\epsilon,Z)包含(q_e,\epsilon)$，当 q 是终结状态，并清空栈：$\delta’(q_e,\epsilon,Z)={(q_e,\epsilon)}$</li></ul><p>已知 $M_1$， 构造 $M_2$ 使 $N(M_1) = L(M_2)$：</p><ul><li>添加新的初始状态、终结状态、栈底符号</li><li>初始：状态改为 $M_1$ 的初始状态，将 $M_1$ 的栈底符号压入栈</li><li>终结：当栈顶符号为 $M_2$ 栈底符号是，说明栈为空，如果没有输入了，就转至终结状态</li></ul><p>已知 CFL L，构造 PDA M 使 $L = N(M)$：</p><ul><li>若 L 接受空串，则加上 $\delta(q,\epsilon,S) = {(q,\epsilon)}$</li><li>除去空串，设 G 为产生 L 的 <code>Greibach</code> 文法，构造转移函数：若 $A\rightarrow a\gamma\in P$ 则 $\delta(q,a,A) 包含 (q,\gamma)$</li></ul><p>已知 PDA M， 构造 CFL L 使 $L=N(M)$：</p><ul><li>构造 $V={[q,A,p]|q,p\in Q,A\in\Gamma}\cup{S}$</li><li>初始：$S\rightarrow [q_0,Z_0,q], q \in Q$</li><li>当 $\delta(q,a,A)包含(q_1,B_1B_2…B_m)$ 则有 $[q,A,q_{m+1}]\rightarrow a[q_1,B_1,q_2][q_2,B_2,q_3]…[q_m,B_m,q_{m+1}]$。</li></ul><h3 id="缩胀定理-1"><a href="#缩胀定理-1" class="headerlink" title="缩胀定理"></a>缩胀定理</h3><blockquote><p>基础版：</p><p>$\forall k\ge 0,\exist z\in L, |z| \ge k, z = uvwxy, |vx|\ge 1,|vwx|\le k, \exist i \ge 0, uv^iwx^iy \notin L$， 则 L 不是 CFL。</p></blockquote><p>步骤：</p><ul><li>拆成5份</li><li>中间部分不超过k，要扩展的部分不都为空</li><li>将第2、4部分进行复制，或删除</li></ul><blockquote><p><code>Ogden</code> 定理：</p><p>若 L 是 CFL，存在 $k\ge 0$，对每个 $z\in L, z=uvwxy$，在 z 中标出 $\ge k$ 个特别符号，使：vx 至少包含一个特别符号、vwx 最多包含 k 个特别符号。</p></blockquote><p>CFL 在并、连接、闭包运算下封闭，在交、补运算下不封闭（不可判定）。</p><p>CFG 接受的语言是否为空、是否有穷的问题可判定。</p><p>成员资格问题的 CYK 算法：</p><ul><li>将 CFG 转为 <code>Chomsky</code> 范式。记 $x_{ij}$ 为 $x.substr(i,j)$。</li><li>判别 $x_{ij}$ 可由哪些变元派生，从 $j=1\ to\ n$ 依次判别。<ul><li>当 j = 1 时，可由生成式得出。</li><li>当 j &gt; 1 时，A 可派生出 $x_{ij}$，当且仅当 $\exist A\rightarrow BC$ 且 B 派生 $x_{ij}$ 的前一段，C 派生 $x_{ij}$ 的后一段。</li></ul></li></ul><h2 id="图灵机、递归集、不可判定性（讲义第七、八章）"><a href="#图灵机、递归集、不可判定性（讲义第七、八章）" class="headerlink" title="图灵机、递归集、不可判定性（讲义第七、八章）"></a>图灵机、递归集、不可判定性（讲义第七、八章）</h2><blockquote><p>确定的单带图灵机 TM 是9元组 $(Q,\Sigma,\Gamma,左端标记,空白符号,\delta,初始状态,接受状态,拒绝状态)$</p><p>$\delta(p,a)=(q,b,R)$</p><p>瞬时描述 ID 为 $\alpha_1 q \alpha_2$，（读写头左侧，状态，读写头及其右侧）</p><p>完全的图灵机：对一切输入都能停机</p><p>图灵机接受的语言：递归可枚举集（r.e.）</p><p>完全图灵机接受的语言：递归集</p></blockquote><h3 id="图灵机的构造技术"><a href="#图灵机的构造技术" class="headerlink" title="图灵机的构造技术"></a>图灵机的构造技术</h3><ul><li>有限控制器中的存储：状态可以是 n 元组</li><li>移动：将带上符号吸收到状态上</li><li>多道技术：每个带符号是 n 元组</li><li>查讫符号：带符号是2元组 (字符，标记)</li><li>子程序技术<ul><li>调用：转到子程序的初始状态</li><li>返回：到达子程序的返回状态</li></ul></li></ul><h3 id="图灵机的类型"><a href="#图灵机的类型" class="headerlink" title="图灵机的类型"></a>图灵机的类型</h3><ul><li>双向无限带</li><li>多带</li><li>非确定</li><li>双栈</li><li>带字母最少</li><li>枚举器</li></ul><h3 id="递归集与不可判定问题"><a href="#递归集与不可判定问题" class="headerlink" title="递归集与不可判定问题"></a>递归集与不可判定问题</h3><table><thead><tr><th></th><th>递归集</th><th>递归可枚举</th></tr></thead><tbody><tr><td>补</td><td>封闭</td><td>如果 L 和 L 的补是递归可枚举的，它们是递归的</td></tr><tr><td>并</td><td>封闭</td><td>封闭</td></tr><tr><td>交</td><td>封闭</td><td>封闭</td></tr></tbody></table><blockquote><p>通用图灵机 U 是能模拟任何图灵机的图灵机</p><p>$L(U)={M#x|x\in L(M)}$，#为分隔符</p></blockquote><p>任意给定的 TM M 对任意给定的输入串 x 是否停机的问题是不可判定的。</p><p>对任意给定的 TM M 和输入串 x，M 是否接受 x 的问题是不可判定的。</p><p>给定一个 TM M，它是否接受空串的问题是不可判定的。</p><blockquote><p>A 到 B 的<strong>归约</strong>：存在函数 f，$x\in A \lrarr f(x) \in B$，记 $A\le_m B$，m 表明归约是多对一的。</p></blockquote><p>若 $A\le_m B$：</p><ul><li>B 是 r.e. =&gt; A 是 r.e.</li><li>B 是递归集 =&gt; A 是递归集</li></ul><blockquote><p><strong>性质</strong> 是一个映射：定义域是 $\Sigma^*$ 的 r.e. 子集，值域是 {True, False}</p><p>平凡性质：映射只取 True 或 False</p></blockquote><p>Rice 定理：r.e. 集合类的任一非平凡性质都是不可判定的。</p>]]></content>
    
    
    <categories>
      
      <category>计算理论基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Malloc Lab 动态内存分配器</title>
    <link href="/AcceptedHelper/2021/05/22/MallocLab/"/>
    <url>/AcceptedHelper/2021/05/22/MallocLab/</url>
    
    <content type="html"><![CDATA[<h1 id="Malloc-Lab"><a href="#Malloc-Lab" class="headerlink" title="Malloc Lab"></a>Malloc Lab</h1><p>​    个人的实验报告，放上来给大家参考。</p><p>​    Malloc lab 需要我们编写一个类似 libc malloc 的动态内存分配器，其主要考察动态内存分配器的原理设计以及堆内存的结构组织，同时需要比较强的 DEBUG 能力。最后在不使用BST以及其他全局数据结构的情况下我的方法达到了 97/100 的分数</p><p><a href="https://github.com/ZiYang-xie/Malloc_Lab">ZiYang-xie/Malloc_Lab: CMU Malloc Lab Repo (github.com)</a></p><h2 id="一、空闲块组织结构"><a href="#一、空闲块组织结构" class="headerlink" title="一、空闲块组织结构"></a>一、空闲块组织结构</h2><p>​    在结构设计上我采用了分离存储的显示链表形式来进行组织空闲块，在书上说明了分离存储的思想，但没有具体说明实现方法。在此我使用称为 <strong>Segregated Free List</strong> 的空闲块组织设计，即在堆的低地址分配数量等于 <code>SEG_LEN</code> 的指针，每个指针分别对应着一个大小类，指向正式堆块中的空闲块，相当于 <code>SEG_LEN</code> 个链表。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gquqskpijgj30ff07cdg2.jpg" alt="Segregated Free List"></p><p>​    在我的代码设计中，我以2的幂次分割大小类，由于空闲块最小块大小为16 bytes （包括头尾标记以及前后指针）因此其设计为 {2^4 ~ 2^5} \ {2^5 ~ 2^6} \ {2^6 ~ 2^7} …(类推)</p><p> 为了区分某一空闲块应该被放置在哪个类中，我们需要一个 <strong>get_index</strong> 函数，正常设计也十分简单，即通过一个循环右移，计算位数。在这里我参考了 <strong>Bit twiddling hacks</strong> 著名位运算<em>奇技淫巧</em> 网站，采用了一个位运算的 log2 方式，其可以在 O(1) 的复杂度计算出 log2(x)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_index</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> v)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 本质上是位运算的 log 2, O(1)复杂度</span><br>    <span class="hljs-comment">// 参考 &#x27;Bit twiddling hacks&#x27;</span><br>    <span class="hljs-comment">// Linking: https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogLookup</span><br>    <br>    <span class="hljs-keyword">size_t</span> r, shift;<br>    r = (v &gt; <span class="hljs-number">0xFFFF</span>)   &lt;&lt; <span class="hljs-number">4</span>; v &gt;&gt;= r;<br>    shift = (v &gt; <span class="hljs-number">0xFF</span>) &lt;&lt; <span class="hljs-number">3</span>; v &gt;&gt;= shift; r |= shift;<br>    shift = (v &gt; <span class="hljs-number">0xF</span>)  &lt;&lt; <span class="hljs-number">2</span>; v &gt;&gt;= shift; r |= shift;<br>    shift = (v &gt; <span class="hljs-number">0x3</span>)  &lt;&lt; <span class="hljs-number">1</span>; v &gt;&gt;= shift; r |= shift;<br>                                          r |= (v &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 从 2^4 开始 (空闲块最小 16 bytes)</span><br>    <span class="hljs-keyword">int</span> x = (<span class="hljs-keyword">int</span>)r - <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>) <br>        x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(x &gt;= SEG_LEN) <br>        x = SEG_LEN - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、堆内存设计"><a href="#二、堆内存设计" class="headerlink" title="二、堆内存设计"></a>二、堆内存设计</h2><p>​    在空闲块指针之上，分配正常的堆块，正常的堆块由<strong>序言块</strong> （一个已分配大小为8的块），以及<strong>结尾块</strong>（一个已分配大小为0的块）前后包围，这样可以很方便的检验边界情况，当后继块大小为0，那么便可判断其达到了结尾。之后便记录下全局的开始地址 <code>global_list_start_ptr</code> 即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 空闲块 */</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; SEG_LEN; ++i)<br>  PUT(heap_listp + i*WSIZE, <span class="hljs-literal">NULL</span>);            <span class="hljs-comment">// 初始化空闲块大小类头指针</span><br><br><span class="hljs-comment">/* 分配块 */</span><br>PUT(heap_listp + (i+<span class="hljs-number">0</span>)*WSIZE, PACK(DSIZE, ALLOCATED));  <span class="hljs-comment">/* 序言块头部 */</span><br>PUT(heap_listp + (i+<span class="hljs-number">1</span>)*WSIZE, PACK(DSIZE, ALLOCATED));  <span class="hljs-comment">/* 序言块尾部 */</span><br>PUT(heap_listp + (i+<span class="hljs-number">2</span>)*WSIZE, PACK(<span class="hljs-number">0</span>, ALLOCATED));      <span class="hljs-comment">/* 结尾块头部 */</span><br><br>global_list_start_ptr = heap_listp;<br>heap_listp += (i+<span class="hljs-number">1</span>)*WSIZE; <span class="hljs-comment">// 对齐到起始块有效载荷</span><br></code></pre></td></tr></table></figure><h2 id="三、具体设计"><a href="#三、具体设计" class="headerlink" title="三、具体设计"></a>三、具体设计</h2><p>​    接下来以函数为单位详细介绍实现过程</p><pre><code>### mm_init 初始化堆</code></pre><p>​    堆内存设计块节中以及包含大部分，mm_init 代码，在组织完堆初始化的指针之后就可以进行分配栈空间以一个初始化的空闲块，这涉及到了 extend_heap 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 扩展空栈至 CHUNKSIZE bytes */</span><br>    <span class="hljs-keyword">if</span>(extend_heap(CHUNKSIZE) == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="extend-heap-堆扩展"><a href="#extend-heap-堆扩展" class="headerlink" title="extend_heap 堆扩展"></a>extend_heap 堆扩展</h3><p>​    对于堆扩展，我们调用 mm_sbrk 函数将lab中设计好的抽象 program breaker 上移扩展堆大小，其返回空闲块的头指针，我们设置好它的头尾标记，并通过 coalesce 函数在进行前后空闲块合并之后插入到空闲块链表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">extend_heap</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> asize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *bp;<br>    <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>)(bp = mem_sbrk(asize)) == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-comment">/* 初始化空闲块的头尾和结尾块的头部 */</span><br>    PUT(HDRP(bp), PACK(asize, FREE));                <span class="hljs-comment">/* 空闲块头部 */</span><br>    PUT(FTRP(bp), PACK(asize, FREE));                <span class="hljs-comment">/* 空闲块尾部 */</span><br>    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="hljs-number">0</span>, ALLOCATED));    <span class="hljs-comment">/* 结尾块头部 */</span><br><br>    <span class="hljs-keyword">return</span> coalesce(bp);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="coalesce-合并块"><a href="#coalesce-合并块" class="headerlink" title="coalesce 合并块"></a>coalesce 合并块</h3><p>​    合并块的模式包含四种情况，并且在我的设计模式中，在合并后将空闲块插入到空闲链表中去，形成一体化操作。</p><ul><li><strong>Case1: 前后均不空闲</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; next_alloc)&#123;                   <span class="hljs-comment">/* 前后非空闲 */</span><br>  insert_free_block(bp);<br>  <span class="hljs-keyword">return</span> bp;<br>&#125;<br></code></pre></td></tr></table></figure><p>前后均不空闲的时候就直接插入当前空闲块，并返回bp</p><ul><li><strong>Case2: 后空闲</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)&#123;             <span class="hljs-comment">/* 后空闲 */</span><br>  size += NEXT_BLKSZ(bp);<br>  delete_free_block(NEXT_BLKP(bp));<br>  PUT(HDRP(bp), PACK(size, FREE));<br>  PUT(FTRP(bp), PACK(size, FREE));<br>  PUT(PRED(bp), <span class="hljs-literal">NULL</span>);<br>  PUT(SUCC(bp), <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    后空闲的时候就从空闲链表中删除后方空闲块，并把当前块的头部和后部块的尾部大小设计为扩展后大小 <em>( 由于 FTRP 中调用了 HDRP，所以先设计HDRP的size之后FTRP能够正确定位到尾部 )</em> 并且设置空闲块前驱后继指针为NULL做好清理。</p><ul><li><strong>Case3:</strong> 前空闲</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(!prev_alloc &amp;&amp; next_alloc) &#123;            <span class="hljs-comment">/* 前空闲 */</span><br>  size += PREV_BLKSZ(bp);<br>  delete_free_block(PREV_BLKP(bp));<br><br>  PUT(FTRP(bp), PACK(size, FREE));<br>  PUT(HDRP(PREV_BLKP(bp)), PACK(size, FREE));<br><br>  bp = PREV_BLKP(bp);<br>  PUT(PRED(bp), <span class="hljs-literal">NULL</span>);<br>  PUT(SUCC(bp), <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    前空闲就从空闲链表中删除前方空闲块，并且注意分配的头部标记是前一块的头部标记，其余逻辑和 Case2类似</p><ul><li><strong>Case4:</strong> 前后均非空闲</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 前后均空闲 */</span><br>  size += NEXT_BLKSZ(bp) + PREV_BLKSZ(bp);<br>  delete_free_block(PREV_BLKP(bp));<br>  delete_free_block(NEXT_BLKP(bp));<br>  PUT(HDRP(PREV_BLKP(bp)), PACK(size, FREE));<br>  PUT(FTRP(NEXT_BLKP(bp)), PACK(size, FREE));<br>  bp = PREV_BLKP(bp);<br>  PUT(PRED(bp), <span class="hljs-literal">NULL</span>);<br>  PUT(SUCC(bp), <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    前两种的结合，不多赘述</p><h3 id="insert-free-block-插入空闲链表"><a href="#insert-free-block-插入空闲链表" class="headerlink" title="insert_free_block 插入空闲链表"></a>insert_free_block 插入空闲链表</h3><p>​    插入空闲链表算是一个比较重要的函数，其关乎着空闲块的组织结构，在这里我采用的是<strong>地址排序</strong>的策略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert_free_block</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fbp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 地址排序 - Address Order</span><br>    <span class="hljs-keyword">void</span> *succ = root;<br>    <br>    <span class="hljs-keyword">while</span>(SUCC_BLKP(succ))&#123;<br>        succ = (<span class="hljs-keyword">char</span> *)SUCC_BLKP(succ);<br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)succ &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)fbp)&#123;<br>            <span class="hljs-comment">// 安装地址顺序插入空闲块</span><br>            <span class="hljs-comment">// PRED_BLKP(succ) &lt;-&gt; fbp &lt;-&gt; succ</span><br>            <span class="hljs-keyword">char</span> *tmp = succ;<br>            succ = (<span class="hljs-keyword">char</span> *)PRED_BLKP(succ);<br>            PUT(SUCC(succ), fbp);<br>            PUT(PRED(fbp), succ);<br>            PUT(SUCC(fbp), tmp);<br>            PUT(PRED(tmp), fbp);<br>            <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> INDEBUG</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;succ(PRE): %p \t tmp(SUCC): %p \t&quot;</span>, succ, tmp);<br>                print_free_list(<span class="hljs-string">&quot;Insert&quot;</span>);<br>            <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Base Case &amp; Last Case </span><br>    <span class="hljs-comment">// 当前大小类无空闲块 或者 在地址分配时当前空闲块地址最大被分配在最后</span><br>    PUT(SUCC(succ), fbp);<br>    PUT(PRED(fbp), succ);<br>    PUT(SUCC(fbp), <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    首先获得目标块的 index，即属于二的几次幂，之后通过 <code>global_list_start_ptr</code> 加上 index 偏移定位到其属于的大小类链表的 root 指针，如果root指针有指向就进行地址顺序的排序，如果找到后部块地址大于插入块，就把该插入块插到上述块的前部。</p><p>​    如果root没有指向，即当前该大小类中没有空闲块，或者按地址序，该块地址大小最大则进行直接的分配在succ之后。</p><h3 id="delete-free-block-删除空闲块"><a href="#delete-free-block-删除空闲块" class="headerlink" title="delete_free_block 删除空闲块"></a>delete_free_block 删除空闲块</h3><p>​    删除空闲块要注意，这里常见的bug是和 insert_free_block 一同出现的指针维护不良，导致删除不存在的块，或者访问 nullptr 的前后继以及指针越界问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete_free_block</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fbp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// NORMAL: GOT A SUCCESSOR AND PREDECESSOR</span><br>    <span class="hljs-keyword">if</span>(SUCC_BLKP(fbp) &amp;&amp; PRED_BLKP(fbp))&#123;<br>        PUT(SUCC(PRED_BLKP(fbp)), SUCC_BLKP(fbp));<br>        PUT(PRED(SUCC_BLKP(fbp)), PRED_BLKP(fbp));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(PRED_BLKP(fbp))&#123; <span class="hljs-comment">// LAST BLOCK</span><br>        PUT(SUCC(PRED_BLKP(fbp)), <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    PUT(SUCC(fbp), <span class="hljs-literal">NULL</span>);<br>    PUT(PRED(fbp), <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    正常情况是当前块是链表中间节点，重新连接好前后，把其从链表上脱离即可。如果是最后一个节点，就直接把前继节点的后继指针置为空。最后做好当前删除块的清理工作，把其前后继指针置为NULL</p><h3 id="mm-malloc-分配空闲块"><a href="#mm-malloc-分配空闲块" class="headerlink" title="mm_malloc 分配空闲块"></a>mm_malloc 分配空闲块</h3><p>​    mm_malloc 是该lab中的主要函数，用于控制分配内存块的工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mm_malloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> asize = align_size(size);    <span class="hljs-comment">/* 调整后的块大小 */</span><br>    <span class="hljs-keyword">size_t</span> extendsize;                  <span class="hljs-comment">/* 扩展堆大小 */</span><br>    <span class="hljs-keyword">char</span> *bp;<br><br>    <span class="hljs-comment">/* Trivial Case */</span><br>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* 寻找适配 */</span><br>    <span class="hljs-keyword">if</span>((bp = find_fit(asize, get_index(asize))) != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> place(bp, asize);<br><br>    <span class="hljs-comment">/* 未找到适配，分配更多堆空间 */</span><br>    extendsize = MAX(asize, CHUNKSIZE);<br>    <span class="hljs-keyword">if</span>((bp = extend_heap(extendsize)) == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">return</span> place(bp, asize);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    首先要做好分配大小的对齐，这里定义了一个util函数 align_size 用来对齐块大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">align_size</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* 调整块大小 */</span><br>    <span class="hljs-keyword">if</span>(size &lt;= DSIZE) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*DSIZE;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> DSIZE * ((size + (DSIZE) + (DSIZE - <span class="hljs-number">1</span>)) / DSIZE);<br><br>    <span class="hljs-comment">// Code Never Went Here</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    之后逻辑就是通过 find_fit 在空闲链表中寻找适配，如果没找到适配就进行 heap_extend，每次最小扩展 <code>CHUNKSIZE</code> bytes，这里我将 <code>CHUNKSIZE</code> 设为 512</p><p> <strong>(有讲究，如果大于520就会导致realloc2的第一次分配 512 就能够成功，这样之后alloc的块就跟在512块后，就不能成功的将 realloc 的 0 号 block 安排在块位，导致无法通过 extend_heap 来提高性能)</strong></p><p>最后放置空闲块，使用place函数进行分配和分割</p><h3 id="find-fit-寻找适配"><a href="#find-fit-寻找适配" class="headerlink" title="find_fit 寻找适配"></a>find_fit 寻找适配</h3><p>​    我使用的是简单的首次适配，即从小到大遍历分离空闲链表，找到第一块适合的空闲块。由于每个空闲链表内部是按地址顺序排列而非大小排列，所以其效果并非严格等同于 best_fit 但是由于大小分块的组织结构，其效果又好于完全不按空间大小排序的适配方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">find_fit</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> seg_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// First Fit</span><br>    <span class="hljs-keyword">char</span>* res;<br>    <span class="hljs-keyword">while</span>(seg_idx &lt; SEG_LEN)&#123;<br>        <span class="hljs-keyword">char</span> *root = global_list_start_ptr + seg_idx * WSIZE;<br>        <span class="hljs-keyword">char</span> *bp = (<span class="hljs-keyword">char</span> *)SUCC_BLKP(root);<br>        <span class="hljs-keyword">while</span>(bp)&#123;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-keyword">size_t</span>)CRT_BLKSZ(bp) &gt;= size)<br>                <span class="hljs-keyword">return</span> bp;<br>            <br>            bp = (<span class="hljs-keyword">char</span> *)SUCC_BLKP(bp);<br>        &#125;<br>        <span class="hljs-comment">// 在这类中未找到适合，在更大类中寻找</span><br>        seg_idx++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="place-分配块"><a href="#place-分配块" class="headerlink" title="place 分配块"></a>place 分配块</h3><p>​    分配块这里有说法了，第一层是分配空闲块的时候，如果当前适配的块大小比需要分配的大很多（超出最小空闲块大小 16bytes）那么我们就可以通过分割来减小内部碎片。</p><p>​    并且这个分割也是很有讲究，我们可以设计当需要分配的空间较大时例如大于64 bytes，我们就将其分配在空闲块的后部，将前部分割出来作为新的空闲块。如果小于就直接分配在当前空闲块的前部，将后部分割出来作为新的空闲块。这样的组织方式有两方面好处，</p><ul><li>一方面是其进行了大小分类，有利于块的合并</li><li>另一方面是对于 realloc2 的测试 trace，我们通过前部切分的方式，使 512 块后再次分配的两 128 块占用前部空间，这样可以使 512 块始终是最后一块即其后继块是结尾块，那么在 realloc 它的时候我们就可以直接通过 extend_heap 达到如此一来可以大大提高内存利用率，<strong>将realloc1、2的util提升至近100%！</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">place</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *bp, <span class="hljs-keyword">size_t</span> asize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> blk_size = CRT_BLKSZ(bp);<br>    <span class="hljs-keyword">size_t</span> rm_size = blk_size - asize;<br><br>    <span class="hljs-keyword">if</span>(!GET_ALLOC(HDRP(bp)))<br>        delete_free_block(bp);<br>    <span class="hljs-comment">// 剩余空间大于最小块大小的可分割的情况</span><br>    <span class="hljs-keyword">if</span>(rm_size &gt;= <span class="hljs-number">2</span>*DSIZE)&#123;<br>        <span class="hljs-comment">// 当块大小大于 64 时将其有效载荷放在空闲块后部，前部切分出来作为空闲块</span><br>        <span class="hljs-keyword">if</span>(asize &gt; <span class="hljs-number">64</span>)&#123;<br>            PUT(HDRP(bp), PACK(rm_size, FREE));<br>            PUT(FTRP(bp), PACK(rm_size, FREE));<br>            PUT(HDRP(NEXT_BLKP(bp)), PACK(asize, ALLOCATED));<br>            PUT(FTRP(NEXT_BLKP(bp)), PACK(asize, ALLOCATED));<br>            coalesce(bp);<br>            <span class="hljs-keyword">return</span> NEXT_BLKP(bp);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            PUT(HDRP(bp), PACK(asize, ALLOCATED));<br>            PUT(FTRP(bp), PACK(asize, ALLOCATED));<br>            PUT(HDRP(NEXT_BLKP(bp)), PACK(rm_size, FREE));<br>            PUT(FTRP(NEXT_BLKP(bp)), PACK(rm_size, FREE));<br><br>            coalesce(NEXT_BLKP(bp));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 不可分割情况</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        PUT(HDRP(bp), PACK(blk_size, ALLOCATED));<br>        PUT(FTRP(bp), PACK(blk_size, ALLOCATED));<br>    &#125;<br>    <span class="hljs-keyword">return</span> bp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mm-free-释放块"><a href="#mm-free-释放块" class="headerlink" title="mm_free 释放块"></a>mm_free 释放块</h3><p>​    直接设置空闲，并释放同时合并，没什么好说的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mm_free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Freeing.....\n&quot;</span>);<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-keyword">char</span> *bp = ptr;<br>    <span class="hljs-keyword">size_t</span> size = CRT_BLKSZ(bp);<br><br>    PUT(HDRP(bp), PACK(size, FREE));<br>    PUT(FTRP(bp), PACK(size, FREE));<br>    coalesce(bp);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mm-realloc-重分配块"><a href="#mm-realloc-重分配块" class="headerlink" title="mm_realloc 重分配块"></a>mm_realloc 重分配块</h3><p>​    mm_realloc 能否做好是分数能否上 90 的关键，其主要策略有两个</p><ul><li><p><strong>空闲块融合</strong></p><p>一在重分配的时候，如果后方有空闲块可以进行融合，再看空间够不够，如果够了就不用释放再分配了。</p><p>（同时前融合也应当有相应的效果，前融合要注意内部载荷数据的移动，但其实观察 trace 文件下的block组织表现，发现其实前融合很少甚至没有，对性能影响不大，之后便在代码中删除了）</p></li><li><p><strong>尾部堆扩展</strong></p><p>就是之前提到的如果要重分配的块是尾部块就执行 extend_heap 就行了，不需要释放再分配。同时注意到了 trace 文件中反复 realloc 首次分配的块，于是和 place 中提到的策略相互结合可以达到将首次分配的块移动到末尾的效果。</p></li></ul><p>其余就是一些基础写法，在注释中已经体现，还有需要注意一下<strong>分配大小的对齐</strong>和特殊情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mm_realloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 如果 ptr == NULL 直接分配</span><br>    <span class="hljs-keyword">if</span>(ptr == <span class="hljs-literal">NULL</span>)    <br>        <span class="hljs-keyword">return</span> mm_malloc(size);<br>    <span class="hljs-comment">// 如果 size == 0 就释放</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)&#123;<br>        mm_free(ptr);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">size_t</span> asize = align_size(size), old_size = CRT_BLKSZ(ptr);<br>    <span class="hljs-keyword">size_t</span> mv_size = MIN(asize, old_size);<br>    <span class="hljs-keyword">char</span> *oldptr = ptr;<br>    <span class="hljs-keyword">char</span> *newptr;<br><br>    <span class="hljs-keyword">if</span>(old_size == asize)<br>        <span class="hljs-keyword">return</span> ptr;<br>    <br>    <span class="hljs-keyword">size_t</span> prev_alloc =  GET_ALLOC(FTRP(PREV_BLKP(ptr)));<br>    <span class="hljs-keyword">size_t</span> next_alloc =  GET_ALLOC(HDRP(NEXT_BLKP(ptr)));<br>    <span class="hljs-keyword">size_t</span> next_size = NEXT_BLKSZ(ptr);<br>    <span class="hljs-keyword">char</span> *next_bp = NEXT_BLKP(ptr);<br>    <span class="hljs-keyword">size_t</span> total_size = old_size;<br><br>    <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; !next_alloc &amp;&amp; (old_size + next_size &gt;= asize))&#123;    <span class="hljs-comment">// 后空闲  </span><br>        total_size += next_size;<br>        delete_free_block(next_bp);<br>        PUT(HDRP(ptr), PACK(total_size, ALLOCATED));<br>        PUT(FTRP(ptr), PACK(total_size, ALLOCATED));<br>        place(ptr, total_size);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!next_size &amp;&amp; asize &gt;= old_size)&#123;   <span class="hljs-comment">// 如果后部是结尾块，则直接 extend_heap</span><br>        <span class="hljs-keyword">size_t</span> extend_size = asize - old_size;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>)(mem_sbrk(extend_size)) == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <br>        <br>        PUT(HDRP(ptr), PACK(total_size + extend_size, ALLOCATED));<br>        PUT(FTRP(ptr), PACK(total_size + extend_size, ALLOCATED));<br>        PUT(HDRP(NEXT_BLKP(ptr)), PACK(<span class="hljs-number">0</span>, ALLOCATED)); <br>        place(ptr, asize);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;   <span class="hljs-comment">// 直接分配</span><br>        newptr = mm_malloc(asize);<br>        <span class="hljs-keyword">if</span>(newptr == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">memcpy</span>(newptr, ptr, MIN(old_size, size));<br>        mm_free(ptr);<br>        <span class="hljs-keyword">return</span> newptr;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关于DEBUG"><a href="#关于DEBUG" class="headerlink" title="关于DEBUG"></a>关于DEBUG</h2><p>​    代码中为了 DEBUG 定义了大量 debug util 函数和 Error Handler，如果想清晰的看清楚堆块的组织结构，调用它们是很有帮助的。还有 debug 要善用 gdb…</p><h2 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqqcdfltwxj309s088aal.jpg"></p><p>​    在不使用BST和全局数据结构的情况下达到了 97/100 的分数，还不错。</p><h2 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h2><p>​    这个Lab用了我2、3天的时间，是比较难的，需要用心 DEBUG 考验 gdb的使用。Malloc Lab 还是很好玩的，ddl之后我可能会考虑进一步优化，采用BST结构尽量做到接近 100/100</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Malloc</tag>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 动态内存分配机制详解</title>
    <link href="/AcceptedHelper/2021/05/21/Dynamic%20Memory%20Allocation/"/>
    <url>/AcceptedHelper/2021/05/21/Dynamic%20Memory%20Allocation/</url>
    
    <content type="html"><![CDATA[<p>​    动态内存分配是虚拟内存组织中的核心概念，理解它对于帮助整个linux虚拟内存的组织以及堆上内存分配过程。本文会系统介绍动态内存的分配机制以及内存堆块的组织形式，并最后以 CMU CSAPP Malloc Lab 为例来详细讲解。</p><p><strong>Malloc Lab 代码：<a href="https://github.com/ZiYang-xie/Malloc_Lab">ZiYang-xie/Malloc_Lab: CMU Malloc Lab Repo (github.com)</a></strong> </p><p>在开始介绍 malloc 机制前，我们先看一下虚拟内存的组织形式。</p><h1 id="【序】虚拟内存组织形式"><a href="#【序】虚拟内存组织形式" class="headerlink" title="【序】虚拟内存组织形式"></a>【序】虚拟内存组织形式</h1><p>​    linux虚拟内存形式安装堆栈形式组织，栈位于内存高地址，分为内核栈和用户栈，增长方向从高到低。而堆位于内存的低地址，是程序员进行动态内存分配的空间，增长方向由低到高。堆和栈中间是共享映射空间，用于共享库在内存中的映射，这样每次如果有不同代码调用相同的共享库，就不需要再次向内存中复制一份副本，节省了时间和空间。</p><p>​    栈内存的更高地址用于存放一些全局数据结构</p><p>​    堆内存的更低地址按地址从低到高放置着代码段（.text）、已分配数据段（.data）、未分配数据段（.bss）。你可能还听说过 COMMON 段专门储存未初始化全局变量，真正的.bss存储未初始化的静态变量以及初始化为0的全局和静态变量 [1]，组织形式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">SECTIONS &#123; <br>  .text : &#123; *(.text) &#125;<br>  .data : &#123; *(.data) &#125; <br>  .bss :  &#123; *(.bss)  *(COMMON) &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>虚拟内存的大致组成形式如下图所示。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqr0n9olxfj30e80e0gn3.jpg"></p><p>​    可以看到代码段从 <em>0x40000000</em> 处开始，从0到0x40000000的内存地址单纯是未被映射，代码段和0地址之间相隔一段距离在早期是为了防止 nullptr 对代码段的修改<em>（此处仅凭记忆，真实性需要进一步验证</em>）。但如今权限设计更加完善，上述意义已不再成立，这就变成了一种约定俗成的规则。</p><p>在了解了虚拟内存的大致组织模式之后，我们便可以开始讲解 Malloc 的基本机制。</p><h1 id="【一】动态内存分配的实现方式"><a href="#【一】动态内存分配的实现方式" class="headerlink" title="【一】动态内存分配的实现方式"></a>【一】动态内存分配的实现方式</h1><p>​    Linux动态内存分配的实现方式是由 mmap, munmap 以及 brk, sbrk 这四个系统函数联合完成的。</p><h2 id="mmap-与-munmap"><a href="#mmap-与-munmap" class="headerlink" title="mmap 与 munmap"></a>mmap 与 munmap</h2><p><strong>mmap</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">size_t</span> length, <span class="hljs-keyword">int</span> prot, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-function"><span class="hljs-params">           <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> offset)</span></span>;<br></code></pre></td></tr></table></figure><p>mmap 创建一个新的虚拟内存空间和文件设备之间的映射。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqr27vczrhj30jd0a9tah.jpg"></p><p>​    其中 addr 代表分配开始地址，fd是相应文件描述符，len是指文件存储部分映射的长度，offset指的是从文件头开始offset距离开始分配。</p><ul><li>prot包含权限位</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">PROT_EXEC <span class="hljs-comment">// 可执行</span><br>PROT_READ <span class="hljs-comment">// 可读</span><br>PROT_WRITE <span class="hljs-comment">// 可写</span><br>PROT_NONE <span class="hljs-comment">// 不可访问</span><br></code></pre></td></tr></table></figure><ul><li>Flags 表示映射对象类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">MAP_ANON <span class="hljs-comment">// 匿名请求二进制零的</span><br>MAP_PRIVATE <span class="hljs-comment">// 私有的</span><br>MAP_SHARED <span class="hljs-comment">// 共享的</span><br></code></pre></td></tr></table></figure><p><strong>munmap</strong></p><p>取消相应地址内存块的映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">size_t</span> length)</span></span>;<br></code></pre></td></tr></table></figure><p>很好理解取消开始地址为 addr 长度为 length 的内存映射。</p><h2 id="brk-与-sbrk"><a href="#brk-与-sbrk" class="headerlink" title="brk 与 sbrk"></a>brk 与 sbrk</h2><p>​    brk, sbrk 用来移动 program break 指向的指针来扩展堆内存，program break 位于堆顶未初始化数据段末尾之后，通过移动 program break 指针来动态控制堆的大小。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqri33m8lkj30ic0huq62.jpg" style="zoom:50%;" /><p><strong>brk</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">brk</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr)</span></span>;<br></code></pre></td></tr></table></figure><p>​    brk 会在允许的情况下简单的将 program break 设为 addr 地址，来控制堆内存大小。相当于 program break 的绝对移动</p><p><strong>sbrk</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">sbrk</span><span class="hljs-params">(<span class="hljs-keyword">intptr_t</span> increment)</span></span>;<br></code></pre></td></tr></table></figure><p>​    sbrk 会在允许的情况下将 program break 指针加 increment 值，返回扩展前的 program break 地址。当<code>increment</code>为正值时，堆被扩展；为0时，返回当前 program break 的指针；为负值时，堆被收缩。相当于 program break 的相对移动</p><p>​    值得注意的是，当无法扩展时 (申请了大于允许的内存，或碰到了共享内存段)，sbrk会返回 (void *)-1 并且会设置 errorno 为 <strong>ENOMEM</strong>（ENO Memory）</p><h3 id="关于-sbrk-的更多细节"><a href="#关于-sbrk-的更多细节" class="headerlink" title="关于 sbrk 的更多细节"></a>关于 sbrk 的更多细节</h3><p>​    sbrk 实际上是 linux 的一个上古函数，如今大多数内存分配器都倾向于使用 mmap 而不使用 sbrk，是因为 sbrk 是线程不安全的。由于 sbrk 的组织形式是对 program break 的相对移动来进行对扩展，那么对堆块的组织释放方式只能使用 LIFO。假设 sbrk 函数是原子的，在多进程调用时，如果一个进程要释放一个块，且其正好位于结尾program break处，我们选择 increment 为一个负值进行堆收缩（这是正确的）；但在我们还未释放的时候，另一个进程选择分配内存，调用 sbrk。在分配后我们继续进行释放此时我们需要释放的块后增加了一个新块，再调用 sbrk 会导致另一个进程分配的块被释放从而引发错误。</p><p>​    为了解决这个问题，我们也可以自己设计一个进程安全的 sbrk 函数，称为 sbrk_safe</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">sbrk_safe</span><span class="hljs-params">(<span class="hljs-keyword">intptr_t</span> increment, <span class="hljs-keyword">void</span> *expect_top)</span></span>;<br></code></pre></td></tr></table></figure><p>​    其增加了一个参数expect_top，思想很简单，就是在每次调用 sbrk_safe 的时候将选择释放块的内存地址填入 expect_top，函数中验证其是否是在堆顶，如果不是就返回错误。</p><p>​    （另外 sbrk 可能还有其他问题，比如受到 mmap 分配内存和共享内存的阻碍导致内存分配的间断。这里有待进一步研究探讨）</p><h1 id="【二】动态内存分配器的设计"><a href="#【二】动态内存分配器的设计" class="headerlink" title="【二】动态内存分配器的设计"></a>【二】动态内存分配器的设计</h1><p>​        对于堆上的动态内存分配，我们通常将其组织为“块”的模式，一个块就是指一段连续内存地址，而根据其是否被分配数据又被划分为<strong>空闲块</strong>和<strong>分配块</strong>两种。</p><h2 id="序、内存块结构"><a href="#序、内存块结构" class="headerlink" title="序、内存块结构"></a>序、内存块结构</h2><p>​    首先我们需要了解一个简单的技巧，就是如果有空闲块相邻时我们是可以将其进行合并为一个空闲块的，这样一来我们就可以分配更大的内存，并减少内存的碎片程度。注意到由于我们需要对块进行分配和合并，所以我们必须要知道块的<strong>大小信息</strong>和<strong>块的分类</strong>，因而一个内存块中其并不是所有位置都存储着有效信息。以32位系统为例，双字对齐（8 bytes）我们设计一个块的头部一个字大小（4 bytes）放置着块的大小信息和分配信息，由于是双字对齐的，所以块大小的后3位永远是0（1000）, 因此我们用前29位放大小信息，后3位放置分配信息（实际上是最后一位）001表示已分配、000表示空闲。中间放置有效载荷、即数据段，尾部可有一个填充。</p><p>​    最后注意到我们需要对块进行<strong>合并</strong>（在后文中我们会详细讨论合并策略），所以在尾部也放置一个大小和分配标记有利于下一块相邻块快速找到上一块的分配状态和大小来达成向前合并的操作，所以我们在脚部也增加一个字大小（4 bytes）和头部相同的大小分配标记。这个特征称为<strong>边界标记</strong></p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqrjzzz4iaj30go0dwjyj.jpg" style="zoom:50%;" /><h2 id="一、内存碎片"><a href="#一、内存碎片" class="headerlink" title="一、内存碎片"></a>一、内存碎片</h2><p>​        关于内存分配，首先我们要有一个直观，在组织过程中我们确实可以简单的每次分配内存都创建一个所需大小的块，但经过频繁的分配释放，很快堆上的整块内存就会被划分为十分杂乱的小块。这种情况称之为内存碎片化，内存碎片化是一个十分严重的问题，其可能导致内存极大的浪费，因此要理解动态内存分配器的设计之前首先我们需要理解内存碎片的概念，来帮助我们更好的设计一个性能更加优良的分配器。</p><p>​    关于内存碎片根据其表现形式可以分为两类，内部碎片和外部碎片。</p><h3 id="内部内存碎片"><a href="#内部内存碎片" class="headerlink" title="内部内存碎片"></a>内部内存碎片</h3><p>​    内部内存碎片可以有一个直观的理解（虽然可能有点夸张），就是如果你仅仅需要 1kb 的内存用于存放数据，但是你申请了 2GB 大小的内存空间用来存这 1kb 的数据，那么里面大部分的内存全部都被浪费掉了，这时候如果你再要申请内存，空闲的内存可能就不够了。这就是内部碎片。</p><p>​    这时候有人可能会问，那么我们之间分配需要分配的内存大小就好了啊？那为什么内部碎片还会产生呢？确实说的很对，。但有时候由于内存对齐需要以及分配器策略等影响我们并不能够直接分配正好就是需求大小的内存块，其产生机制我将会在下文中进一步深入讲解</p><h3 id="外部内存碎片"><a href="#外部内存碎片" class="headerlink" title="外部内存碎片"></a>外部内存碎片</h3><p>​    外部内存碎片的产生主要源于频繁的大小不一的内存分配和释放过程。经过一系列的分配释放，最后整块的内存会被切分成空闲块分配块相互交杂的情况，如下图所示，这时候如果我们想要再分配一个 1000 kb 的数据块，可能所有的空闲块加起来是大于 1000 kb 的但是由于没有一个空闲块是大于 1000 kb 的就会导致内存分配的失败。同时由于内存映射已经建立，重整虚拟内存会导致整个程序到虚拟内存，虚拟内存到物理内存的映射表都需要更改，这种花费是我们无法承受的，所以我们需要设计更好的分配方式尽量避免这种碎片化情况的产生。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqrji3uyl1g30b404l3yd.gif"></p><h2 id="二、空闲块组织模式"><a href="#二、空闲块组织模式" class="headerlink" title="二、空闲块组织模式"></a>二、空闲块组织模式</h2><p>​    关于动态内存分配器的设计其有不同的设计策略，而一种最为常见的区分方式是通过空闲块的组织模式来区分不同的分配器，这里简单介绍两种来自 CSAPP 的空闲块组织模式。</p><h3 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h3><p>​    关于隐式空闲链表，它组织内存空闲块的形式非常简单，可以说是根本没有任何组织，我们可以通过遍历所有堆块（因为我们知道每一个堆块的大小）并验证其是否空闲来找到所有空闲块。所以将这种空闲块组织模式成为隐式空闲链表组织模式。</p><ul><li><p><strong>优点：</strong>简单、无需其他数据结构、节省空间</p></li><li><p><strong>缺点：</strong>时间复杂度高，每次寻找空闲块都需要 O(n) 时间复杂度遍历所有堆块</p></li></ul><h3 id="显示空闲链表"><a href="#显示空闲链表" class="headerlink" title="显示空闲链表"></a>显示空闲链表</h3><p>​    关于显示空闲链表，其是通过在空闲块中间添加两个指针分别指向前趋空闲块和后继空闲块，将空闲块串联成一个链表的模式。这时候我们在全局需要存储一个入口指针指向第一个空闲块，因为其显示的将所有空闲块进行串联，所以我们称这种组织模式为显示空闲链表</p><ul><li><strong>优势：</strong>速度快效率高，只需要 O(m) 遍历所有空闲块</li><li><strong>缺点：</strong>组织复杂，且最小块大小较大（空闲块需要多两个指针的大小）</li></ul><p>在实际的动态内存分配器中我们常常使用显示空闲链表的模式，因为相比于它的效率提升，其多出的空间花费是微不足道的。</p><h2 id="三、空闲块适配模式"><a href="#三、空闲块适配模式" class="headerlink" title="三、空闲块适配模式"></a>三、空闲块适配模式</h2><p>​    说完了空闲块组织模式，我们来谈谈常见的空闲块适配模式，为什么要适配空闲块？当然是因为请求分配一个内存大小的时候要找到一个相应合适的内存块，空闲块适配这个概念和前面讲到的内存碎片有着很大的联系，如果我们选的太大那么就会导致内部碎片的产生（如果没有其他分割策略），如果外部碎片太多，那么我们可能根本找不到合适的空闲块。</p><p>接下来我主要介绍三类空闲块组织模式，首次适配（First Fit）、再次适配（Next Fit)和最佳适配（Best Fit）</p><ul><li><strong>首次适配：</strong> 遍历空闲块找到的第一个合适的空闲块就用来分配 （速度快，内存不一定节省）</li><li><strong>再次适配：</strong>不从头找起，从上一次分配的空闲块继续往下找，找到的第一个适合的空闲块就用来分配 （默认了分配内存的大小基本一致，需要依赖于程序的内存分配特点和空闲块大小组织方式，效率不固定）</li><li><strong>最佳适配：</strong>遍历所有空闲块，找到一个在能够符合分配条件下最小的空闲块来最大化减少内部碎片的产生（内存利用率最佳，但效率较低）</li></ul><h2 id="四、空闲块顺序安排"><a href="#四、空闲块顺序安排" class="headerlink" title="四、空闲块顺序安排"></a>四、空闲块顺序安排</h2><p>​    空闲块顺序安排这个概念是归属于显示空闲链表组织模式下的，隐式空闲链表就完全不会有这个概念（因为根本没有组织xs）</p><p>​    下面来讲讲空闲块的顺序安排，其主要有两种组织形式，LIFO 顺序和地址顺序</p><ul><li><strong>LIFO 顺序：</strong>把释放块插入到空闲链表的开始处，结合首次适配策略，我们便每次会分配适合分配大小的最近释放的空闲块。</li></ul><p>由于我们每次都在空闲块链表开头插入新释放的空闲块，其释放能够在常数时间内 O(1) 完成。</p><ul><li><strong>地址顺序：</strong> 我们也可以简单地按地址顺序安排空闲块链表，即让空闲块链表中空闲块地址从低到高排序，这样符合堆的地址增长方式。</li></ul><p>通常情况下地址顺序结合首次适配的方式比LIFO结合首次适配拥有<strong>更高的内存利用率</strong>，这是从实验中得出的</p><h2 id="五、空闲块的存储技术"><a href="#五、空闲块的存储技术" class="headerlink" title="五、空闲块的存储技术"></a>五、空闲块的存储技术</h2><h3 id="分离适配与分段空闲链表（-Segregated-Free-List-）"><a href="#分离适配与分段空闲链表（-Segregated-Free-List-）" class="headerlink" title="分离适配与分段空闲链表（ Segregated Free List ）"></a>分离适配与分段空闲链表（ Segregated Free List ）</h3><p>​    在实际应用中，我们可以对空闲块的组织模式进行一定的大小分类，通过分类的方式，我们可以进一步减少空闲块的索引时间。</p><p><strong>（这里的思想是运用的分层级的思想，这一思想在计算机科学中无处不在，例如数据库中的多级索引，多级页表的组织等，其实际上就是用分组的形式形成层级结构，通过使用更多的空间来换取索引的时间，是典型的空间换时间模式）</strong></p><p>我们将根据空闲块大小的分类得出的不同类称为大小类，通常在一个最简单的应用中，我们可以使用二的幂次来对其进行表示。在实现上，我们可以将其组织为一个叫做分段空闲链表（Segregated Free List）的组织形式（如下图所示）。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqrl8pm35nj30wc0u0aj5.jpg" style="zoom:40%;" /><p>​    例如我们将空闲块按二的幂次分为 MAX_ORDER 个大小类，每个 index = i 维护一个链表，连接着一类大小位于 $ 2^{i - 1}$ ~ $2^i$ 的空闲块，这样的组织形式，我们就可以先根据分配需求索引大类的大小，定位之后再进入链表根据适配规则适配空闲块。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <em>Computer Systems: A Programmer’s Perspective</em>, 3/E (CS:APP3e). Randal E. Bryant and David R. O’Hallaron, Carnegie Mellon University.  Page 469</p><p>[2] <a href="https://lifecs.likai.org/2010/02/sbrk-is-not-thread-safe.html">Life of a Computer Scientist: sbrk() is not thread safe (likai.org)</a></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Malloc</tag>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算理论基础思维导图</title>
    <link href="/AcceptedHelper/2021/04/07/mind-map-for-intro-to-comp-thry/"/>
    <url>/AcceptedHelper/2021/04/07/mind-map-for-intro-to-comp-thry/</url>
    
    <content type="html"><![CDATA[<p>这是计算理论基础前五周的思维导图。(pdf请使用chrome浏览器)</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/FDU19CS/AcceptedHelper@hexo/source/_posts/mind-map-for-intro-to-comp-thry/mind-map-for-intro-to-comp-thry.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>计算理论基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>孙若诗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0324ICSHW问题汇总</title>
    <link href="/AcceptedHelper/2021/03/30/0324ICSHW%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/AcceptedHelper/2021/03/30/0324ICSHW%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="1-关于作业7-13B，为什么两个文件objdump的结果一样，但是通过diff比较二进制文件得出的结果不同？"><a href="#1-关于作业7-13B，为什么两个文件objdump的结果一样，但是通过diff比较二进制文件得出的结果不同？" class="headerlink" title="1.关于作业7.13B，为什么两个文件objdump的结果一样，但是通过diff比较二进制文件得出的结果不同？"></a>1.关于作业7.13B，为什么两个文件objdump的结果一样，但是通过diff比较二进制文件得出的结果不同？</h2><p>-g主要是加了debug section，它包含了符号表，如果没有-g的内容，用gdb进行debug时，它并不知道每一行是什么内容，也不能print i变量，因为local variable会丢失，它只知道有个内存地址，不知道变量是i，但是如果使用-g选项，就可以添加这些信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210330001135.jpg" alt="image-20210329234104958"></p><p><code>objdump</code>相当于只读了.text内容，其他地方都没有读。</p><h2 id="2-关于补充作业题中的链接时出现segmentation-fault"><a href="#2-关于补充作业题中的链接时出现segmentation-fault" class="headerlink" title="2.关于补充作业题中的链接时出现segmentation fault"></a>2.关于补充作业题中的链接时出现<code>segmentation fault</code></h2><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210330001208.jpg" alt="image-20210329234104958"></p><h3 id="出错原因（此处为tyf的解释，可能复述的有不到位的地方）："><a href="#出错原因（此处为tyf的解释，可能复述的有不到位的地方）：" class="headerlink" title="出错原因（此处为tyf的解释，可能复述的有不到位的地方）："></a>出错原因（此处为tyf的解释，可能复述的有不到位的地方）：</h3><p>-e main是进入到main，但是此前没有执行虚拟内存映射，导致地址出错，出现segmentation fault，进入_start可以，因为 _start中会调用libc_start，（因为源码不公开，所以并不知道这其中做了什么，但是猜想它进行了虚拟内存映射），如果删去-e _start，即为默认值，也是可以正常运行的。</p><p>libc_start是定义在crt1.o中的，只要把它放在main之前，就可以进入。</p><h3 id="用main也可以正常运行的方法："><a href="#用main也可以正常运行的方法：" class="headerlink" title="用main也可以正常运行的方法："></a>用main也可以正常运行的方法：</h3><p>不要链接crt1.o，将entry point设为main，这样会进入main，main会return，return之后立刻会有segmentation fault，此时将return 0 改为 exit 0就可以了，因为exit调用的是system call，会执行一个中断。</p><h2 id="3-程序加载的过程"><a href="#3-程序加载的过程" class="headerlink" title="3.程序加载的过程"></a>3.程序加载的过程</h2><p>在进入main函数之前，首先会有一个程序准备全局变量等，最后来调用main函数，把他的参数传入，执行main函数，会return 0 给一个结束的程序，它会将一些“善后”的工作做完。如果入口是main函数，则上述准备操作均没有做，就return到一个系统不知道在哪儿的位置，所以会segmentation fault，但如果用exit就没有问题。</p><h2 id="4-标准的链接格式"><a href="#4-标准的链接格式" class="headerlink" title="4.标准的链接格式"></a>4.标准的链接格式</h2><p><code>ld -o OUTPUT crt1.o crti.o crtbegin.o [-L paths] [user objects] [gcc libs] [C libs] [gcc libs] crtend.o crtn.o</code></p><p>感谢谭一凡的耐心解答！</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>曹丝露</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0324ICSHW答案</title>
    <link href="/AcceptedHelper/2021/03/29/0324ICSHW%E7%AD%94%E6%A1%88/"/>
    <url>/AcceptedHelper/2021/03/29/0324ICSHW%E7%AD%94%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="ICS作业-链接2参考"><a href="#ICS作业-链接2参考" class="headerlink" title="ICS作业-链接2参考"></a>ICS作业-链接2参考</h1><h2 id="7-10"><a href="#7-10" class="headerlink" title="7.10"></a>7.10</h2><p>A.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ p.o libx.a<br></code></pre></td></tr></table></figure><p>B.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ p.o libx.a liby.a libx.a<br></code></pre></td></tr></table></figure><p>C.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ p.o libx.a liby.a libx.a libz.a<br></code></pre></td></tr></table></figure><h2 id="7-11"><a href="#7-11" class="headerlink" title="7.11"></a>7.11</h2><p>因为有.BSS区域，该区域在可执行文件中并不分配空间；而在加载入内存时进行分配，因此要预留出0x230字节。</p><h2 id="7-12"><a href="#7-12" class="headerlink" title="7.12"></a>7.12</h2><p>A.</p><p>$*refptr = ADDR(r.symbol)+r.addend-refaddr$</p><p>$=0x4004f8-4-(0x4004e0+0xa)=0xa$</p><p>B.</p><p>$*refptr = ADDR(r.symbol)+r.addend-refaddr$</p><p>$=0x400500-4-(0x4004d0+0xa)=0x22$</p><h2 id="7-13"><a href="#7-13" class="headerlink" title="7.13"></a>7.13</h2><h3 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h3><h4 id="寻找libc-a和libm-a"><a href="#寻找libc-a和libm-a" class="headerlink" title="寻找libc.a和libm.a"></a>寻找libc.a和libm.a</h4><p>使用如下的命令，找到库的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc --print-file-name=libc.a<br>gcc --print-file-name=libm.a<br></code></pre></td></tr></table></figure><p>得出这两个文件均在<code>/usr/lib/aarch64-linux-gnu</code>目录下</p><h4 id="查找有多少个Object-Files"><a href="#查找有多少个Object-Files" class="headerlink" title="查找有多少个Object Files"></a>查找有多少个Object Files</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/lib/aarch64-linux-gnu<br>ar -t libc.a | wc -l<br>ar -t libm.a | wc -l<br></code></pre></td></tr></table></figure><p>得出结论，在libc.a下有1616个Object file，在libm.a下有576个Object file</p><h3 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h3><p>他们产生的二进制文件是不同的，-g会携带更多的debug和符号信息。</p><p>使用如下命令即可看出他们之间的差别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">xxd main&gt;main.binary<br>xxd maing&gt;maing.binary<br>colordiff -y main.binary maing.binary<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210329221556.png"></p><p>事实上，添加的部分为debug section，可以用readelf读出来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">readelf -wi main # No output<br>readelf -wi maing<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">i<br>=<span class="hljs-built_in">info</span><br></code></pre></td></tr></table></figure><p>Displays the contents of the ‘.debug_info’ section. Note: the output from this option can also be restricted by the use of the –dwarf-depth and –dwarf-start options.</p></blockquote><h4 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h4><p>使用ldd分析任意一个可执行文件，可看出在我的电脑上(Ubuntu20.04 aarch64)，动态链接库如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">ldd /usr/bin/ls</span>                <br>linux-vdso.so.1 (0x0000ffff81faf000)<br>libselinux.so.1 =&gt; /lib/aarch64-linux-gnu/libselinux.so.1 (0x0000ffff81f05000)<br>libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6 (0x0000ffff81d92000)<br>/lib/ld-linux-aarch64.so.1 (0x0000ffff81f7f000)<br>libpcre2-8.so.0 =&gt; /lib/aarch64-linux-gnu/libpcre2-8.so.0 (0x0000ffff81d04000)<br>libdl.so.2 =&gt; /lib/aarch64-linux-gnu/libdl.so.2 (0x0000ffff81cf0000)<br>libpthread.so.0 =&gt; /lib/aarch64-linux-gnu/libpthread.so.0 (0x0000ffff81cc0000)<br></code></pre></td></tr></table></figure><ul><li>linux-vdso.so.1</li><li>libselinux.so.1 =&gt; /lib/aarch64-linux-gnu/libselinux.so.1 </li><li>libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6</li><li>/lib/ld-linux-aarch64.so.1</li><li>libpcre2-8.so.0 =&gt; /lib/aarch64-linux-gnu/libpcre2-8.so.0 </li><li>libdl.so.2 =&gt; /lib/aarch64-linux-gnu/libdl.so.2</li><li>libpthread.so.0 =&gt; /lib/aarch64-linux-gnu/libpthread.so.0 </li></ul><h2 id="补充习题"><a href="#补充习题" class="headerlink" title="补充习题"></a>补充习题</h2><h3 id="1-补充源码"><a href="#1-补充源码" class="headerlink" title="1.补充源码"></a>1.补充源码</h3><p>源码和Makefile见附带的文件</p><p>编译成功后的截图如下</p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210329195524.png" style="zoom:50%;" /><h3 id="2-手动编译"><a href="#2-手动编译" class="headerlink" title="2. 手动编译"></a>2. 手动编译</h3><p>使用了两种方法，第一种直接使用<code>gcc -v</code>的编译参数，第二种使用更简单的手动链接</p><h4 id="gcc-v式的"><a href="#gcc-v式的" class="headerlink" title="gcc -v式的"></a>gcc -v式的</h4><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210329200556.png"></p><p>能正常编译并运行</p><h4 id="手动链接式的"><a href="#手动链接式的" class="headerlink" title="手动链接式的"></a>手动链接式的</h4><p>在我们进行链接之前，需要先解释各个系统库有什么用，才能进行选择性的简化链接</p><ul><li>libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3496d10000) - C标准库动态共享对象</li><li>/lib64/ld-linux-x86-64.so.2 (0x00007f3497303000) - 动态链接器/加载器</li><li>crt1.o：包含入口函数_start(该函数执行了上一节所描述的整个程序执行过程)，以及未定义的符号__libc_start_main、main</li><li>crti.o: 提供.init节和.fini节的序言(function prologs)</li><li>crtn.o: 提供.init节和.fini节的尾言(function epilogs)</li><li>crtbegin.o: 提供构造函数的首地址(但在本题中，因为没有构造函数，因此不需要链接)</li><li>crtend.o: 提供析构函数的首地址(同上)</li></ul><p>具体到本题中，使用如下命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">crt1.o=/usr/lib/x86_64-linux-gnu/crt1.o<br>crti.o=/usr/lib/x86_64-linux-gnu/crti.o<br>crtn.o=/usr/lib/x86_64-linux-gnu/crtn.o<br>crtbeginS.o=/usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o<br>crtendS.o=/usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o<br>ld.so=/lib64/ld-linux-x86-64.so.2<br>libc.so=/usr/lib/x86_64-linux-gnu/libc.so<br>ld -dynamic-linker $(ld.so) -o main $(crt1.o) $(crti.o) main.o BubbleSort.o add.o printResult.o $(libc.so) $(crtn.o)<br></code></pre></td></tr></table></figure><h3 id="3-OBJDUMP进行反汇编"><a href="#3-OBJDUMP进行反汇编" class="headerlink" title="3.OBJDUMP进行反汇编"></a>3.OBJDUMP进行反汇编</h3><p>使用<code>objdump -S main.o &gt; main.S</code>将反编译形成的汇编码写入<code>main.S</code>文件中</p><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210329201203.png"></p><h3 id="4-生成调试信息后，使用GDB进行调试"><a href="#4-生成调试信息后，使用GDB进行调试" class="headerlink" title="4. 生成调试信息后，使用GDB进行调试"></a>4. 生成调试信息后，使用GDB进行调试</h3><p>使用了list, break, start, run, continue, info等多种命令进行了调试，在此处限于截图篇幅，仅截取部分</p><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210329201939.png"></p><h3 id="5-相关问题"><a href="#5-相关问题" class="headerlink" title="5. 相关问题"></a>5. 相关问题</h3><ol><li><p>分析同一个源程序在不同机器上生成的可执行目标代码是否相同</p><ol><li>ISA: 在arm处理器和x86处理器上，显然有不同的可执行目标文件代码</li><li>OS：在windows和linux上有不同的寄存器分配规则，在windows64上的函数调用采用<code>RCX</code>,<code>RDX</code>,<code>R8</code>,<code>R9</code>的寄存器调用顺序，在Linux64上采用的函数调用寄存器为<code>RDI</code>,<code>RSI</code>,<code>RDX</code>,<code>RCX</code>,<code>R8</code>,<code>R9</code></li><li>编译器：不同编译器会采用不同的优化策略，生成的可执行目标代码可能不同</li></ol></li><li><p>你能在可执行目标文件中找出函数printf ()对应的机器代码段吗？能的话，请标示出来。</p><p>不能，printf函数所对应的机器代码段在libc.so中，是在运行时调用的，因此无法找到。</p><p>事实上，的确有printf@plt（Procedure linkage table)这一函数，但这仅仅是一个找到真实printf代码的stub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000000710 &lt;printf@plt&gt;:<br> 710:ff 25 9a 18 20 00    jmpq   *0x20189a(%rip)        # 201fb0 &lt;printf@GLIBC_2.2.5&gt;<br> 716:68 03 00 00 00       pushq  $0x3<br> 71b:e9 b0 ff ff ff       jmpq   6d0 &lt;.plt&gt;<br></code></pre></td></tr></table></figure></li><li><p>为什么源程序文件的内容和可执行目标文件的内容完全不同？</p><p>源程序文件的内容为文本文件，是编程语言代码；可执行目标文件为CPU可以运行的二进制代码，自然不同。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>王少文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code for ICS HW4</title>
    <link href="/AcceptedHelper/2021/03/28/Code-for-ICS-HW4/"/>
    <url>/AcceptedHelper/2021/03/28/Code-for-ICS-HW4/</url>
    
    <content type="html"><![CDATA[<p>本文提供了ICS HW4补充作业中需要的初始代码。</p><h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;add.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;BubbleSort.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;printResult.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> bool char</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LENGTH 10</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a[LENGTH],i;<br>    <span class="hljs-keyword">int</span> b[LENGTH];<br>    <span class="hljs-keyword">int</span> randValue = <span class="hljs-number">0</span>;<br>    srand(time(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;LENGTH;i++)&#123;<br>        randValue = <span class="hljs-number">1</span> + (<span class="hljs-keyword">int</span>)rand()%LENGTH;<br>        a[i] = randValue;<br>        b[i] = a[i];<br>    &#125;<br>    printResult(a,LENGTH,<span class="hljs-string">&quot;\nrandom array: &quot;</span>);<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(flag)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n1.Bubble Sort\n2.sum\n3.print result\n4.exit&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nchoose a number:&quot;</span>);<br>        <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;number);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">switch</span>(number)<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                BubbleSort(a,LENGTH);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                sum = add(a,LENGTH);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nresult of sum: %d\n&quot;</span>,sum);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                printResult(b,LENGTH,<span class="hljs-string">&quot;\noriginal array:\t&quot;</span>);<br>                printResult(a,LENGTH,<span class="hljs-string">&quot;\nsorted array:\t&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nplease choose a correct number and continue!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nDone!\n\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="add-c"><a href="#add-c" class="headerlink" title="add.c"></a>add.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;add.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[],<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">//Write your code here</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="add-h"><a href="#add-h" class="headerlink" title="add.h"></a>add.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[],<span class="hljs-keyword">int</span> n)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="BubbleSort-c"><a href="#BubbleSort-c" class="headerlink" title="BubbleSort.c"></a>BubbleSort.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;BubbleSort.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[], <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">//Write your code here</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BubbleSort-h"><a href="#BubbleSort-h" class="headerlink" title="BubbleSort.h"></a>BubbleSort.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[], <span class="hljs-keyword">int</span> n)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="printResult-c"><a href="#printResult-c" class="headerlink" title="printResult.c"></a>printResult.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;printResult.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[],<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">char</span>* str)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str);<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d&quot;</span>,s[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="printResult-h"><a href="#printResult-h" class="headerlink" title="printResult.h"></a>printResult.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[],<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">char</span>* str)</span></span>;<br></code></pre></td></tr></table></figure><p><del>愿天堂没有用word图片发布的作业代码。</del></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>祁昊</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学作业答案</title>
    <link href="/AcceptedHelper/2021/03/25/answer_of_discrete_math/"/>
    <url>/AcceptedHelper/2021/03/25/answer_of_discrete_math/</url>
    
    <content type="html"><![CDATA[<p>此处的答案为2020年春网课学期助教所发布的答案，可能与今年布置的作业有所出入，请同学们务必<strong>不要外传</strong>。第12章和13章的答案如下(需要用电脑版的Chrome浏览器访问):</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/FDU19CS/AcceptedHelper@hexo/source/_posts/answer_of_discrete_math/discrete_math_12_13.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>离散数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>王少文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELF头简介</title>
    <link href="/AcceptedHelper/2021/03/23/Readelf/"/>
    <url>/AcceptedHelper/2021/03/23/Readelf/</url>
    
    <content type="html"><![CDATA[<p>​    在linux中我们常用readelf指令来读取ELF (Executable and Linkable Format) 文件中的信息，本文主要介绍ELF头的基本信息</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Elf-layout--en.svg/260px-Elf-layout--en.svg.png" alt="ELF文件结构"></p><h3 id="ELF头"><a href="#ELF头" class="headerlink" title="ELF头"></a>ELF头</h3><p>elf头是位于elf文件的头部，里面存储着一些机器和该ELF文件的基本信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>   e_ident[EI_NIDENT];<br>        Elf64_Half      e_type;<br>        Elf64_Half      e_machine;<br>        Elf64_Word      e_version;<br>        Elf64_Addr      e_entry;<br>        Elf64_Off       e_phoff;<br>        Elf64_Off       e_shoff;<br>        Elf64_Word      e_flags;<br>        Elf64_Half      e_ehsize;<br>        Elf64_Half      e_phentsize;<br>        Elf64_Half      e_phnum;<br>        Elf64_Half      e_shentsize;<br>        Elf64_Half      e_shnum;<br>        Elf64_Half      e_shstrndx;<br>&#125; Elf64_Ehdr;<br></code></pre></td></tr></table></figure><p>我们分别介绍其含义</p><hr><h4 id="1、e-ident"><a href="#1、e-ident" class="headerlink" title="1、e_ident"></a>1、e_ident</h4><ul><li><strong>长度：16字节</strong></li><li><strong>简介：包含着文件和操作系统信息</strong></li><li><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosklimwgzj30m00fmq55.jpg" style="zoom:50%;" /></li></ul><h5 id="Magic-Num-e-ident-0-3"><a href="#Magic-Num-e-ident-0-3" class="headerlink" title="Magic Num - e_ident[0:3]"></a>Magic Num - e_ident[0:3]</h5><p>​    前四个字节包含着一个 magic number，表示该文件是一个 ELF 文件</p><h5 id="EI-Class-e-ident-4"><a href="#EI-Class-e-ident-4" class="headerlink" title="EI_Class - e_ident[4]"></a>EI_Class - e_ident[4]</h5><p>​    指示文件类型，是ELF32还是ELF64位</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskl3oqhyj30dq05qq3h.jpg" style="zoom:50%;" /><h5 id="EI-DATA-e-ident-5"><a href="#EI-DATA-e-ident-5" class="headerlink" title="EI_DATA - e_ident[5]"></a>EI_DATA - e_ident[5]</h5><p>​    指示文件的编码方式，是大端法还是小端法</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskkp5pdjj30fy05ggm5.jpg" style="zoom:50%;" /><p>​    <strong>ELFDATA2LSB - 小端法</strong></p><p>​    <strong>ELFDATA2MSB - 大端法</strong></p><h5 id="EI-Version-e-ident-6"><a href="#EI-Version-e-ident-6" class="headerlink" title="EI_Version - e_ident[6]"></a>EI_Version - e_ident[6]</h5><p>​    标识ELF Version, 该值等于EV_CURRENT，目前为1</p><h5 id="EI-OSABI-e-ident-7"><a href="#EI-OSABI-e-ident-7" class="headerlink" title="EI_OSABI - e_ident[7]"></a>EI_OSABI - e_ident[7]</h5><p>​    表示着该文件运行的操作系统</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskk8xx2wj30oi0jmadb.jpg" alt="操作系统类型对应" style="zoom:50%;" /><h5 id="EI-ABIVERSION-e-ident-8"><a href="#EI-ABIVERSION-e-ident-8" class="headerlink" title="EI_ABIVERSION - e_ident[8]"></a>EI_ABIVERSION - e_ident[8]</h5><p>​    标志着 ABI （应用二进制接口）的版本，ABI相当于硬件层级的API（见下图）</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosknnji29j31400u0qd8.jpg" alt="ABI解释" style="zoom:40%;" /><h5 id="EI-PAD-e-ident-8-15"><a href="#EI-PAD-e-ident-8-15" class="headerlink" title="EI_PAD - e_ident[8:15]"></a>EI_PAD - e_ident[8:15]</h5><p>​    填充位，用零填充用以对齐，可以预留给未来使用</p><h4 id="2、e-type"><a href="#2、e-type" class="headerlink" title="2、e_type"></a>2、e_type</h4><ul><li><p><strong>长度：2字节</strong></p></li><li><p><strong>简介：</strong>指示文件类型</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosm36oov3j30he0da40a.jpg" style="zoom:50%;" /></li></ul><p>​    </p><h4 id="3、e-machine"><a href="#3、e-machine" class="headerlink" title="3、e_machine"></a>3、e_machine</h4><ul><li><p><strong>长度：2字节</strong></p></li><li><p><strong>简介：</strong>指示机器类型</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosm42l3lxj30u00x2wkc.jpg" alt="部分机器类型" style="zoom:50%;" /></li></ul><h4 id="4、e-version"><a href="#4、e-version" class="headerlink" title="4、e_version"></a>4、e_version</h4><p>​    <strong>长度：4字节</strong></p><p>​    <strong>简介：指示文件版本</strong></p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosm8c0knij30dk04gglx.jpg" style="zoom:50%;" /><h4 id="5、e-entry"><a href="#5、e-entry" class="headerlink" title="5、e_entry"></a>5、e_entry</h4><p>​    <strong>长度：4字节（32位）/8字节（64位）</strong></p><p>​    <strong>简介：进程开始的虚拟地址</strong></p><h4 id="6、e-phoff"><a href="#6、e-phoff" class="headerlink" title="6、e_phoff"></a>6、e_phoff</h4><p>​    <strong>长度：4字节（32位）/8字节（64位）</strong></p><p>​    <strong>简介：指向程序头部表的开始</strong>    </p><h4 id="7、e-shoff"><a href="#7、e-shoff" class="headerlink" title="7、e_shoff"></a>7、e_shoff</h4><p>​    <strong>长度：4字节（32位）/8字节（64位）</strong></p><p>​    <strong>简介：指向节头部表的开始</strong>    </p><h4 id="8、e-flags"><a href="#8、e-flags" class="headerlink" title="8、e_flags"></a>8、e_flags</h4><p>​    <strong>长度：4字节</strong></p><p>​    <strong>简介：意义取决于目标架构</strong>    </p><h4 id="9、e-ehsize"><a href="#9、e-ehsize" class="headerlink" title="9、e_ehsize"></a>9、e_ehsize</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：该文件头部的大小</strong></p><h4 id="10、e-phentsize"><a href="#10、e-phentsize" class="headerlink" title="10、e_phentsize"></a>10、e_phentsize</h4><p>​    <strong>长度：2字节</strong>    </p><p><strong>简介：程序头部的大小</strong>    </p><h4 id="11、e-phnum"><a href="#11、e-phnum" class="headerlink" title="11、e_phnum"></a>11、e_phnum</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：程序头部的条目数</strong></p><h4 id="12、e-shentsize"><a href="#12、e-shentsize" class="headerlink" title="12、e_shentsize"></a>12、e_shentsize</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：节头部表的大小</strong></p><h4 id="13、e-shnum"><a href="#13、e-shnum" class="headerlink" title="13、e_shnum"></a>13、e_shnum</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：节头部表的条目数</strong></p><h4 id="14、e-shstrndx"><a href="#14、e-shstrndx" class="headerlink" title="14、e_shstrndx"></a>14、e_shstrndx</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：节头部表的条目和其位置 (idx) 的对应关系</strong></p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">https://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a></p><p>[2] <a href="https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html">https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>谢子飏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/AcceptedHelper/2021/03/18/hello_world/"/>
    <url>/AcceptedHelper/2021/03/18/hello_world/</url>
    
    <content type="html"><![CDATA[<h2 id="第一篇用以测试"><a href="#第一篇用以测试" class="headerlink" title="第一篇用以测试"></a>第一篇用以测试</h2><h3 id="一、-下面是一段C-代码"><a href="#一、-下面是一段C-代码" class="headerlink" title="一、 下面是一段C++代码"></a>一、 下面是一段C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Hello World!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、-下面是一段表格"><a href="#二、-下面是一段表格" class="headerlink" title="二、 下面是一段表格"></a>二、 下面是一段表格</h3><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">x</td></tr></tbody></table><h3 id="三、-下面是一段-Latex"><a href="#三、-下面是一段-Latex" class="headerlink" title="三、 下面是一段 Latex"></a>三、 下面是一段 Latex</h3><p>$$E= mc^2$$</p><h3 id="四、下面是一张图片"><a href="#四、下面是一张图片" class="headerlink" title="四、下面是一张图片"></a>四、下面是一张图片</h3><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRP-ciAYVH8UlH3ZaZC3NkN3ow9CrG36O5crg&usqp=CAU"></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>None</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
