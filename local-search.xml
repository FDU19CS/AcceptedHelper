<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据挖掘笔记</title>
    <link href="/AcceptedHelper/2021/12/03/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AC%94%E8%AE%B0/"/>
    <url>/AcceptedHelper/2021/12/03/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据挖掘笔记"><a href="#数据挖掘笔记" class="headerlink" title="数据挖掘笔记"></a>数据挖掘笔记</h1><h2 id="习题课"><a href="#习题课" class="headerlink" title="习题课"></a>习题课</h2><ol><li>盒图：五数概括不用判定离群点，盒图要判定离群点</li><li>中位数概括宽度不用+1</li><li>OLAP基础操作 专有名词</li><li>15选择（1分）+5填空（2分）+4大题</li><li>upd：<strong>20-21春学期期末</strong><ul><li>大题考了用基尼系数做朴素贝叶斯概率、频繁模式挖掘、k近邻聚类、神经网络参数计算（求导大法）。确实都是作业出现过的题型，但是数不好算，聚类和基尼系数要按的计算器太多了。老师最后开始频繁催“算不出来数没关系，写对公式就给绝大部分分；写不出来公式写算法，至少写点东西好给分”。</li><li>前几章的计算只考了小题，比如算卡方、选正确的盒图。</li><li>小题里有概念题，比如写出三种集成学习算法。</li></ul></li><li>不挂人但是也不保B+，作业/PJ/期末考三部分占比未知</li></ol><h2 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h2><p>数据挖掘/KDD：从大量数据中挖掘有趣模式和知识的过程，通常包括数据清理、数据集成、数据选择、数据变换、模式发现、模式评估、知识表示。</p><h3 id="挖掘的对象"><a href="#挖掘的对象" class="headerlink" title="挖掘的对象"></a>挖掘的对象</h3><ol><li>关系数据库：表的汇集，有实体-联系（<strong>ER</strong>）等数据模型</li><li>数据仓库：从多个数据源收集的信息存储库，存放在一致的模式下，通常驻留在单个站点上。围绕主题组织，从历史的角度提供信息，通常是汇总的。用<strong>数据立方体</strong>建模。</li><li>事务数据：挖掘频繁项集</li></ol><h3 id="数据挖掘功能"><a href="#数据挖掘功能" class="headerlink" title="数据挖掘功能"></a>数据挖掘功能</h3><ol><li>类/概念描述：特征化与区分</li><li>挖掘频繁模式、关联和相关性</li><li>用于预测分析的分类与回归</li><li>聚类分析</li><li>离群点分析</li></ol><h2 id="第二章-认识数据"><a href="#第二章-认识数据" class="headerlink" title="第二章 认识数据"></a>第二章 认识数据</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol><li>数据对象用属性描述；属性表示数据对象的一个特征，同义词有属性（数据挖掘、数据库）、特征（机器学习）、变量（统计学）、维（数据仓库）。</li><li>标称属性：意味着“与名称相关”，值是一些符号或事物的名称，是分类的、枚举的、不定量、无序的。只有众数，没有其他数学运算（eg：颜色、编号、职业）。</li><li>二元/布尔属性：01的标称属性。若两种状态有同等价值且权重相同，称为对称的（eg：性别）；否则称为非对称的（eg：病毒阳性），一般将重要结果用1编码。</li><li>序数属性：可能的值之间具有意义的序或秩评定，但是相继值之间的差是未知的（eg：饮料大小杯、成绩等级、职位）。记录不能客观度量的主观质量评估，或通过把数值属性离散化得到。有众数和中位数，没有平均值。</li><li>数值属性：定量的可度量的量。区间标度属性用相等的单位尺度度量，可以做差，但是由于没有真正的零不能做商（eg：华氏温度、日期）；比率标度属性是具有固定零点的数值属性，可以做差和商（eg：开式温标、文档字数、速度）。数值属性都可以求众数、中位数、平均值。</li><li>总结：无序的只有众数、有序的可以求中位数、数值的可以做差和平均值、有零点的可以做商。</li><li>离散属性具有有限或无限可数个值（eg：头发颜色、顾客编号、邮政编码）；不离散的属性是连续属性（可与数值属性互换使用），一般用浮点变量表示。</li></ol><h3 id="数据的基本统计描述"><a href="#数据的基本统计描述" class="headerlink" title="数据的基本统计描述"></a>数据的基本统计描述</h3><ol><li>中心趋势度量<ul><li>均值/mean：算术均值/加权均值（对极端值很敏感）、截尾均值（丢弃高低极端值之后的均值）</li><li>中位数/median（对倾斜、非对称数据描述更好）：数据个数为偶数时，中位数不唯一，取中间两个值和它们之间的任意值；对于数值属性，约定取中间两个值的平均值。中位数的近似值。</li><li>众数/mode：根据众数个数将数据集合分为单峰的、双峰的、三峰的、多峰的（两个或更多个峰），N峰也称为N模。每个数据值只出现一次，则没有众数。</li><li>对于适度倾斜的单峰数值数据，有经验关系：$mean-mode \approx 3(mean-median)$</li><li>中列数/midrange：数据集最大和最小值的平均值。</li><li>完全对称的单峰频率曲线中，均值、中位数、众数都是相同的中心值。</li><li>正倾斜：众数小于中位数。反之则为负倾斜。</li></ul></li><li>数据散布度量<ul><li>极差/range：最大值与最小值之差</li><li>分位数/quantile：把数据划分成基本上大小相等的连贯集合，有$q-1$个q-分位数，第$k$个q-分位数是值$x$，小于$x$的数据值最多为$k/q$，大于$x$的数据值最多为$(q-k)/q$。2-分位数是中位数，四分位数依次为$Q_1$、$Q_2$、$Q_3$，又常用百分位数。</li><li>四分位数极差：$IQR=Q_3-Q_1$，给出被数据的中间一半覆盖的范围。</li><li>五数概括：最小观测值、$Q_1$、中位数、$Q_3$、<strong>最大观测值</strong>。</li><li>盒图：端点在四分位数上，长度是IQR，中位数用盒内的线标记，胡须延伸到最大最小观测值。若最大最小观测值距四分位数超过1.5IQR，胡须在距四分位数<strong>1.5IQR内最极端的观测值处</strong>终止，剩下的情况个别绘出。</li><li>方差：到均值距离的平方和的均值，或$(\frac{1}{N}\sum_{i=1}^{n}x_{i}^2)^2-\bar{x}^2$。标准差：方差的平方根，度量关于均值的发散。一个观测一般不会远离均值超过标准差的数倍，最少$(1-\frac{1}{k^2})*100%$的观测值离均值不超过k个标准差。</li></ul></li><li>基本统计描述的图形显示<ul><li>分位数图（观察单变量数据分布）：横轴为f值(i-0.5)/N，纵轴为观测值。</li><li>分位数-分位数图（观察两个分布之间是否有漂移）：横轴为一个观测值，纵轴为另一个观测值，每个点在两个数据集离对应的分位数相同。若两个观测集数据个数不同，以小的为准，需要在大的观测集里插值。</li><li>直方图：标称属性的直方图常被称为条形图。数值属性的直方图横轴为不相交的连续子域（桶/箱），通常是等宽的，纵轴为子域内数据的计数。</li><li>散点图（确定两个数值变量之间是否存在联系）：每个值对视为一个代数坐标对，作为一个点画在平面上。左下-右上暗示正相关，左上-右下暗示负相关。</li></ul></li></ol><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><ol><li>基于像素的可视化技术：对每一维创建一个窗口。线性填充、空间填充曲线，圆弓分割技术。</li><li>几何投影可视化技术：散点图矩阵（随着维数增加变得不太有效）、平行坐标（视觉上的簇和重叠导致不能有效地显示具有很多记录的数据集）</li><li>基于图符的可视化技术：切尔诺夫脸（容易被用户消化，在表示多重联系的能力方面存在局限性，最多18维，眼睛大小和眉毛的歪斜是重要的）、非对称的切尔诺夫脸（达到36维）、人物线条画（两个维映射到显示轴，其他维映射到人物线条画，数据关于两个显示维相对稠密则结果显示纹理模式）。</li><li>层次可视化技术：世界中的世界（将部分维固定为选定的值，以这个值为原点绘制内世界三维图，在外世界三维图中改变原点位置观察内世界变化）、树图</li><li>可视化复杂对象和关系：标签云（用大小表示次数）、图</li></ol><h3 id="度量数据的差异性和相似性"><a href="#度量数据的差异性和相似性" class="headerlink" title="度量数据的差异性和相似性"></a>度量数据的差异性和相似性</h3><ol><li><p>数据矩阵/二模矩阵：对象-属性结构，n*p。每行对应一个对象，又称数据样本/特征向量。</p></li><li><p>相异性矩阵/单模矩阵：对象-对象结构，n*n，存放对象两两之间的邻近度，对称矩阵。对于标称数据，$sim(i,j)=1-d(i,j)$</p></li><li><p>标称属性的邻近性度量：$d(i,j)=\frac{p-m}{p}$，m可加权</p></li><li><p>二元属性的邻近性度量</p><ul><li>对称的二元相异性$d(i,j)=\frac{r+s}{q+r+s+t}$</li><li>非对称的二元相异性$d(i,j)=\frac{r+s}{q+r+s}$</li><li>非对称的二元相似性$sim(i,j)=\frac{q}{q+r+s}$，称为Jaccard系数。</li></ul></li><li><p>数值属性的相异性</p><ul><li>先对数据规范化，如变换到$[-1,1]$或$[0,1]$</li><li>欧几里得距离，加权的欧几里得距离</li><li>曼哈顿距离</li><li>度量：满足非负性、同一性、对称性、三角不等式</li><li>闵可夫斯基距离/$L_p$范数：各维距离的p次方之和，开p次方，p是不小于1的实数。$L_1$范数为曼哈顿距离，$L_2$范数为欧几里得距离。</li><li>上确界距离/$L_{max}$/$L_{∞}$范数/一致范数/切比雪夫距离：各维距离的最大值</li></ul></li><li><p>序数属性的邻近性度量：对于第$i$个对象，用对应排位$r_{if}$取代序数属性组$x_{if}$，将每个属性的值域映射到$[0,1]$，$z_{if}=\frac{r_{if}-1}{M_f-1}$，再对$z$使用数值属性的距离度量计算相异性</p></li><li><p>混合类型属性的相异性</p><ul><li>计算两者均不缺失的所有属性相异性并取平均数</li><li>数值属性$d_{ij}^{(f)}=\frac{|x_{if}-x_{jf}|}{max_hx_{hf}-min_hx_{hf}}$</li><li>序数属性计算$z$后按数值属性处理</li><li>标称属性$d$即为是否相等</li></ul></li><li><p>余弦相似性</p><ul><li>处理很长的、稀疏的向量，数据往往高度非对称（eg：信息检索、生物学分类）</li><li>$sim(x,y)=\frac{x*y}{||x||||y||}$，分母为两个向量欧几里得范数（即长度）之积</li><li>0代表两个向量正交，余弦值越小向量之间的匹配越大</li><li>不遵守度量测度性质，被称为非度量测度</li><li>二值属性的余弦相似性可以用共享特征或属性解释，分子是共同具有的属性数，分母是两个向量具有的属性数的几何均值，sim成为公共属性相对拥有的一种度量，$sim(i,j)=\frac{x<em>y}{x</em>x+y<em>y-x</em>y}$，称为Tanimoto系数或Tanimoto距离</li></ul></li></ol><h2 id="第三章-数据预处理"><a href="#第三章-数据预处理" class="headerlink" title="第三章 数据预处理"></a>第三章 数据预处理</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li><p>数据质量的三个要素：准确性、完整性、一致性</p></li><li><p>影响数据质量的要素：时效性、可解释性、可信性</p></li><li><p>主要步骤：数据清理、数据集成、数据归约、数据变换</p></li></ol><h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><ol><li>缺失值</li><li>噪声数据：分箱、回归、离群点分析</li><li>偏差检测，数据变换两步的迭代过程</li><li>数据清洗工具，数据审计工具，数据迁移工具，ETL工具</li></ol><h3 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h3><ol><li>实体识别问题：使用元数据</li><li>冗余和相关分析<ul><li>标称数据的卡方检验：相依表中$o_{ij}$为联合事件观测频度，$e_{ij}$为期望频度，可用$e_{ij}=\frac{count(A=a_i)<em>count(B=b_j)}{n}$计算，卡方=$\sum_{i=1}^c\sum_{j=1}^r\frac{(o_{ij}-e_{ij})^2}{e_{ij}}$，对卡方贡献越大的单元实际计数与期望计数越不符。卡方检验假设A和B是独立的，具有自由度$(r-1)</em>(c-1)$，自由度和置信水平决定拒绝假设的值</li><li>数值数据的相关系数/Pearson积矩系数：$r_{A,B}=\frac{\sum_{i=1}^n(a_i-\bar A)(b_i-\bar B)}{n\sigma_A\sigma_B}=\frac{\sum_{i=1}^n(a_ib_i)-n\bar A\bar B}{n\sigma_A\sigma_B}$；r越接近1，正相关越强；越接近-1，负相关越强；r为0，A和B独立。相关性不蕴涵因果关系</li><li>数值数据的协方差：$Cov(A,B)=E((A-\bar A)(B-\bar B))=\frac{\sum_{i=1}^n(a_i-\bar A)(b_i-\bar B)}{n}=E(A*B)-\bar A\bar B=r_{A,B}\sigma_A\sigma_B$；协方差为正表示正相关，协方差为负表示负相关；A和B独立时协方差一定为0，但A和B不独立协方差也可能为0，只有当数据满足多元正态分布等限制条件时协方差为0才充分说明数据独立。方差是属性和自身的协方差</li></ul></li><li>元组重复</li><li>数据值冲突的检测与处理</li></ol><h3 id="数据归约"><a href="#数据归约" class="headerlink" title="数据归约"></a>数据归约</h3><ol><li>维归约：小波变换、主成分分析、属性子集选择、属性创建</li><li>数量归约：参数方法（回归、对数-线性模型）、非参数方法（直方图、聚类、抽样、数据立方体聚集）</li><li>数据压缩：有损的、无损的</li><li>离散小波变换（DWT）<ul><li>将数据向量X变换成不同的数值小波系数向量X’，变换后数据可以截短，仅存放一部分最强的小波系数，消除噪声</li><li>有损压缩，比DFT更准确，空间局部性好，对稀疏或倾斜数据和具有有序属性的数据效果好</li><li>层次金字塔算法：每次迭代数据减半，先后使用光滑和加权差分函数，得到两个长度为L/2的数据集，分别代表光滑后的版本或低频版本和它的高频内容</li><li>有若干族DWT，小波名后的数是小波的消失瞬间</li><li>将矩阵乘法用于输入数据，所用的矩阵必须是标准正交的</li><li>处理多维数据，首先将变换用于第一个维，然后第二个，复杂度关于立方体中单元的个数是线性的</li></ul></li><li>主成分分析/PCA<ul><li>搜索k个最能代表数据的n维正交向量，k&lt;=n</li><li>对输入数据规范化，计算k个标准正交向量（主成分），对主成分按重要性或强度降序排列，主成分本质上充当新坐标系，通过去掉较弱的成分（方差较小的那些）来规约数据</li><li>可用于有序和无序的属性，可以处理稀疏和倾斜数据，可以用做多元回归和聚类分析的输入</li><li>多于二维的多维数据可以通过将问题归约为二维问题来处理</li><li>小波变换更适合高维数据，PCA能够更好处理稀疏数据</li></ul></li><li>属性子集选择<ul><li>删除不相关或冗余属性，目标是找出最小属性集，使数据类的概率分布尽可能接近原分布</li><li>压缩搜索空间的启发式算法：贪心，取局部最优解</li><li>确定”最好/差的“属性：统计显著性检验/信息增益度量</li><li>具体技术：逐步向前选择、逐步向后删除、逐步向前选择和逐步向后删除的组合、决策树归纳</li></ul></li><li>回归和对数线性模型<ul><li>参数化数据归约</li><li>线性回归（最小二乘法求解回归系数）、多元回归</li><li>对数线性模型：近似离散的多维概率分布，基于维组合的一个较小子集估计多维空间中每个点的概率</li><li>都可以用于稀疏数据。回归对倾斜数据可望更好，对数线性模型对高维数据伸缩性好，可达10维</li></ul></li><li>直方图<ul><li>等宽直方图，等频/等深直方图</li><li>对于近似稀疏和稠密数据，以及高倾斜和均匀的数据，都是非常有效的</li><li>多维直方图可以表现属性间的依赖，能有效近似多达5个属性的数据</li><li>对于存放具有高频率的离群点，单值桶是有用的</li></ul></li><li>聚类<ul><li>直径：簇中两个对象的最大距离</li><li>形心距离：簇中每个对象到簇形心（平均对象/空间中的平均点）的平均距离</li><li>数据归约中用簇代表替换实际数据，对于能够组织成不同的簇的数据较为有用</li></ul></li><li>抽样<ul><li>s个样本的无放回简单随机抽样（SRSWOR）</li><li>s个样本的有放回简单随机抽样（SRSWR）</li><li>簇抽样：每次抽取一个簇</li><li>分层抽样：数据倾斜时可以帮助确保样本的代表性</li><li>得到样本的花费正比例于样本集的大小s，而不是数据集的大小N，因此复杂度亚线性于数据大小，仅根据数据的维数n线性增加</li><li>常用来估计聚集查询的回答，通过简单的增加样本大小可以进一步求精</li></ul></li><li>数据立方体聚集<ul><li>每个属性都可能存在概念分层，允许在多个抽象层进行数据分析</li><li>数据立方体提供对与计算的汇总数据进行快速访问，适合联机数据分析和数据挖掘</li><li>在最低抽象层创建的立方体称为基本方体，应当对应于感兴趣的个体实体</li><li>最高抽象层的立方体称为顶点方体</li><li>不同层创建的数据立方体称为方体，数据立方体可以看作方体的格</li><li>回答询问时使用与给定任务相关的最小可用方体</li></ul></li></ol><h3 id="数据变换与数据离散化"><a href="#数据变换与数据离散化" class="headerlink" title="数据变换与数据离散化"></a>数据变换与数据离散化</h3><ol><li>光滑：去掉数据中的噪声，包括分箱、回归和聚类</li><li>属性构造/特征构造：由给定属性创造新属性</li><li>聚集：一般用来维多个抽象层的数据分析构造数据立方体</li><li>规范化/标准化：把属性数据按比例缩放到特定小区间<ul><li>最小-最大规范化：$v_i’=\frac{v_i-min_A}{max_A-min_A}(max_A’-min_A’)+min_A’$，保持原始数据之间的联系，但新输入落在原始数据值域外可能越界</li><li>z分数规范化/z-score规范化/零均值规范化：$v_i’=\frac{v_i-\bar A}{\sigma_A}$，实际最大最小值未知或离群点左右了最小-最大规范化时是有用的。标准差可用均值绝对偏差$s_A$替换，对离群点更鲁棒</li><li>小数定标规范化：通过移动属性A的小数点位置进行规范化，$v_i’=\frac{v_i}{10^j}$，j是使得$max(|v_i’|)&lt;1$的最小整数</li><li>有必要保留规范化参数，以便将来的数据可以用一致的方式规范化</li></ul></li><li>离散化：将数值属性原始值用区间标签或概念标签替换<ul><li>监督的离散化和非监督的离散化：是否使用类信息</li><li>自顶向下离散化/分裂，自底向上离散化/合并</li><li>分箱离散化：等宽/等频分箱，用箱均值/中位数替换箱中的每个值，是非监督的离散化技术，对用户指定的箱个数和离群点很敏感</li><li>直方图离散化：非监督，可以递归地用于每个分区，自动产生多级概念分层，用预设概念层数或最小区间长度控制递归过程</li><li>聚类</li><li>决策树：监督的离散化，选择最小化熵的值作为划分点</li><li>相关分析离散化：监督的离散化，ChiMerge，自底向上递归找出具有最小卡方值的相邻区间并合并（对于精确的离散化，相对类频率在一个区间内应当完全一致）</li></ul></li><li>由标称数据产生概念分层：利用模式和属性值计数信息</li></ol><h2 id="第四章-数据仓库与联机分析处理"><a href="#第四章-数据仓库与联机分析处理" class="headerlink" title="第四章 数据仓库与联机分析处理"></a>第四章 数据仓库与联机分析处理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>主要特征：面向主题的、集成的、时变的、非易失的</li><li>使用更新驱动而非查询驱动方法</li><li>操作数据库与数据仓库分离，OLTP和OLAP分离</li><li>OLAP系统面向市场（而非面向顾客），管理大量历史数据（而非当前数据），采用星形或雪花模型和面向主题的数据库设计（而非ER模型和面向应用的数据库设计），常常跨越数据库模式的多个版本，存放在多个存储介质上，大部分是只读操作</li><li>三层体系结构：底层是仓库数据库服务器，中间层是OLAP服务器，顶层是前端客户层</li><li>数据仓库模型：企业仓库，数据集市和虚拟仓库</li><li>数据提取、变换和装入</li><li>元数据库：关于数据的数据，应当持久存放和管理（即存放在磁盘上）</li></ol><h3 id="数据立方体与OLAP"><a href="#数据立方体与OLAP" class="headerlink" title="数据立方体与OLAP"></a>数据立方体与OLAP</h3><ol><li>数据立方体由维和事实定义，是n维的</li><li>数据立方体称作方体。给定维的集合，可以对给定诸维的每个子集产生一个方体，结果形成方体的格，称作数据立方体。存放最低层汇总的方体称作基本方体，最高层汇总的方体称作顶点方体。</li><li>多维数据模型<ul><li>星形模式：一个事实表+一组维表</li><li>雪花模式：在星形模式的基础上将某些维表规范化</li><li>星系模式/事实星座：多个事实表共享维表</li><li>数据仓库通常使用事实星座模式，数据集市流行采用星形或雪花模式</li></ul></li><li>概念分层<ul><li>模式分层：形成数据库模式中属性的全序或偏序的概念分层</li><li>集合分组分层：将给定维或属性的值离散化或分组</li></ul></li><li>度量的分类和计算<ul><li>数据立方体度量是一个数值函数，可以对数据立方体空间的每个点求值，通过对给定点的各维-值对聚集数据，计算该点的度量值</li><li>度量分类：分布的（可以划分计算，eg：sum、count、min）、代数的（可以由多个划分计算的结果得到，eg：avg、min_N)、整体的（描述子聚集所需的存储没有常数界，eg：median、mode、rank）</li></ul></li><li>典型的OLAP操作<ul><li>上卷（roll-up）/上钻（drill-up）：通过沿一个维的概念分层向上攀升，泛化</li><li>下钻（drill-down）：通过沿一个维的概念分层向下或引入附加的维，特殊化</li><li>切片（slice）：在一个维进行选择</li><li>切块（dice）：在两个或多个维进行选择</li><li>转轴（pivot）/旋转（rotate）：转动数据视角</li><li>钻过（drill-across）：执行涉及多个事实表的查询</li><li>钻透（drill-through）：使用关系SQL机制钻透到后端关系表</li></ul></li><li>星网模型：由从中心点发出的射线组成，其中每一条射线代表一个维的概念分层，概念分层上的每个”抽象级“称为一个足迹，代表 OLAP操作可用的粒度</li></ol><h3 id="数据仓库的设计与使用"><a href="#数据仓库的设计与使用" class="headerlink" title="数据仓库的设计与使用"></a>数据仓库的设计与使用</h3><ol><li>商务分析框架：自顶向下视图、数据源视图、数据仓库视图、商务查询视图</li><li>开发方法：瀑布式方法、螺旋式方法</li><li>数据仓库应用：信息处理、分析处理、数据挖掘</li><li>多维数据挖掘/探索式多维数据挖掘/联机分析挖掘/OLAM</li></ol><h3 id="数据仓库的实现"><a href="#数据仓库的实现" class="headerlink" title="数据仓库的实现"></a>数据仓库的实现</h3><ol><li>compute cube：在操作指定的维的所有子集上计算聚集</li><li>维灾难：n维方体总数=$\prod_{i=1}^n(L_i+1)$</li><li>不物化、完全物化、部分物化</li><li>冰山立方体：只存放聚集值大于某个最小支持度阈值的立方体单元</li><li>外壳立方体</li><li>位图索引，连接索引，复合连接索引，位图连接索引</li><li>关系OLAP（ROLAP）服务器：伸缩性好，映射到关系操作；多维OLAP（MOLAP）服务器：适用稠密子立方体，映射到数组结构；混合OLAP（HOLAP）服务器；特殊的SQL服务器</li></ol><h3 id="数据泛化：面向属性的归纳"><a href="#数据泛化：面向属性的归纳" class="headerlink" title="数据泛化：面向属性的归纳"></a>数据泛化：面向属性的归纳</h3><ol><li>属性删除：某个属性有大量不同值但没有泛化操作符，或较高层概念用其他属性表示</li><li>属性泛化：某个属性有大量不同值且存在泛化操作符</li><li>属性泛化控制：属性泛化阈值控制、广义关系阈值控制</li><li>面向属性归纳：关系查询-收集初始关系上的统计量-导出主关系P</li><li>类比较：数据收集-维相关分析-同步泛化-导出比较的表示</li></ol><h2 id="第五章-数据立方体技术"><a href="#第五章-数据立方体技术" class="headerlink" title="第五章 数据立方体技术"></a>第五章 数据立方体技术</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>基本方体的单元是基本单元，非基本方体的单元是聚集单元</li><li>祖先和后代单元，父母和子女单元</li><li>闭覆盖：一个单元c是闭单元，如果不存在后代d与c有相同的度量值；闭立方体是只由闭单元组成的数据立方体</li><li>立方体外壳，外壳片段</li><li>优化技术：散列、排序、分组、同时聚集和缓存中间结果、由最小的子女聚集、先验剪枝</li></ol><h3 id="数据立方体计算方法"><a href="#数据立方体计算方法" class="headerlink" title="数据立方体计算方法"></a>数据立方体计算方法</h3><ol><li>多路数组聚集（MultiWay）：扫描顺序决定保持二维平面在块内存中的最小内存需求量；适合维的基数乘积适中且数据不是太稀疏的情况，但是不能先验剪枝</li><li>BUC：自顶向下，容易受维的次序和倾斜数据的影响，理想情况下应先处理最有区分能力的维，应当以维的基数减序处理</li><li>Star-Cubing<ul><li>共享维剪枝</li><li>方体树，星树</li><li>计算完全立方体，稠密时接近MultiWay，比BUC快；稀疏时比MultiWay快很多，大部分情况下比BUC快</li><li>计算冰山立方体，比BUC快</li></ul></li><li>计算外壳片段：倒排索引，Frag-Shells</li><li>点查询，子立方体查询</li></ol><h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><ol><li>抽样立方体<ul><li>置信区间$\bar x ±t_c\sigma_{\bar x}$，$t_c$与置信水平相关，$\sigma_{\bar x}=\frac{s}{\sqrt l}$是均值的估计标准误差，自由度为$l-1$，$l$为样本数</li><li>提升小样本置信度：方体内查询扩展、方体间查询扩展</li></ul></li><li>排序立方体</li></ol><h3 id="多维数据分析"><a href="#多维数据分析" class="headerlink" title="多维数据分析"></a>多维数据分析</h3><ol><li>预测立方体</li><li>多特征立方体：多粒度上多个依赖的聚集的复杂查询</li><li>基于异常的、发现驱动的立方体空间探查<ul><li>SelfExp，InExp，PathExp</li><li>给定单元的值和它的期望值之间的差称为残差，残差越大越异常，要对残差定标</li></ul></li></ol><h2 id="第六章-挖掘频繁模式、关联和相关性：基本概念和方法"><a href="#第六章-挖掘频繁模式、关联和相关性：基本概念和方法" class="headerlink" title="第六章 挖掘频繁模式、关联和相关性：基本概念和方法"></a>第六章 挖掘频繁模式、关联和相关性：基本概念和方法</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>频繁模式：频繁出现在数据集中的模式，如频繁项集、频繁序列模式</li><li>有趣的关联规则：满足最小支持度阈值和最小置信度阈值</li><li>支持度support(A-&gt;B)=P(A$\cup$B)</li><li>置信度confidence(A-&gt;B)=P(B|A)=support(A$\cup$B)/support(A)</li><li>闭频繁项集：不存在频繁项集X的真超集Y，使得Y与X在D中支持度相同</li><li>极大频繁项集：不存在频繁项集X的超集Y，使得Y在D中是频繁的</li></ol><h3 id="频繁项集挖掘方法"><a href="#频繁项集挖掘方法" class="headerlink" title="频繁项集挖掘方法"></a>频繁项集挖掘方法</h3><ol><li><p>Apriori（先验）算法</p><ul><li>先验性质，属于反单调性</li><li>连接步，剪枝步</li><li>由频繁项集枚举子集，产生关联规则</li><li>优化方法：散列技术、事务压缩、划分、抽样、动态项集计数</li></ul></li><li><p>FP-growth（频繁模式增长）算法</p><ul><li>导出频繁项的集合，构造FP树</li><li>从表后端的后缀模式开始构造条件模式基</li></ul></li><li><p>使用垂直数据格式挖掘频繁项集</p><ul><li><p>不需要扫描数据库来确定k+1项集的支持度</p></li><li><p>差集技术：数据集稠密和包含长模式时，可以显著降低总开销</p></li></ul></li><li><p>挖掘闭模式和极大模式</p><ul><li>项合并</li><li>子项集剪枝</li><li>项跳过</li></ul></li></ol><h3 id="模式评估方法"><a href="#模式评估方法" class="headerlink" title="模式评估方法"></a>模式评估方法</h3><ol><li>提升度：$lift(A,B)=\frac{P(A\cup B)}{P(A)P(B)}=\frac{P(B|A)}{P(B)}=\frac{conf(A-&gt;B)}{sup(B)}$，小于1为负相关，大于1为正相关，等于1为独立</li><li>全置信度：min{P(A|B),P(B|A)}</li><li>最大置信度：max{P(A|B),P(B|A)}</li><li>Kulczynski（Kulc）度量：0.5(P(A|B)+P(B|A))</li><li>余弦度量：$\sqrt{P(A|B)+P(B|A)}$</li><li>不平衡比：$IR(A,B)=\frac{|sup(A)-sup(B)|}{sup(A)+sup(B)-sup(A\cup B)}$</li><li>全置信度、最大置信度、Kulc和余弦是零不变的，推荐Kulc和IR配合使用</li></ol><h2 id="第七章-高级模式挖掘"><a href="#第七章-高级模式挖掘" class="headerlink" title="第七章 高级模式挖掘"></a>第七章 高级模式挖掘</h2><h3 id="多层、多维空间中的模式挖掘"><a href="#多层、多维空间中的模式挖掘" class="headerlink" title="多层、多维空间中的模式挖掘"></a>多层、多维空间中的模式挖掘</h3><ol><li>挖掘多层关联规则</li><li>检查多层关联规则的冗余性：根据规则的祖先，它的支持度和置信度都接近于期望值</li><li>挖掘多维关联规则</li><li>挖掘量化关联规则</li><li>挖掘稀有模式和负模式<ul><li>稀有模式支持度远低于用户指定的最小支持度阈值</li><li>负相关：X和Y都是频繁的，但很少一起出现</li><li>直接用sup定义的强负相关并不是零不变的</li><li>零不变的强负相关定义：Kulc度量小于负模式阈值</li></ul></li></ol><h3 id="基于约束的频繁模式挖掘"><a href="#基于约束的频繁模式挖掘" class="headerlink" title="基于约束的频繁模式挖掘"></a>基于约束的频繁模式挖掘</h3><ol><li>用模式剪枝约束对模式空间剪枝<ul><li>反单调的</li><li>单调的</li><li>简洁的</li><li>可转变的</li><li>不可转变的</li></ul></li><li>用数据剪枝约束对数据空间剪枝<ul><li>数据简洁</li><li>数据反单调</li></ul></li></ol><h3 id="挖掘高维数据和巨型模式"><a href="#挖掘高维数据和巨型模式" class="headerlink" title="挖掘高维数据和巨型模式"></a>挖掘高维数据和巨型模式</h3><ol><li>通过模式融合挖掘巨型模式<ul><li>核模式（核后代）、核比率</li><li>鲁棒</li><li>模式距离</li><li>池初始化-迭代的模式融合</li></ul></li></ol><h3 id="挖掘压缩或近似模式"><a href="#挖掘压缩或近似模式" class="headerlink" title="挖掘压缩或近似模式"></a>挖掘压缩或近似模式</h3><ol><li>通过模式聚类挖掘压缩模式：模式距离</li><li>提取感知冗余的top-k模式<ul><li>显著性度量S</li><li>S(p,q)联合显著性，S(p|q)=S(p,q)-S(q)相对显著性</li><li>冗余性R(p,q)=S(p)+S(q)-S(p,q)，所以S(p|q)=S(p)-R(p,q)</li><li>可以用模式间的距离近似冗余度</li></ul></li></ol><h3 id="模式探索与应用"><a href="#模式探索与应用" class="headerlink" title="模式探索与应用"></a>模式探索与应用</h3><ol><li>频繁模式的语义注解：互信息</li><li>模式挖掘的应用</li></ol><h2 id="第八章-分类：基本概念"><a href="#第八章-分类：基本概念" class="headerlink" title="第八章 分类：基本概念"></a>第八章 分类：基本概念</h2><h3 id="决策树归纳"><a href="#决策树归纳" class="headerlink" title="决策树归纳"></a>决策树归纳</h3><ol><li>属性选择度量<ul><li>信息增益：信息需求$Info(D)=-\sum_{i=1}^mp_ilog_2(p_i)$，$p_i$用$|C_{i,D}|/|D|$估计；$Info_A(D)=\sum_{j=1}^v\frac{|D_j|}{D}*Info(D_j)$，$Info_A(D)$越小，分区纯度越高；信息增益$Gain(A)=Info(D)-Info_A(D)$</li><li>增益率：分裂信息$SplitInfo_A(D)=-\sum_{j=1}^v\frac{|D_j|}{D}*log_2(\frac{|D_j|}{|D|})$，增益率$GRianRate(A)=\frac{Gain(A)}{SplitInfo_A(D)}$</li><li>基尼系数：$Gini(D)=1-\sum_{i=1}^mp_i^2$度量数据分区或训练元组集D的不纯度；考虑二元划分裂时，计算每个结果分区不纯度加权和；对连续值属性，最大化不纯度降低</li><li>基于最小描述长度原理的属性</li></ul></li><li>树剪枝：先剪枝，后剪枝（代价复杂度剪枝算法，应用剪枝集）</li><li>可伸缩性与决策树归纳：雨林（在每个结点维护每个属性的AVC-集），树构造的自助乐观算法（BOAT）</li><li>决策树归纳的可视化挖掘：基于感知的分类（PBC）</li></ol><h3 id="贝叶斯分类方法"><a href="#贝叶斯分类方法" class="headerlink" title="贝叶斯分类方法"></a>贝叶斯分类方法</h3><ol><li>贝叶斯定理<ul><li>后验概率P(H|X)</li><li>P(H|X)=P(X|H)P(H)/P(X)</li></ul></li><li>朴素贝叶斯分类<ul><li>预测X属于在X条件下有最高后验概率的类</li><li>等价于最大化P(X|Ci)P(Ci)</li><li>若P(Ci)未知则假定等概率，否则用Ci/D估计</li><li>类条件独立的朴素假定：P(X|Ci)=P(x1|Ci)P(x2|Ci)……P(xn|Ci)</li><li>连续值属性的概率用高斯分布定义</li><li>拉普拉斯校准/拉普拉斯估计法</li></ul></li></ol><h3 id="基于规则的分类"><a href="#基于规则的分类" class="headerlink" title="基于规则的分类"></a>基于规则的分类</h3><ol><li>规则：规则前件/前提IF，规则结论THEN</li><li>覆盖率$coverage(R)=n_{covers}/|D|$</li><li>准确率$accuracy(R)=n_{correct}/n_{covers}$</li><li>规模序：优先最苛刻的规则，即前件规模最大、激活具有最多属性测试的被触发的规则</li><li>规则序：预定规则的优先次序</li><li>由决策树提取规则：规则是互斥的和穷举的</li><li>使用顺序覆盖算法的规则归纳<ul><li>贪心的深度优先策略</li><li>用于规则学习的称为正元组pos，其余称为负元组neg</li><li>信息增益$FOIL-Gain=pos’*(log_2\frac{pos’}{pos’+neg’}-log_2\frac{pos}{pos+neg})$；似然率统计量$Likelihood-Ratio=2\sum_{i=1}^mf_ilog(\frac{f_i}{e_i})$，似然率越高正确预测数与随机猜测差越显著</li><li>规则剪枝$FOIL-Prune(R)=\frac{pos-neg}{pos+neg}$</li></ul></li></ol><h3 id="模型评估与选择"><a href="#模型评估与选择" class="headerlink" title="模型评估与选择"></a>模型评估与选择</h3><ol><li>混淆矩阵——真阳性：TP；真阴性：TN；假阳性：FP；假阴性：FN</li><li>准确率/总体识别率：$accuracy=\frac{TP+TN}{P+N}$</li><li>错误率：1-accuracy</li><li>灵敏性/召回率：$sensitivity=\frac{TP}{P}=\frac{TP}{TP+FN}=recall$</li><li>特效性：$specificity=\frac{TN}{N}$</li><li>精度：$precision=\frac{TP}{TP+FP}$</li><li>$F_x$分数：$F_x=\frac{(1+x^2)<em>precision</em>recall}{x^2*precision+recall}$，x为1时称为F度量/F分数</li><li>保持方法和随机二次抽样</li><li>交叉验证<ul><li>k-折交叉验证：初始数据随机划分成k个互不相交的子集D，训练和检验进行k次，每次留下一个D检验</li><li>留一：每次只给检验集留出一个样本</li><li>分层交叉验证</li><li>建议用分层10-折交叉验证估计准确率</li></ul></li><li>自助法：有放回，.632，$Acc(M)=\sum_{i=1}^k(0.632<em>Acc(M_i)_{test-set}+0.368</em>Acc(M_i)train-set)$</li><li>统计显著性：t-test，显著水平sig，置信界z=sig/2<ul><li>$t=\frac{\bar {err}(M_1)-\bar {err}(M_2)}{\sqrt{var(M_1-M_2)/k}}$，var为模型差的方差，若有两个检验集，方差估计为$\sqrt{var(M_1)/k_1+var(M_2)/k_2}$</li></ul></li><li>成本效益</li><li>ROC曲线<ul><li>真正例率TPR=TP/P</li><li>假正例率TFR=FP/N</li><li>概率从高到低排序，真正例TP增加，假正例FP增加</li><li>用当前混淆矩阵计算(FPR,TPR)并将点绘在图中</li><li>ROC曲线越接近随机猜测，模型准确率越低</li></ul></li></ol><h3 id="提高分类准确率的技术"><a href="#提高分类准确率的技术" class="headerlink" title="提高分类准确率的技术"></a>提高分类准确率的技术</h3><ol><li>组合分类方法</li><li>装袋：有放回抽样，多数表决</li><li>提升和AdaBoost：给不正确分类的元组加权，不同分类器的表决权重也取决于错误率</li><li>随机森林</li><li>提高类不平衡数据的分类准确率：过抽样、欠抽样、阈值移动、组合技术</li></ol><h2 id="第九章-分类：高级方法"><a href="#第九章-分类：高级方法" class="headerlink" title="第九章 分类：高级方法"></a>第九章 分类：高级方法</h2><h3 id="贝叶斯信念网络"><a href="#贝叶斯信念网络" class="headerlink" title="贝叶斯信念网络"></a>贝叶斯信念网络</h3><ol><li>计算梯度</li><li>沿梯度方向前进一小步</li><li>重新规格化权重</li></ol><h3 id="用后向传播分类"><a href="#用后向传播分类" class="headerlink" title="用后向传播分类"></a>用后向传播分类</h3><ol><li>多层前馈神经网络</li><li>后向传播：初始化权重，向前传播输入，向后传播误差</li><li>可增强可解释性</li></ol><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><ol><li>对线性和非线性数据进行分类</li><li>SVM搜索最大边缘超平面（MMH）</li><li>支持向量：最难分类的元组，给出最多支持信息</li></ol><h3 id="使用频繁模式分类"><a href="#使用频繁模式分类" class="headerlink" title="使用频繁模式分类"></a>使用频繁模式分类</h3><h3 id="惰性学习法（近邻学习）"><a href="#惰性学习法（近邻学习）" class="headerlink" title="惰性学习法（近邻学习）"></a>惰性学习法（近邻学习）</h3><ol><li>距离最近的k个中取最多</li><li>训练元组趋于无穷，k=1，错误率不超过贝叶斯错误率的2倍；k趋于无穷，错误率趋向于贝叶斯错误率</li><li>基于案例的推理</li></ol><h3 id="其他分类方法"><a href="#其他分类方法" class="headerlink" title="其他分类方法"></a>其他分类方法</h3><ol><li>遗传算法</li><li>粗糙集算法</li><li>模糊集算法</li><li>多类分类</li><li>半监督分类</li><li>主动学习</li><li>迁移学习</li></ol><h2 id="第十章-聚类分析：基本概念和方法"><a href="#第十章-聚类分析：基本概念和方法" class="headerlink" title="第十章 聚类分析：基本概念和方法"></a>第十章 聚类分析：基本概念和方法</h2><ol><li>划分方法：k-均值，k-中心点</li><li>层次方法</li><li>基于密度的方法</li><li>基于网格的方法</li><li>簇的形心、半径、直径</li><li>聚类评估</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据挖掘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>孙若诗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网笔记</title>
    <link href="/AcceptedHelper/2021/11/17/web_note/"/>
    <url>/AcceptedHelper/2021/11/17/web_note/</url>
    
    <content type="html"><![CDATA[<p>本文件为计算机网络的笔记</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/FDU19CS/AcceptedHelper@hexo/source/_posts/web_note/Note.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>唐侨</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS笔记</title>
    <link href="/AcceptedHelper/2021/11/13/os_note/"/>
    <url>/AcceptedHelper/2021/11/13/os_note/</url>
    
    <content type="html"><![CDATA[<p>本文件为操作系统的笔记</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/FDU19CS/AcceptedHelper@hexo/source/_posts/os_note/Note.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>黄绵秋</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算理论基础复习笔记</title>
    <link href="/AcceptedHelper/2021/06/24/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/AcceptedHelper/2021/06/24/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算理论基础复习笔记"><a href="#计算理论基础复习笔记" class="headerlink" title="计算理论基础复习笔记"></a>计算理论基础复习笔记</h1><p>待更新</p><h2 id="预备知识与基本文法理论（讲义第一章、第二章）"><a href="#预备知识与基本文法理论（讲义第一章、第二章）" class="headerlink" title="预备知识与基本文法理论（讲义第一章、第二章）"></a>预备知识与基本文法理论（讲义第一章、第二章）</h2><p>第一章大部分内容在其他课程里讲过了，新的内容只有：</p><blockquote><p>前缀性质：L 中任何字符串都不是另一个字符串的真前缀</p></blockquote><p>第二章讲了文法的基本概念。</p><blockquote><p><strong>文法</strong> $G$ 是四元组 $(V, T, P, S)$， V 是变元的有限集，T 是终结符有限集，P 是生成式有限集， S 是开始符号。</p></blockquote><blockquote><p>=&gt; 关系为<strong>直接派生</strong>，多步直接派生为<strong>派生</strong>。</p></blockquote><blockquote><p>文法 $G$ 产生的<strong>语言</strong> $L(G)$ 是 S 派生出来的终结符号串的全体。</p></blockquote><blockquote><p>0型文法（短语结构文法 PSG ）：对生成式无限制。</p><p>1型文法（上下文有关文法 CSG ）：每个生成式左侧长度≤右侧长度</p><p>1°型文法（上下文有关文法的另一种形式）：每个生成式，左侧至少包含一个变元，删去该变元后的前缀与后缀（可为空）也是右侧的前缀与后缀。$\alpha_1A\alpha_2 \rightarrow \alpha1\beta\alpha_2, \beta不为空$，前缀$\alpha_1$和后缀$\alpha_2$即为上下文。</p><p>2型文法（上下文无关文法 CFG ）：每个生成式左侧仅包含一个变元</p><p>3型文法（正规文法 RG ）：每个生成式左侧仅包含一个变元，且右侧必须形如 $a$ 或 $aB$ ，$a \in T \ 或a为空串$</p></blockquote><p>将1型文法转为1°型文法：</p><ol><li>对所有终结符$a$，添加变元$[a]$。</li><li>将原有生成式中所有终结符替换为对应新变元（如将$a$替换为$[a]$）。此时，所有生成式都只含变元。</li><li>对所有终结符$a$，添加生成式$[a]\rightarrow a$。</li><li>对所有不符合1°型文法的生成式，若左侧为$A_1A_2\ …\ A_n$，右侧为$B_1B_2…B_m$ ，则添加$n$个变元，用新的 $2n$ 个生成式替换这个生成式。新的生成式中：<ul><li>第 $i+1$ 个生成式的左侧是第 $i$ 个生成式的右侧；</li><li>前 $n$ 个生成式将 $A_1A_2…A_n$ 逐渐替换为 $C_1C_2…C_n$，每个生成式替换一个最靠前的 $A$（第一个生成式为$A_1A_2…A_n\rightarrow C_1A_2…A_n$）；</li><li>接下来的 $n-1$ 个生成式将 $C_1C_2…C_n$ 逐渐替换为 $B_1B_2…B_{n-1}C_n$， 每个生成式替换一个最靠前的 $C$ （第 $n+1$个生成式为$C_1C_2…C_n\rightarrow B_1C_2…C_n$）；</li><li>最后的生成式将 $C_n$ 替换为 $B_nB_{n+1}…B_m$ 。</li></ul></li></ol><p>2型文法的<strong>派生树</strong>：根节点为 S ；内部节点为变元；某个节点（有标记A）的孩子从左到右收集而成的字符串s，必有$A\rightarrow s$属于生成式集合（对应<em>直接派生</em>）；<strong>边缘</strong>是叶子节点从左到右收集而成的字符串（对应<em>派生</em>）。派生树可对应一个字符串从 S 开始的派生过程。</p><p><strong>最左派生</strong>：派生过程每一步都只替换最左边的变元。（同理有<strong>最右派生</strong>）</p><p><strong>多义</strong>：某个字符串有两种不同派生过程。</p><h2 id="有穷自动机、正规表达式、正规集（讲义第三、四章，MIT教材第一章）"><a href="#有穷自动机、正规表达式、正规集（讲义第三、四章，MIT教材第一章）" class="headerlink" title="有穷自动机、正规表达式、正规集（讲义第三、四章，MIT教材第一章）"></a>有穷自动机、正规表达式、正规集（讲义第三、四章，MIT教材第一章）</h2><blockquote><p><strong>有穷自动机</strong> （FA） 是五元组 $(Q,\Sigma,\delta,q_0,F)$，分别对应：有穷状态集、有穷输入字符表、转移函数、初始状态、终结状态集。</p><p>转移函数的输入为单个字符，可扩充为字符串。</p><p>FA 接收的字符串 s ：以 s 作为 FA 的输入，状态从初始的 $q_0$ 转移到 F 里的状态。</p></blockquote><h3 id="几种转换"><a href="#几种转换" class="headerlink" title="几种转换"></a>几种转换</h3><ol><li><p>$DFA \rightarrow Regular\ Expression$</p><p>讲义上的方法是：</p><ul><li><p>如果有 $k$ 个状态，算出 $k^3$ 个正规表达式 $r_{ij}^k$，表示输入串使状态机从状态 i 到 j 中间不经过编号高于 k 的状态。</p></li><li><p>$k = 0$ 时，状态图中若有从状态 i 到状态 j 的箭头，就把箭头上的字符加到集合里。$i == j$ 时，这个集合里还要包含空串。</p></li><li><p>$k \ne 0$ 时，有递推式 $r_{ij}^k = r_{ik}^{k-1}(r_{kk}^{k-1})^*r_{kj}^{k-1} \cup r_{ij}^{k-1}$</p></li></ul><p>MIT 教材上的方法是：</p><ul><li>将 DFA 转为 GNFA （GNFA的转换条件可以是正规表达式）：添加两个状态 s 和 t ，s 为新的初始状态，t 为新的终结状态。s 通过 $\epsilon$ 动作到原有的每个初始状态，原有的每个终结状态通过 $\epsilon$ 动作到 t</li><li>将 GNFA 的状态数缩减到2：下面的 RE 三种四句的反向操作，可将状态数减1</li><li>将 2-state GNFA 转换为 RE：转换条件即为所求</li></ul></li><li><p>$Regular Expression \rightarrow \epsilon-NFA$</p><p>处理三种类型的子句即可。讲义 p65-p66 的三张图</p><ul><li>$r_1+r_2$：两路分叉、两路归并</li><li>$r_1r_2$：前面的终结状态指向后面的初始状态</li><li>$r_1^*$：终结状态回到初始状态</li></ul></li><li><p>$\epsilon-NFA \rightarrow NFA$</p><p>讲义 p59</p><p>先检查 $q_0$ 是否为终结状态。</p><p>转移函数取一个闭包。</p></li><li><p>$NFA \rightarrow DFA$</p><p>讲义 p55</p><p>NFA 中，$\delta(q, a)$ 的结果是一个状态集。建立状态集到状态元组双射，把状态元组看作一个新的状态。将状态元组作为 $\delta$ 的输入，结果为元组中状态作为输入的结果的并集。一直做下去，直到不产生新的状态。</p></li></ol><p>正规文法转为 $\epsilon-NFA$：</p><ul><li>每个变元为状态，每个终结符为输入字符</li><li>转移函数的输入：派生左侧的变元、派生右侧的终结符（或 $\epsilon$）；输出为派生右侧的变元（或终结状态）</li></ul><p>DFA 转为正规文法：同上。</p><h3 id="缩胀定理"><a href="#缩胀定理" class="headerlink" title="缩胀定理"></a>缩胀定理</h3><p><strong>正规集缩胀定理</strong>：A 是正规集，则存在 p (pumping length) 使长度大于等于 p 的 A 中任意 s，可拆成三部分 $s=xyz$，满足：</p><ul><li>$xy^iz\in A, \forall i \ge 0$</li><li>$|y| \gt 0$</li><li>$|xy|\le p$</li></ul><p>（讲义上的定理给 s 和 $xy^iz$ 加了前缀和后缀，移去了最后一个限制。）</p><p>正规集在并、连接、闭包运算（由正规表达式的定义）、补运算（终结状态取补）、交运算（两个 DFA 的状态集、终结状态集取笛卡尔积）、商运算（ 在 R1/R2 中，R1 状态集为 Q，建立 |Q| 个 DFA，分别以 Q 中每个状态为初始状态，检测这些 DFA 交 R2 是否为空）下封闭。这些性质可以用来判定某个集合 C 不是正规集：取已知正规集 A 和已知非正规集 B，使 A 和 C 在某种封闭运算下变为 B，则 C 不是正规集。</p><p>一些判定问题：具有 n 个状态的 FA 有以下性质</p><ul><li>接受集合非空，iff 接受一个长度小于 n 的串</li><li>接受集合无穷，iff 接受一个长度在 [n, 2n) 之间的串</li><li>是否为空、是否无穷、是否等价 是可判定的</li></ul><h3 id="极小化算法"><a href="#极小化算法" class="headerlink" title="极小化算法"></a>极小化算法</h3><blockquote><p>状态的等价：$\forall x \in \Sigma^*, \delta(p,x)\in F\ \leftarrow \ \delta(q,x)\in F$</p><p>商自动机：状态集是 Q 的各等价类；自动机和它的商自动机等价</p></blockquote><p>极小化算法：</p><ul><li>对所有状态对 {p, q} 画一个下三角矩阵</li><li>对 $p\in F,q\notin F$ 的 ${p, q}$，在相应位置做标记</li><li>重复此步直到矩阵不再变化：$\exists a\in\Sigma,{\delta(p,a),\delta(q,a)}$ 被标记，则标记 $(p,q)$</li><li>没被标记的状态对是等价的</li></ul><h3 id="Myhill-Nerode-定理"><a href="#Myhill-Nerode-定理" class="headerlink" title="Myhill-Nerode 定理"></a>Myhill-Nerode 定理</h3><blockquote><p>两个 DFA 同构：状态集存在双射，且满足一些性质</p><p>右不变：对于等价关系 R，xRy 可推出 xzRyz</p><p>关于集合 A 的 <code>Myhill-Nerode</code> 关系：右不变、细分A、具有有穷指数</p></blockquote><p><strong>DFA 与 <code>Myhill-Nerode</code> 的关系</strong>：</p><ul><li><p>DFA M $\rightarrow$ <code>Myhill-Nerode</code> 关系 $R_M$：$xR_My\leftarrow\delta(q_0,x)=\delta(q_0,y)$</p></li><li><p><code>Myhill-Nerode</code> 关系 $\rightarrow$ DFA $M_R$ : $Q = {[x]|x\in\Sigma^*}, q_0 = {[e]}, F = {[x]|x\in A}, \delta([x],a)=[xa]$，有 $L(M_R) = A$</p></li></ul><p><strong>反复横跳</strong>：</p><ul><li>$R_{M_R}=R$，R 是 <code>Myhill-Nerode</code> 关系</li><li>$M_{R_M}$ 同构于 $M$，M 是 FA</li></ul><blockquote><p>等价关系 $R_A$：$xR_Ay:\forall z\in\Sigma^*,xz\in A \leftarrow yz \in A$. $R_A$ 右不变、细分 A </p></blockquote><p><strong>Myhill-Nerode定理</strong>：</p><ul><li>正规集有一个 <code>Myhill-Nerode</code> 关系 $R_M$</li><li>若 A 有 <code>Myhill-Nerode</code> 关系，则 $R_A$ 有有穷指数</li><li>若 $R_A$ 有有穷指数，则$R_A$ 是 $Myhill-Nerode$ 关系，构造 $M_{R_A}$ 接受 A</li></ul><p>$M_{R_A}$ 是状态数最少的。</p><h3 id="归纳：判定某个集合不是正规集"><a href="#归纳：判定某个集合不是正规集" class="headerlink" title="归纳：判定某个集合不是正规集"></a>归纳：判定某个集合不是正规集</h3><ul><li>缩胀定理</li><li>利用封闭运算</li><li>集合的关系 $R_A$ 没有有穷指数</li></ul><h2 id="上下文无关文法、下推自动机（讲义第五、六章，MIT教材第二章）"><a href="#上下文无关文法、下推自动机（讲义第五、六章，MIT教材第二章）" class="headerlink" title="上下文无关文法、下推自动机（讲义第五、六章，MIT教材第二章）"></a>上下文无关文法、下推自动机（讲义第五、六章，MIT教材第二章）</h2><h3 id="化简-CFG"><a href="#化简-CFG" class="headerlink" title="化简 CFG"></a>化简 CFG</h3><blockquote><p>无用符号：$X\in V\cup T$ 但 $X$ 不出现在 S 派生出的字符串中；$X\in V$ 但 X 不能派生任何终结符号串</p></blockquote><p>消去无用符号的步骤：</p><ul><li>先消去 (2) 类无用符号（引理5.1）：构造新的 $V’$ ，若生成式 $A\rightarrow X_1X_2…X_n$ 右侧的每一 $X_i \in T^*\cup V’$，则把 A 加到 $V’$ 中。</li><li>再消去 (1) 类无用符号（引理5.2）：构造新的 $V’$ 和 $T’$，首先将 S 放入 $V’$ 中，若某个生成式左侧的变元属于 $V’$，则将该生成式右侧的变元放入 $V’$ 中，终结符放入 $T’$ 中。</li></ul><blockquote><p>变元 A 可为零：A 可以派生空串</p><p>$\epsilon$-生成式：右端为空</p></blockquote><p>消去 $\epsilon$-生成式（使 $L(G’) = L(G) -{\epsilon}$）的步骤：</p><ul><li>确定可为零的变元集 Z：先把直接派生空串的变元放入 Z 中，然后检查右侧全为变元的生成式，若右侧变元全在 Z 中，则把该生成式左侧变元放入 Z 中。</li><li>构造新的生成式集合 $P’$：对 $P$ 中所有生成式，检查右侧的每一个符号，如果不属于 Z 则不改变，属于 Z 则改为 $\epsilon$ 或不改变（不改变的情况是防止修改后右侧全为 $\epsilon$）。</li><li>消去无用符号</li></ul><blockquote><p>单一生成式：左右端皆为一个变元</p></blockquote><p>不含空串的 CFL，消去单一生成式的步骤：</p><ul><li>构造新的生成式集合 $P’$：先将 $P$ 中非单一生成式放入 $P’$，对单一生成式 $A\rightarrow B$，如果 $B\rightarrow \alpha$ 是 $P’$ 中元素，则将 $A\rightarrow \alpha$ 放入 $P’$。</li><li>消去无用符号</li></ul><h3 id="CFG-范式"><a href="#CFG-范式" class="headerlink" title="CFG 范式"></a>CFG 范式</h3><blockquote><p><code>Chomksky</code> 范式：每个生成式右侧为两个变元或一个终结符</p></blockquote><p>不含空串的 CFL 转为 <code>Chomsky</code> 范式的步骤：</p><ul><li>消去单一生成式、$\epsilon$-生成式和无用符号</li><li>如果某生成式右侧只有一个符号，则它一定是终结符</li><li>如果某生成式 $p$ 右侧同时包含变元和终结符，则对每个终结符 $a$，添加变元 $C_a$ 和生成式 $C_a \rightarrow a$ ，用这个变元替换掉 $p$ 右侧的对应终结符</li><li>此时，所有生成式除去形如 $A\rightarrow a$ 的，其他生成式右侧不含终结符。如果某个生成式仅包含 $m(m\ge 2)$ 个变元，则添加 $m-2$ 个变元和若干个生成式，使每个生成式右侧仅含2个变元。如 $A\rightarrow B_1B_2B_3$ 可拆成 $A\rightarrow B_1D_1, D_1 \rightarrow B_2B_3$</li></ul><blockquote><p><code>Greibach</code> 范式：每个生成式右侧的第一个符号为终结符</p></blockquote><p>不含空串的 CFL 转为 <code>Greibach</code> 范式的步骤：</p><ul><li>转为 <code>Chomsky</code> 范式</li><li>对变元进行编号。保证每个形如 $A_k \rightarrow A_j\alpha$ 生成式右侧的第一个变元编号 $A_j$ 大于左侧变元，如果不大于则用已检查过的 $A_j \rightarrow A_m\alpha$ 替换，这样右侧第一个变元的编号严格递增，这一步可以在有限次数内完成。如果遇到 $A_k \rightarrow A_k\alpha$ 则加入新的生成式 $B_k \rightarrow \alpha,\ B_k \rightarrow \alpha B_k,\ A_k \rightarrow \beta B_k$，对一切已有的 $A_k \rightarrow \beta$</li><li>处理 $A_i \rightarrow A_j \gamma\ ,j&gt;i$。左部变元编号从大到小开始处理：编号为最大时，生成式右侧第一个符号必为终结符；其他情况，右侧第一个变元用已有生成式代入，代入后编号递增，达到编号最大时，再代入一次，右侧第一个符号也变为终结符。</li><li>处理以新加入的 $B_i$ 变元为左部的生成式。其右侧第一个符号只可能是是终结符或 $A_j$，出现后者时再做一次编号递增即可。</li></ul><h3 id="下推自动机"><a href="#下推自动机" class="headerlink" title="下推自动机"></a>下推自动机</h3><blockquote><p>下推自动机 PDA 是七元组 $(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)$，比 DFA 多了 $\Gamma$ 有穷的栈符号表，$Z_0$ 栈底符号。</p><p>转移函数的形式是 $\delta(q,a,Z) = {(p_1,\gamma_1),…,(p_m,\gamma_m)}$，表示当状态为 q，读入字符 a，且栈顶为 Z 时，将状态改为 p，栈顶改为 $\gamma$。</p><p>瞬时描述 ID 是三元组 $(q,w,\gamma)$，w 为未读过的输入，$\gamma$ 为栈中符号串（左侧为栈顶）。$(p_1,\gamma_1) \in \delta(q,a,Z)$ 可表示为 $(q,aw,Z\alpha) \vdash (p_1, w, \gamma_1\alpha)$</p><p>L(M) 是 M 按终结状态方式接受的语言，N(M) 是 M 按空栈方式接受的语言。它们是等价的。</p></blockquote><p>已知 $M_1$， 构造 $M_2$ 使 $L(M_1) = N(M_2)$：</p><ul><li>添加两个状态 $q_e, q_0’$，$q_e$为接受完毕并准备清空栈，$q_0’$为新的初始状态。添加栈符号 $X_0$ 作为栈底符号</li><li>初始：$\delta’(q_0,\epsilon,X_0)={(q_0,Z_0X_0)}$，$Z_0$ 为 $M_1$ 栈底符号</li><li>终结：$\delta’(q,\epsilon,Z)包含(q_e,\epsilon)$，当 q 是终结状态，并清空栈：$\delta’(q_e,\epsilon,Z)={(q_e,\epsilon)}$</li></ul><p>已知 $M_1$， 构造 $M_2$ 使 $N(M_1) = L(M_2)$：</p><ul><li>添加新的初始状态、终结状态、栈底符号</li><li>初始：状态改为 $M_1$ 的初始状态，将 $M_1$ 的栈底符号压入栈</li><li>终结：当栈顶符号为 $M_2$ 栈底符号是，说明栈为空，如果没有输入了，就转至终结状态</li></ul><p>已知 CFL L，构造 PDA M 使 $L = N(M)$：</p><ul><li>若 L 接受空串，则加上 $\delta(q,\epsilon,S) = {(q,\epsilon)}$</li><li>除去空串，设 G 为产生 L 的 <code>Greibach</code> 文法，构造转移函数：若 $A\rightarrow a\gamma\in P$ 则 $\delta(q,a,A) 包含 (q,\gamma)$</li></ul><p>已知 PDA M， 构造 CFL L 使 $L=N(M)$：</p><ul><li>构造 $V={[q,A,p]|q,p\in Q,A\in\Gamma}\cup{S}$</li><li>初始：$S\rightarrow [q_0,Z_0,q], q \in Q$</li><li>当 $\delta(q,a,A)包含(q_1,B_1B_2…B_m)$ 则有 $[q,A,q_{m+1}]\rightarrow a[q_1,B_1,q_2][q_2,B_2,q_3]…[q_m,B_m,q_{m+1}]$。</li></ul><h3 id="缩胀定理-1"><a href="#缩胀定理-1" class="headerlink" title="缩胀定理"></a>缩胀定理</h3><blockquote><p>基础版：</p><p>$\forall k\ge 0,\exists z\in L, |z| \ge k, z = uvwxy, |vx|\ge 1,|vwx|\le k, \exists i \ge 0, uv^iwx^iy \notin L$， 则 L 不是 CFL。</p></blockquote><p>步骤：</p><ul><li>拆成5份</li><li>中间部分不超过k，要扩展的部分不都为空</li><li>将第2、4部分进行复制，或删除</li></ul><blockquote><p><code>Ogden</code> 定理：</p><p>若 L 是 CFL，存在 $k\ge 0$，对每个 $z\in L, z=uvwxy$，在 z 中标出 $\ge k$ 个特别符号，使：vx 至少包含一个特别符号、vwx 最多包含 k 个特别符号。</p></blockquote><p>CFL 在并、连接、闭包运算下封闭，在交、补运算下不封闭（不可判定）。</p><p>CFG 接受的语言是否为空、是否有穷的问题可判定。</p><p>成员资格问题的 CYK 算法：</p><ul><li>将 CFG 转为 <code>Chomsky</code> 范式。记 $x_{ij}$ 为 $x.substr(i,j)$。</li><li>判别 $x_{ij}$ 可由哪些变元派生，从 $j=1\ to\ n$ 依次判别。<ul><li>当 j = 1 时，可由生成式得出。</li><li>当 j &gt; 1 时，A 可派生出 $x_{ij}$，当且仅当 $\exists A\rightarrow BC$ 且 B 派生 $x_{ij}$ 的前一段，C 派生 $x_{ij}$ 的后一段。</li></ul></li></ul><h2 id="图灵机、递归集、不可判定性（讲义第七、八章）"><a href="#图灵机、递归集、不可判定性（讲义第七、八章）" class="headerlink" title="图灵机、递归集、不可判定性（讲义第七、八章）"></a>图灵机、递归集、不可判定性（讲义第七、八章）</h2><blockquote><p>确定的单带图灵机 TM 是9元组 $(Q,\Sigma,\Gamma,左端标记,空白符号,\delta,初始状态,接受状态,拒绝状态)$</p><p>$\delta(p,a)=(q,b,R)$</p><p>瞬时描述 ID 为 $\alpha_1 q \alpha_2$，（读写头左侧，状态，读写头及其右侧）</p><p>完全的图灵机：对一切输入都能停机</p><p>图灵机接受的语言：递归可枚举集（r.e.）</p><p>完全图灵机接受的语言：递归集</p></blockquote><h3 id="图灵机的构造技术"><a href="#图灵机的构造技术" class="headerlink" title="图灵机的构造技术"></a>图灵机的构造技术</h3><ul><li>有限控制器中的存储：状态可以是 n 元组</li><li>移动：将带上符号吸收到状态上</li><li>多道技术：每个带符号是 n 元组</li><li>查讫符号：带符号是2元组 (字符，标记)</li><li>子程序技术<ul><li>调用：转到子程序的初始状态</li><li>返回：到达子程序的返回状态</li></ul></li></ul><h3 id="图灵机的类型"><a href="#图灵机的类型" class="headerlink" title="图灵机的类型"></a>图灵机的类型</h3><ul><li>双向无限带</li><li>多带</li><li>非确定</li><li>双栈</li><li>带字母最少</li><li>枚举器</li></ul><h3 id="递归集与不可判定问题"><a href="#递归集与不可判定问题" class="headerlink" title="递归集与不可判定问题"></a>递归集与不可判定问题</h3><table><thead><tr><th></th><th>递归集</th><th>递归可枚举</th></tr></thead><tbody><tr><td>补</td><td>封闭</td><td>如果 L 和 L 的补是递归可枚举的，它们是递归的</td></tr><tr><td>并</td><td>封闭</td><td>封闭</td></tr><tr><td>交</td><td>封闭</td><td>封闭</td></tr></tbody></table><blockquote><p>通用图灵机 U 是能模拟任何图灵机的图灵机</p></blockquote><p>$L(U)={M#x|x\in L(M)}$，#为分隔符</p><p>任意给定的 TM M 对任意给定的输入串 x 是否停机的问题是不可判定的。</p><p>对任意给定的 TM M 和输入串 x，M 是否接受 x 的问题是不可判定的。</p><p>给定一个 TM M，它是否接受空串的问题是不可判定的。</p><blockquote><p>A 到 B 的<strong>归约</strong>：存在函数 f，$x\in A \leftarrow f(x) \in B$，记 $A\le_m B$，m 表明归约是多对一的。</p></blockquote><p>若 $A\le_m B$：</p><ul><li>B 是 r.e. =&gt; A 是 r.e.</li><li>B 是递归集 =&gt; A 是递归集</li></ul><blockquote><p><strong>性质</strong> 是一个映射：定义域是 $\Sigma^*$ 的 r.e. 子集，值域是 {True, False}</p><p>平凡性质：映射只取 True 或 False</p></blockquote><p>Rice 定理：r.e. 集合类的任一非平凡性质都是不可判定的。</p>]]></content>
    
    
    <categories>
      
      <category>计算理论基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Malloc Lab 动态内存分配器</title>
    <link href="/AcceptedHelper/2021/05/22/MallocLab/"/>
    <url>/AcceptedHelper/2021/05/22/MallocLab/</url>
    
    <content type="html"><![CDATA[<h1 id="Malloc-Lab"><a href="#Malloc-Lab" class="headerlink" title="Malloc Lab"></a>Malloc Lab</h1><p>​    个人的实验报告，放上来给大家参考。</p><p>​    Malloc lab 需要我们编写一个类似 libc malloc 的动态内存分配器，其主要考察动态内存分配器的原理设计以及堆内存的结构组织，同时需要比较强的 DEBUG 能力。最后在不使用BST以及其他全局数据结构的情况下我的方法达到了 97/100 的分数</p><p><a href="https://github.com/ZiYang-xie/Malloc_Lab">ZiYang-xie/Malloc_Lab: CMU Malloc Lab Repo (github.com)</a></p><h2 id="一、空闲块组织结构"><a href="#一、空闲块组织结构" class="headerlink" title="一、空闲块组织结构"></a>一、空闲块组织结构</h2><p>​    在结构设计上我采用了分离存储的显示链表形式来进行组织空闲块，在书上说明了分离存储的思想，但没有具体说明实现方法。在此我使用称为 <strong>Segregated Free List</strong> 的空闲块组织设计，即在堆的低地址分配数量等于 <code>SEG_LEN</code> 的指针，每个指针分别对应着一个大小类，指向正式堆块中的空闲块，相当于 <code>SEG_LEN</code> 个链表。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gquqskpijgj30ff07cdg2.jpg" alt="Segregated Free List"></p><p>​    在我的代码设计中，我以2的幂次分割大小类，由于空闲块最小块大小为16 bytes （包括头尾标记以及前后指针）因此其设计为 {2^4 ~ 2^5} \ {2^5 ~ 2^6} \ {2^6 ~ 2^7} …(类推)</p><p> 为了区分某一空闲块应该被放置在哪个类中，我们需要一个 <strong>get_index</strong> 函数，正常设计也十分简单，即通过一个循环右移，计算位数。在这里我参考了 <strong>Bit twiddling hacks</strong> 著名位运算<em>奇技淫巧</em> 网站，采用了一个位运算的 log2 方式，其可以在 O(1) 的复杂度计算出 log2(x)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_index</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> v)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 本质上是位运算的 log 2, O(1)复杂度</span><br>    <span class="hljs-comment">// 参考 &#x27;Bit twiddling hacks&#x27;</span><br>    <span class="hljs-comment">// Linking: https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogLookup</span><br>    <br>    <span class="hljs-keyword">size_t</span> r, shift;<br>    r = (v &gt; <span class="hljs-number">0xFFFF</span>)   &lt;&lt; <span class="hljs-number">4</span>; v &gt;&gt;= r;<br>    shift = (v &gt; <span class="hljs-number">0xFF</span>) &lt;&lt; <span class="hljs-number">3</span>; v &gt;&gt;= shift; r |= shift;<br>    shift = (v &gt; <span class="hljs-number">0xF</span>)  &lt;&lt; <span class="hljs-number">2</span>; v &gt;&gt;= shift; r |= shift;<br>    shift = (v &gt; <span class="hljs-number">0x3</span>)  &lt;&lt; <span class="hljs-number">1</span>; v &gt;&gt;= shift; r |= shift;<br>                                          r |= (v &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 从 2^4 开始 (空闲块最小 16 bytes)</span><br>    <span class="hljs-keyword">int</span> x = (<span class="hljs-keyword">int</span>)r - <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>) <br>        x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(x &gt;= SEG_LEN) <br>        x = SEG_LEN - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、堆内存设计"><a href="#二、堆内存设计" class="headerlink" title="二、堆内存设计"></a>二、堆内存设计</h2><p>​    在空闲块指针之上，分配正常的堆块，正常的堆块由<strong>序言块</strong> （一个已分配大小为8的块），以及<strong>结尾块</strong>（一个已分配大小为0的块）前后包围，这样可以很方便的检验边界情况，当后继块大小为0，那么便可判断其达到了结尾。之后便记录下全局的开始地址 <code>global_list_start_ptr</code> 即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 空闲块 */</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; SEG_LEN; ++i)<br>  PUT(heap_listp + i*WSIZE, <span class="hljs-literal">NULL</span>);            <span class="hljs-comment">// 初始化空闲块大小类头指针</span><br><br><span class="hljs-comment">/* 分配块 */</span><br>PUT(heap_listp + (i+<span class="hljs-number">0</span>)*WSIZE, PACK(DSIZE, ALLOCATED));  <span class="hljs-comment">/* 序言块头部 */</span><br>PUT(heap_listp + (i+<span class="hljs-number">1</span>)*WSIZE, PACK(DSIZE, ALLOCATED));  <span class="hljs-comment">/* 序言块尾部 */</span><br>PUT(heap_listp + (i+<span class="hljs-number">2</span>)*WSIZE, PACK(<span class="hljs-number">0</span>, ALLOCATED));      <span class="hljs-comment">/* 结尾块头部 */</span><br><br>global_list_start_ptr = heap_listp;<br>heap_listp += (i+<span class="hljs-number">1</span>)*WSIZE; <span class="hljs-comment">// 对齐到起始块有效载荷</span><br></code></pre></td></tr></table></figure><h2 id="三、具体设计"><a href="#三、具体设计" class="headerlink" title="三、具体设计"></a>三、具体设计</h2><p>​    接下来以函数为单位详细介绍实现过程</p><pre><code>### mm_init 初始化堆</code></pre><p>​    堆内存设计块节中以及包含大部分，mm_init 代码，在组织完堆初始化的指针之后就可以进行分配栈空间以一个初始化的空闲块，这涉及到了 extend_heap 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 扩展空栈至 CHUNKSIZE bytes */</span><br>    <span class="hljs-keyword">if</span>(extend_heap(CHUNKSIZE) == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="extend-heap-堆扩展"><a href="#extend-heap-堆扩展" class="headerlink" title="extend_heap 堆扩展"></a>extend_heap 堆扩展</h3><p>​    对于堆扩展，我们调用 mm_sbrk 函数将lab中设计好的抽象 program breaker 上移扩展堆大小，其返回空闲块的头指针，我们设置好它的头尾标记，并通过 coalesce 函数在进行前后空闲块合并之后插入到空闲块链表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">extend_heap</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> asize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *bp;<br>    <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>)(bp = mem_sbrk(asize)) == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-comment">/* 初始化空闲块的头尾和结尾块的头部 */</span><br>    PUT(HDRP(bp), PACK(asize, FREE));                <span class="hljs-comment">/* 空闲块头部 */</span><br>    PUT(FTRP(bp), PACK(asize, FREE));                <span class="hljs-comment">/* 空闲块尾部 */</span><br>    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="hljs-number">0</span>, ALLOCATED));    <span class="hljs-comment">/* 结尾块头部 */</span><br><br>    <span class="hljs-keyword">return</span> coalesce(bp);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="coalesce-合并块"><a href="#coalesce-合并块" class="headerlink" title="coalesce 合并块"></a>coalesce 合并块</h3><p>​    合并块的模式包含四种情况，并且在我的设计模式中，在合并后将空闲块插入到空闲链表中去，形成一体化操作。</p><ul><li><strong>Case1: 前后均不空闲</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; next_alloc)&#123;                   <span class="hljs-comment">/* 前后非空闲 */</span><br>  insert_free_block(bp);<br>  <span class="hljs-keyword">return</span> bp;<br>&#125;<br></code></pre></td></tr></table></figure><p>前后均不空闲的时候就直接插入当前空闲块，并返回bp</p><ul><li><strong>Case2: 后空闲</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)&#123;             <span class="hljs-comment">/* 后空闲 */</span><br>  size += NEXT_BLKSZ(bp);<br>  delete_free_block(NEXT_BLKP(bp));<br>  PUT(HDRP(bp), PACK(size, FREE));<br>  PUT(FTRP(bp), PACK(size, FREE));<br>  PUT(PRED(bp), <span class="hljs-literal">NULL</span>);<br>  PUT(SUCC(bp), <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    后空闲的时候就从空闲链表中删除后方空闲块，并把当前块的头部和后部块的尾部大小设计为扩展后大小 <em>( 由于 FTRP 中调用了 HDRP，所以先设计HDRP的size之后FTRP能够正确定位到尾部 )</em> 并且设置空闲块前驱后继指针为NULL做好清理。</p><ul><li><strong>Case3:</strong> 前空闲</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(!prev_alloc &amp;&amp; next_alloc) &#123;            <span class="hljs-comment">/* 前空闲 */</span><br>  size += PREV_BLKSZ(bp);<br>  delete_free_block(PREV_BLKP(bp));<br><br>  PUT(FTRP(bp), PACK(size, FREE));<br>  PUT(HDRP(PREV_BLKP(bp)), PACK(size, FREE));<br><br>  bp = PREV_BLKP(bp);<br>  PUT(PRED(bp), <span class="hljs-literal">NULL</span>);<br>  PUT(SUCC(bp), <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    前空闲就从空闲链表中删除前方空闲块，并且注意分配的头部标记是前一块的头部标记，其余逻辑和 Case2类似</p><ul><li><strong>Case4:</strong> 前后均非空闲</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 前后均空闲 */</span><br>  size += NEXT_BLKSZ(bp) + PREV_BLKSZ(bp);<br>  delete_free_block(PREV_BLKP(bp));<br>  delete_free_block(NEXT_BLKP(bp));<br>  PUT(HDRP(PREV_BLKP(bp)), PACK(size, FREE));<br>  PUT(FTRP(NEXT_BLKP(bp)), PACK(size, FREE));<br>  bp = PREV_BLKP(bp);<br>  PUT(PRED(bp), <span class="hljs-literal">NULL</span>);<br>  PUT(SUCC(bp), <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    前两种的结合，不多赘述</p><h3 id="insert-free-block-插入空闲链表"><a href="#insert-free-block-插入空闲链表" class="headerlink" title="insert_free_block 插入空闲链表"></a>insert_free_block 插入空闲链表</h3><p>​    插入空闲链表算是一个比较重要的函数，其关乎着空闲块的组织结构，在这里我采用的是<strong>地址排序</strong>的策略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert_free_block</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fbp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 地址排序 - Address Order</span><br>    <span class="hljs-keyword">void</span> *succ = root;<br>    <br>    <span class="hljs-keyword">while</span>(SUCC_BLKP(succ))&#123;<br>        succ = (<span class="hljs-keyword">char</span> *)SUCC_BLKP(succ);<br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)succ &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)fbp)&#123;<br>            <span class="hljs-comment">// 安装地址顺序插入空闲块</span><br>            <span class="hljs-comment">// PRED_BLKP(succ) &lt;-&gt; fbp &lt;-&gt; succ</span><br>            <span class="hljs-keyword">char</span> *tmp = succ;<br>            succ = (<span class="hljs-keyword">char</span> *)PRED_BLKP(succ);<br>            PUT(SUCC(succ), fbp);<br>            PUT(PRED(fbp), succ);<br>            PUT(SUCC(fbp), tmp);<br>            PUT(PRED(tmp), fbp);<br>            <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> INDEBUG</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;succ(PRE): %p \t tmp(SUCC): %p \t&quot;</span>, succ, tmp);<br>                print_free_list(<span class="hljs-string">&quot;Insert&quot;</span>);<br>            <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Base Case &amp; Last Case </span><br>    <span class="hljs-comment">// 当前大小类无空闲块 或者 在地址分配时当前空闲块地址最大被分配在最后</span><br>    PUT(SUCC(succ), fbp);<br>    PUT(PRED(fbp), succ);<br>    PUT(SUCC(fbp), <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    首先获得目标块的 index，即属于二的几次幂，之后通过 <code>global_list_start_ptr</code> 加上 index 偏移定位到其属于的大小类链表的 root 指针，如果root指针有指向就进行地址顺序的排序，如果找到后部块地址大于插入块，就把该插入块插到上述块的前部。</p><p>​    如果root没有指向，即当前该大小类中没有空闲块，或者按地址序，该块地址大小最大则进行直接的分配在succ之后。</p><h3 id="delete-free-block-删除空闲块"><a href="#delete-free-block-删除空闲块" class="headerlink" title="delete_free_block 删除空闲块"></a>delete_free_block 删除空闲块</h3><p>​    删除空闲块要注意，这里常见的bug是和 insert_free_block 一同出现的指针维护不良，导致删除不存在的块，或者访问 nullptr 的前后继以及指针越界问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete_free_block</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fbp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// NORMAL: GOT A SUCCESSOR AND PREDECESSOR</span><br>    <span class="hljs-keyword">if</span>(SUCC_BLKP(fbp) &amp;&amp; PRED_BLKP(fbp))&#123;<br>        PUT(SUCC(PRED_BLKP(fbp)), SUCC_BLKP(fbp));<br>        PUT(PRED(SUCC_BLKP(fbp)), PRED_BLKP(fbp));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(PRED_BLKP(fbp))&#123; <span class="hljs-comment">// LAST BLOCK</span><br>        PUT(SUCC(PRED_BLKP(fbp)), <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    PUT(SUCC(fbp), <span class="hljs-literal">NULL</span>);<br>    PUT(PRED(fbp), <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    正常情况是当前块是链表中间节点，重新连接好前后，把其从链表上脱离即可。如果是最后一个节点，就直接把前继节点的后继指针置为空。最后做好当前删除块的清理工作，把其前后继指针置为NULL</p><h3 id="mm-malloc-分配空闲块"><a href="#mm-malloc-分配空闲块" class="headerlink" title="mm_malloc 分配空闲块"></a>mm_malloc 分配空闲块</h3><p>​    mm_malloc 是该lab中的主要函数，用于控制分配内存块的工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mm_malloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> asize = align_size(size);    <span class="hljs-comment">/* 调整后的块大小 */</span><br>    <span class="hljs-keyword">size_t</span> extendsize;                  <span class="hljs-comment">/* 扩展堆大小 */</span><br>    <span class="hljs-keyword">char</span> *bp;<br><br>    <span class="hljs-comment">/* Trivial Case */</span><br>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* 寻找适配 */</span><br>    <span class="hljs-keyword">if</span>((bp = find_fit(asize, get_index(asize))) != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> place(bp, asize);<br><br>    <span class="hljs-comment">/* 未找到适配，分配更多堆空间 */</span><br>    extendsize = MAX(asize, CHUNKSIZE);<br>    <span class="hljs-keyword">if</span>((bp = extend_heap(extendsize)) == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">return</span> place(bp, asize);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    首先要做好分配大小的对齐，这里定义了一个util函数 align_size 用来对齐块大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">align_size</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* 调整块大小 */</span><br>    <span class="hljs-keyword">if</span>(size &lt;= DSIZE) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*DSIZE;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> DSIZE * ((size + (DSIZE) + (DSIZE - <span class="hljs-number">1</span>)) / DSIZE);<br><br>    <span class="hljs-comment">// Code Never Went Here</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    之后逻辑就是通过 find_fit 在空闲链表中寻找适配，如果没找到适配就进行 heap_extend，每次最小扩展 <code>CHUNKSIZE</code> bytes，这里我将 <code>CHUNKSIZE</code> 设为 512</p><p> <strong>(有讲究，如果大于520就会导致realloc2的第一次分配 512 就能够成功，这样之后alloc的块就跟在512块后，就不能成功的将 realloc 的 0 号 block 安排在块位，导致无法通过 extend_heap 来提高性能)</strong></p><p>最后放置空闲块，使用place函数进行分配和分割</p><h3 id="find-fit-寻找适配"><a href="#find-fit-寻找适配" class="headerlink" title="find_fit 寻找适配"></a>find_fit 寻找适配</h3><p>​    我使用的是简单的首次适配，即从小到大遍历分离空闲链表，找到第一块适合的空闲块。由于每个空闲链表内部是按地址顺序排列而非大小排列，所以其效果并非严格等同于 best_fit 但是由于大小分块的组织结构，其效果又好于完全不按空间大小排序的适配方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">find_fit</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> seg_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// First Fit</span><br>    <span class="hljs-keyword">char</span>* res;<br>    <span class="hljs-keyword">while</span>(seg_idx &lt; SEG_LEN)&#123;<br>        <span class="hljs-keyword">char</span> *root = global_list_start_ptr + seg_idx * WSIZE;<br>        <span class="hljs-keyword">char</span> *bp = (<span class="hljs-keyword">char</span> *)SUCC_BLKP(root);<br>        <span class="hljs-keyword">while</span>(bp)&#123;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-keyword">size_t</span>)CRT_BLKSZ(bp) &gt;= size)<br>                <span class="hljs-keyword">return</span> bp;<br>            <br>            bp = (<span class="hljs-keyword">char</span> *)SUCC_BLKP(bp);<br>        &#125;<br>        <span class="hljs-comment">// 在这类中未找到适合，在更大类中寻找</span><br>        seg_idx++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="place-分配块"><a href="#place-分配块" class="headerlink" title="place 分配块"></a>place 分配块</h3><p>​    分配块这里有说法了，第一层是分配空闲块的时候，如果当前适配的块大小比需要分配的大很多（超出最小空闲块大小 16bytes）那么我们就可以通过分割来减小内部碎片。</p><p>​    并且这个分割也是很有讲究，我们可以设计当需要分配的空间较大时例如大于64 bytes，我们就将其分配在空闲块的后部，将前部分割出来作为新的空闲块。如果小于就直接分配在当前空闲块的前部，将后部分割出来作为新的空闲块。这样的组织方式有两方面好处，</p><ul><li>一方面是其进行了大小分类，有利于块的合并</li><li>另一方面是对于 realloc2 的测试 trace，我们通过前部切分的方式，使 512 块后再次分配的两 128 块占用前部空间，这样可以使 512 块始终是最后一块即其后继块是结尾块，那么在 realloc 它的时候我们就可以直接通过 extend_heap 达到如此一来可以大大提高内存利用率，<strong>将realloc1、2的util提升至近100%！</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">place</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *bp, <span class="hljs-keyword">size_t</span> asize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> blk_size = CRT_BLKSZ(bp);<br>    <span class="hljs-keyword">size_t</span> rm_size = blk_size - asize;<br><br>    <span class="hljs-keyword">if</span>(!GET_ALLOC(HDRP(bp)))<br>        delete_free_block(bp);<br>    <span class="hljs-comment">// 剩余空间大于最小块大小的可分割的情况</span><br>    <span class="hljs-keyword">if</span>(rm_size &gt;= <span class="hljs-number">2</span>*DSIZE)&#123;<br>        <span class="hljs-comment">// 当块大小大于 64 时将其有效载荷放在空闲块后部，前部切分出来作为空闲块</span><br>        <span class="hljs-keyword">if</span>(asize &gt; <span class="hljs-number">64</span>)&#123;<br>            PUT(HDRP(bp), PACK(rm_size, FREE));<br>            PUT(FTRP(bp), PACK(rm_size, FREE));<br>            PUT(HDRP(NEXT_BLKP(bp)), PACK(asize, ALLOCATED));<br>            PUT(FTRP(NEXT_BLKP(bp)), PACK(asize, ALLOCATED));<br>            coalesce(bp);<br>            <span class="hljs-keyword">return</span> NEXT_BLKP(bp);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            PUT(HDRP(bp), PACK(asize, ALLOCATED));<br>            PUT(FTRP(bp), PACK(asize, ALLOCATED));<br>            PUT(HDRP(NEXT_BLKP(bp)), PACK(rm_size, FREE));<br>            PUT(FTRP(NEXT_BLKP(bp)), PACK(rm_size, FREE));<br><br>            coalesce(NEXT_BLKP(bp));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 不可分割情况</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        PUT(HDRP(bp), PACK(blk_size, ALLOCATED));<br>        PUT(FTRP(bp), PACK(blk_size, ALLOCATED));<br>    &#125;<br>    <span class="hljs-keyword">return</span> bp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mm-free-释放块"><a href="#mm-free-释放块" class="headerlink" title="mm_free 释放块"></a>mm_free 释放块</h3><p>​    直接设置空闲，并释放同时合并，没什么好说的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mm_free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Freeing.....\n&quot;</span>);<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-keyword">char</span> *bp = ptr;<br>    <span class="hljs-keyword">size_t</span> size = CRT_BLKSZ(bp);<br><br>    PUT(HDRP(bp), PACK(size, FREE));<br>    PUT(FTRP(bp), PACK(size, FREE));<br>    coalesce(bp);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mm-realloc-重分配块"><a href="#mm-realloc-重分配块" class="headerlink" title="mm_realloc 重分配块"></a>mm_realloc 重分配块</h3><p>​    mm_realloc 能否做好是分数能否上 90 的关键，其主要策略有两个</p><ul><li><p><strong>空闲块融合</strong></p><p>一在重分配的时候，如果后方有空闲块可以进行融合，再看空间够不够，如果够了就不用释放再分配了。</p><p>（同时前融合也应当有相应的效果，前融合要注意内部载荷数据的移动，但其实观察 trace 文件下的block组织表现，发现其实前融合很少甚至没有，对性能影响不大，之后便在代码中删除了）</p></li><li><p><strong>尾部堆扩展</strong></p><p>就是之前提到的如果要重分配的块是尾部块就执行 extend_heap 就行了，不需要释放再分配。同时注意到了 trace 文件中反复 realloc 首次分配的块，于是和 place 中提到的策略相互结合可以达到将首次分配的块移动到末尾的效果。</p></li></ul><p>其余就是一些基础写法，在注释中已经体现，还有需要注意一下<strong>分配大小的对齐</strong>和特殊情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mm_realloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 如果 ptr == NULL 直接分配</span><br>    <span class="hljs-keyword">if</span>(ptr == <span class="hljs-literal">NULL</span>)    <br>        <span class="hljs-keyword">return</span> mm_malloc(size);<br>    <span class="hljs-comment">// 如果 size == 0 就释放</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)&#123;<br>        mm_free(ptr);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">size_t</span> asize = align_size(size), old_size = CRT_BLKSZ(ptr);<br>    <span class="hljs-keyword">size_t</span> mv_size = MIN(asize, old_size);<br>    <span class="hljs-keyword">char</span> *oldptr = ptr;<br>    <span class="hljs-keyword">char</span> *newptr;<br><br>    <span class="hljs-keyword">if</span>(old_size == asize)<br>        <span class="hljs-keyword">return</span> ptr;<br>    <br>    <span class="hljs-keyword">size_t</span> prev_alloc =  GET_ALLOC(FTRP(PREV_BLKP(ptr)));<br>    <span class="hljs-keyword">size_t</span> next_alloc =  GET_ALLOC(HDRP(NEXT_BLKP(ptr)));<br>    <span class="hljs-keyword">size_t</span> next_size = NEXT_BLKSZ(ptr);<br>    <span class="hljs-keyword">char</span> *next_bp = NEXT_BLKP(ptr);<br>    <span class="hljs-keyword">size_t</span> total_size = old_size;<br><br>    <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; !next_alloc &amp;&amp; (old_size + next_size &gt;= asize))&#123;    <span class="hljs-comment">// 后空闲  </span><br>        total_size += next_size;<br>        delete_free_block(next_bp);<br>        PUT(HDRP(ptr), PACK(total_size, ALLOCATED));<br>        PUT(FTRP(ptr), PACK(total_size, ALLOCATED));<br>        place(ptr, total_size);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!next_size &amp;&amp; asize &gt;= old_size)&#123;   <span class="hljs-comment">// 如果后部是结尾块，则直接 extend_heap</span><br>        <span class="hljs-keyword">size_t</span> extend_size = asize - old_size;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>)(mem_sbrk(extend_size)) == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <br>        <br>        PUT(HDRP(ptr), PACK(total_size + extend_size, ALLOCATED));<br>        PUT(FTRP(ptr), PACK(total_size + extend_size, ALLOCATED));<br>        PUT(HDRP(NEXT_BLKP(ptr)), PACK(<span class="hljs-number">0</span>, ALLOCATED)); <br>        place(ptr, asize);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;   <span class="hljs-comment">// 直接分配</span><br>        newptr = mm_malloc(asize);<br>        <span class="hljs-keyword">if</span>(newptr == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">memcpy</span>(newptr, ptr, MIN(old_size, size));<br>        mm_free(ptr);<br>        <span class="hljs-keyword">return</span> newptr;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关于DEBUG"><a href="#关于DEBUG" class="headerlink" title="关于DEBUG"></a>关于DEBUG</h2><p>​    代码中为了 DEBUG 定义了大量 debug util 函数和 Error Handler，如果想清晰的看清楚堆块的组织结构，调用它们是很有帮助的。还有 debug 要善用 gdb…</p><h2 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqqcdfltwxj309s088aal.jpg"></p><p>​    在不使用BST和全局数据结构的情况下达到了 97/100 的分数，还不错。</p><h2 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h2><p>​    这个Lab用了我2、3天的时间，是比较难的，需要用心 DEBUG 考验 gdb的使用。Malloc Lab 还是很好玩的，ddl之后我可能会考虑进一步优化，采用BST结构尽量做到接近 100/100</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Malloc</tag>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 动态内存分配机制详解</title>
    <link href="/AcceptedHelper/2021/05/21/Dynamic%20Memory%20Allocation/"/>
    <url>/AcceptedHelper/2021/05/21/Dynamic%20Memory%20Allocation/</url>
    
    <content type="html"><![CDATA[<p>​    动态内存分配是虚拟内存组织中的核心概念，理解它对于帮助整个linux虚拟内存的组织以及堆上内存分配过程。本文会系统介绍动态内存的分配机制以及内存堆块的组织形式，并最后以 CMU CSAPP Malloc Lab 为例来详细讲解。</p><p><strong>Malloc Lab 代码：<a href="https://github.com/ZiYang-xie/Malloc_Lab">ZiYang-xie/Malloc_Lab: CMU Malloc Lab Repo (github.com)</a></strong> </p><p>在开始介绍 malloc 机制前，我们先看一下虚拟内存的组织形式。</p><h1 id="【序】虚拟内存组织形式"><a href="#【序】虚拟内存组织形式" class="headerlink" title="【序】虚拟内存组织形式"></a>【序】虚拟内存组织形式</h1><p>​    linux虚拟内存形式安装堆栈形式组织，栈位于内存高地址，分为内核栈和用户栈，增长方向从高到低。而堆位于内存的低地址，是程序员进行动态内存分配的空间，增长方向由低到高。堆和栈中间是共享映射空间，用于共享库在内存中的映射，这样每次如果有不同代码调用相同的共享库，就不需要再次向内存中复制一份副本，节省了时间和空间。</p><p>​    栈内存的更高地址用于存放一些全局数据结构</p><p>​    堆内存的更低地址按地址从低到高放置着代码段（.text）、已分配数据段（.data）、未分配数据段（.bss）。你可能还听说过 COMMON 段专门储存未初始化全局变量，真正的.bss存储未初始化的静态变量以及初始化为0的全局和静态变量 [1]，组织形式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">SECTIONS &#123; <br>  .text : &#123; *(.text) &#125;<br>  .data : &#123; *(.data) &#125; <br>  .bss :  &#123; *(.bss)  *(COMMON) &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>虚拟内存的大致组成形式如下图所示。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqr0n9olxfj30e80e0gn3.jpg"></p><p>​    可以看到代码段从 <em>0x40000000</em> 处开始，从0到0x40000000的内存地址单纯是未被映射，代码段和0地址之间相隔一段距离在早期是为了防止 nullptr 对代码段的修改<em>（此处仅凭记忆，真实性需要进一步验证</em>）。但如今权限设计更加完善，上述意义已不再成立，这就变成了一种约定俗成的规则。</p><p>在了解了虚拟内存的大致组织模式之后，我们便可以开始讲解 Malloc 的基本机制。</p><h1 id="【一】动态内存分配的实现方式"><a href="#【一】动态内存分配的实现方式" class="headerlink" title="【一】动态内存分配的实现方式"></a>【一】动态内存分配的实现方式</h1><p>​    Linux动态内存分配的实现方式是由 mmap, munmap 以及 brk, sbrk 这四个系统函数联合完成的。</p><h2 id="mmap-与-munmap"><a href="#mmap-与-munmap" class="headerlink" title="mmap 与 munmap"></a>mmap 与 munmap</h2><p><strong>mmap</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">size_t</span> length, <span class="hljs-keyword">int</span> prot, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-function"><span class="hljs-params">           <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> offset)</span></span>;<br></code></pre></td></tr></table></figure><p>mmap 创建一个新的虚拟内存空间和文件设备之间的映射。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqr27vczrhj30jd0a9tah.jpg"></p><p>​    其中 addr 代表分配开始地址，fd是相应文件描述符，len是指文件存储部分映射的长度，offset指的是从文件头开始offset距离开始分配。</p><ul><li>prot包含权限位</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">PROT_EXEC <span class="hljs-comment">// 可执行</span><br>PROT_READ <span class="hljs-comment">// 可读</span><br>PROT_WRITE <span class="hljs-comment">// 可写</span><br>PROT_NONE <span class="hljs-comment">// 不可访问</span><br></code></pre></td></tr></table></figure><ul><li>Flags 表示映射对象类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">MAP_ANON <span class="hljs-comment">// 匿名请求二进制零的</span><br>MAP_PRIVATE <span class="hljs-comment">// 私有的</span><br>MAP_SHARED <span class="hljs-comment">// 共享的</span><br></code></pre></td></tr></table></figure><p><strong>munmap</strong></p><p>取消相应地址内存块的映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">size_t</span> length)</span></span>;<br></code></pre></td></tr></table></figure><p>很好理解取消开始地址为 addr 长度为 length 的内存映射。</p><h2 id="brk-与-sbrk"><a href="#brk-与-sbrk" class="headerlink" title="brk 与 sbrk"></a>brk 与 sbrk</h2><p>​    brk, sbrk 用来移动 program break 指向的指针来扩展堆内存，program break 位于堆顶未初始化数据段末尾之后，通过移动 program break 指针来动态控制堆的大小。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqri33m8lkj30ic0huq62.jpg" style="zoom:50%;" /><p><strong>brk</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">brk</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr)</span></span>;<br></code></pre></td></tr></table></figure><p>​    brk 会在允许的情况下简单的将 program break 设为 addr 地址，来控制堆内存大小。相当于 program break 的绝对移动</p><p><strong>sbrk</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">sbrk</span><span class="hljs-params">(<span class="hljs-keyword">intptr_t</span> increment)</span></span>;<br></code></pre></td></tr></table></figure><p>​    sbrk 会在允许的情况下将 program break 指针加 increment 值，返回扩展前的 program break 地址。当<code>increment</code>为正值时，堆被扩展；为0时，返回当前 program break 的指针；为负值时，堆被收缩。相当于 program break 的相对移动</p><p>​    值得注意的是，当无法扩展时 (申请了大于允许的内存，或碰到了共享内存段)，sbrk会返回 (void *)-1 并且会设置 errorno 为 <strong>ENOMEM</strong>（ENO Memory）</p><h3 id="关于-sbrk-的更多细节"><a href="#关于-sbrk-的更多细节" class="headerlink" title="关于 sbrk 的更多细节"></a>关于 sbrk 的更多细节</h3><p>​    sbrk 实际上是 linux 的一个上古函数，如今大多数内存分配器都倾向于使用 mmap 而不使用 sbrk，是因为 sbrk 是线程不安全的。由于 sbrk 的组织形式是对 program break 的相对移动来进行对扩展，那么对堆块的组织释放方式只能使用 LIFO。假设 sbrk 函数是原子的，在多进程调用时，如果一个进程要释放一个块，且其正好位于结尾program break处，我们选择 increment 为一个负值进行堆收缩（这是正确的）；但在我们还未释放的时候，另一个进程选择分配内存，调用 sbrk。在分配后我们继续进行释放此时我们需要释放的块后增加了一个新块，再调用 sbrk 会导致另一个进程分配的块被释放从而引发错误。</p><p>​    为了解决这个问题，我们也可以自己设计一个进程安全的 sbrk 函数，称为 sbrk_safe</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">sbrk_safe</span><span class="hljs-params">(<span class="hljs-keyword">intptr_t</span> increment, <span class="hljs-keyword">void</span> *expect_top)</span></span>;<br></code></pre></td></tr></table></figure><p>​    其增加了一个参数expect_top，思想很简单，就是在每次调用 sbrk_safe 的时候将选择释放块的内存地址填入 expect_top，函数中验证其是否是在堆顶，如果不是就返回错误。</p><p>​    （另外 sbrk 可能还有其他问题，比如受到 mmap 分配内存和共享内存的阻碍导致内存分配的间断。这里有待进一步研究探讨）</p><h1 id="【二】动态内存分配器的设计"><a href="#【二】动态内存分配器的设计" class="headerlink" title="【二】动态内存分配器的设计"></a>【二】动态内存分配器的设计</h1><p>​        对于堆上的动态内存分配，我们通常将其组织为“块”的模式，一个块就是指一段连续内存地址，而根据其是否被分配数据又被划分为<strong>空闲块</strong>和<strong>分配块</strong>两种。</p><h2 id="序、内存块结构"><a href="#序、内存块结构" class="headerlink" title="序、内存块结构"></a>序、内存块结构</h2><p>​    首先我们需要了解一个简单的技巧，就是如果有空闲块相邻时我们是可以将其进行合并为一个空闲块的，这样一来我们就可以分配更大的内存，并减少内存的碎片程度。注意到由于我们需要对块进行分配和合并，所以我们必须要知道块的<strong>大小信息</strong>和<strong>块的分类</strong>，因而一个内存块中其并不是所有位置都存储着有效信息。以32位系统为例，双字对齐（8 bytes）我们设计一个块的头部一个字大小（4 bytes）放置着块的大小信息和分配信息，由于是双字对齐的，所以块大小的后3位永远是0（1000）, 因此我们用前29位放大小信息，后3位放置分配信息（实际上是最后一位）001表示已分配、000表示空闲。中间放置有效载荷、即数据段，尾部可有一个填充。</p><p>​    最后注意到我们需要对块进行<strong>合并</strong>（在后文中我们会详细讨论合并策略），所以在尾部也放置一个大小和分配标记有利于下一块相邻块快速找到上一块的分配状态和大小来达成向前合并的操作，所以我们在脚部也增加一个字大小（4 bytes）和头部相同的大小分配标记。这个特征称为<strong>边界标记</strong></p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqrjzzz4iaj30go0dwjyj.jpg" style="zoom:50%;" /><h2 id="一、内存碎片"><a href="#一、内存碎片" class="headerlink" title="一、内存碎片"></a>一、内存碎片</h2><p>​        关于内存分配，首先我们要有一个直观，在组织过程中我们确实可以简单的每次分配内存都创建一个所需大小的块，但经过频繁的分配释放，很快堆上的整块内存就会被划分为十分杂乱的小块。这种情况称之为内存碎片化，内存碎片化是一个十分严重的问题，其可能导致内存极大的浪费，因此要理解动态内存分配器的设计之前首先我们需要理解内存碎片的概念，来帮助我们更好的设计一个性能更加优良的分配器。</p><p>​    关于内存碎片根据其表现形式可以分为两类，内部碎片和外部碎片。</p><h3 id="内部内存碎片"><a href="#内部内存碎片" class="headerlink" title="内部内存碎片"></a>内部内存碎片</h3><p>​    内部内存碎片可以有一个直观的理解（虽然可能有点夸张），就是如果你仅仅需要 1kb 的内存用于存放数据，但是你申请了 2GB 大小的内存空间用来存这 1kb 的数据，那么里面大部分的内存全部都被浪费掉了，这时候如果你再要申请内存，空闲的内存可能就不够了。这就是内部碎片。</p><p>​    这时候有人可能会问，那么我们之间分配需要分配的内存大小就好了啊？那为什么内部碎片还会产生呢？确实说的很对，。但有时候由于内存对齐需要以及分配器策略等影响我们并不能够直接分配正好就是需求大小的内存块，其产生机制我将会在下文中进一步深入讲解</p><h3 id="外部内存碎片"><a href="#外部内存碎片" class="headerlink" title="外部内存碎片"></a>外部内存碎片</h3><p>​    外部内存碎片的产生主要源于频繁的大小不一的内存分配和释放过程。经过一系列的分配释放，最后整块的内存会被切分成空闲块分配块相互交杂的情况，如下图所示，这时候如果我们想要再分配一个 1000 kb 的数据块，可能所有的空闲块加起来是大于 1000 kb 的但是由于没有一个空闲块是大于 1000 kb 的就会导致内存分配的失败。同时由于内存映射已经建立，重整虚拟内存会导致整个程序到虚拟内存，虚拟内存到物理内存的映射表都需要更改，这种花费是我们无法承受的，所以我们需要设计更好的分配方式尽量避免这种碎片化情况的产生。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqrji3uyl1g30b404l3yd.gif"></p><h2 id="二、空闲块组织模式"><a href="#二、空闲块组织模式" class="headerlink" title="二、空闲块组织模式"></a>二、空闲块组织模式</h2><p>​    关于动态内存分配器的设计其有不同的设计策略，而一种最为常见的区分方式是通过空闲块的组织模式来区分不同的分配器，这里简单介绍两种来自 CSAPP 的空闲块组织模式。</p><h3 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h3><p>​    关于隐式空闲链表，它组织内存空闲块的形式非常简单，可以说是根本没有任何组织，我们可以通过遍历所有堆块（因为我们知道每一个堆块的大小）并验证其是否空闲来找到所有空闲块。所以将这种空闲块组织模式成为隐式空闲链表组织模式。</p><ul><li><p><strong>优点：</strong>简单、无需其他数据结构、节省空间</p></li><li><p><strong>缺点：</strong>时间复杂度高，每次寻找空闲块都需要 O(n) 时间复杂度遍历所有堆块</p></li></ul><h3 id="显示空闲链表"><a href="#显示空闲链表" class="headerlink" title="显示空闲链表"></a>显示空闲链表</h3><p>​    关于显示空闲链表，其是通过在空闲块中间添加两个指针分别指向前趋空闲块和后继空闲块，将空闲块串联成一个链表的模式。这时候我们在全局需要存储一个入口指针指向第一个空闲块，因为其显示的将所有空闲块进行串联，所以我们称这种组织模式为显示空闲链表</p><ul><li><strong>优势：</strong>速度快效率高，只需要 O(m) 遍历所有空闲块</li><li><strong>缺点：</strong>组织复杂，且最小块大小较大（空闲块需要多两个指针的大小）</li></ul><p>在实际的动态内存分配器中我们常常使用显示空闲链表的模式，因为相比于它的效率提升，其多出的空间花费是微不足道的。</p><h2 id="三、空闲块适配模式"><a href="#三、空闲块适配模式" class="headerlink" title="三、空闲块适配模式"></a>三、空闲块适配模式</h2><p>​    说完了空闲块组织模式，我们来谈谈常见的空闲块适配模式，为什么要适配空闲块？当然是因为请求分配一个内存大小的时候要找到一个相应合适的内存块，空闲块适配这个概念和前面讲到的内存碎片有着很大的联系，如果我们选的太大那么就会导致内部碎片的产生（如果没有其他分割策略），如果外部碎片太多，那么我们可能根本找不到合适的空闲块。</p><p>接下来我主要介绍三类空闲块组织模式，首次适配（First Fit）、再次适配（Next Fit)和最佳适配（Best Fit）</p><ul><li><strong>首次适配：</strong> 遍历空闲块找到的第一个合适的空闲块就用来分配 （速度快，内存不一定节省）</li><li><strong>再次适配：</strong>不从头找起，从上一次分配的空闲块继续往下找，找到的第一个适合的空闲块就用来分配 （默认了分配内存的大小基本一致，需要依赖于程序的内存分配特点和空闲块大小组织方式，效率不固定）</li><li><strong>最佳适配：</strong>遍历所有空闲块，找到一个在能够符合分配条件下最小的空闲块来最大化减少内部碎片的产生（内存利用率最佳，但效率较低）</li></ul><h2 id="四、空闲块顺序安排"><a href="#四、空闲块顺序安排" class="headerlink" title="四、空闲块顺序安排"></a>四、空闲块顺序安排</h2><p>​    空闲块顺序安排这个概念是归属于显示空闲链表组织模式下的，隐式空闲链表就完全不会有这个概念（因为根本没有组织xs）</p><p>​    下面来讲讲空闲块的顺序安排，其主要有两种组织形式，LIFO 顺序和地址顺序</p><ul><li><strong>LIFO 顺序：</strong>把释放块插入到空闲链表的开始处，结合首次适配策略，我们便每次会分配适合分配大小的最近释放的空闲块。</li></ul><p>由于我们每次都在空闲块链表开头插入新释放的空闲块，其释放能够在常数时间内 O(1) 完成。</p><ul><li><strong>地址顺序：</strong> 我们也可以简单地按地址顺序安排空闲块链表，即让空闲块链表中空闲块地址从低到高排序，这样符合堆的地址增长方式。</li></ul><p>通常情况下地址顺序结合首次适配的方式比LIFO结合首次适配拥有<strong>更高的内存利用率</strong>，这是从实验中得出的</p><h2 id="五、空闲块的存储技术"><a href="#五、空闲块的存储技术" class="headerlink" title="五、空闲块的存储技术"></a>五、空闲块的存储技术</h2><h3 id="分离适配与分段空闲链表（-Segregated-Free-List-）"><a href="#分离适配与分段空闲链表（-Segregated-Free-List-）" class="headerlink" title="分离适配与分段空闲链表（ Segregated Free List ）"></a>分离适配与分段空闲链表（ Segregated Free List ）</h3><p>​    在实际应用中，我们可以对空闲块的组织模式进行一定的大小分类，通过分类的方式，我们可以进一步减少空闲块的索引时间。</p><p><strong>（这里的思想是运用的分层级的思想，这一思想在计算机科学中无处不在，例如数据库中的多级索引，多级页表的组织等，其实际上就是用分组的形式形成层级结构，通过使用更多的空间来换取索引的时间，是典型的空间换时间模式）</strong></p><p>我们将根据空闲块大小的分类得出的不同类称为大小类，通常在一个最简单的应用中，我们可以使用二的幂次来对其进行表示。在实现上，我们可以将其组织为一个叫做分段空闲链表（Segregated Free List）的组织形式（如下图所示）。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqrl8pm35nj30wc0u0aj5.jpg" style="zoom:40%;" /><p>​    例如我们将空闲块按二的幂次分为 MAX_ORDER 个大小类，每个 index = i 维护一个链表，连接着一类大小位于 $ 2^{i - 1}$ ~ $2^i$ 的空闲块，这样的组织形式，我们就可以先根据分配需求索引大类的大小，定位之后再进入链表根据适配规则适配空闲块。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <em>Computer Systems: A Programmer’s Perspective</em>, 3/E (CS:APP3e). Randal E. Bryant and David R. O’Hallaron, Carnegie Mellon University.  Page 469</p><p>[2] <a href="https://lifecs.likai.org/2010/02/sbrk-is-not-thread-safe.html">Life of a Computer Scientist: sbrk() is not thread safe (likai.org)</a></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Malloc</tag>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算理论基础思维导图</title>
    <link href="/AcceptedHelper/2021/04/07/mind-map-for-intro-to-comp-thry/"/>
    <url>/AcceptedHelper/2021/04/07/mind-map-for-intro-to-comp-thry/</url>
    
    <content type="html"><![CDATA[<p>这是计算理论基础前五周的思维导图。(pdf请使用chrome浏览器)</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/FDU19CS/AcceptedHelper@hexo/source/_posts/mind-map-for-intro-to-comp-thry/mind-map-for-intro-to-comp-thry.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>计算理论基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>孙若诗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0324ICSHW问题汇总</title>
    <link href="/AcceptedHelper/2021/03/30/0324ICSHW%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/AcceptedHelper/2021/03/30/0324ICSHW%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="1-关于作业7-13B，为什么两个文件objdump的结果一样，但是通过diff比较二进制文件得出的结果不同？"><a href="#1-关于作业7-13B，为什么两个文件objdump的结果一样，但是通过diff比较二进制文件得出的结果不同？" class="headerlink" title="1.关于作业7.13B，为什么两个文件objdump的结果一样，但是通过diff比较二进制文件得出的结果不同？"></a>1.关于作业7.13B，为什么两个文件objdump的结果一样，但是通过diff比较二进制文件得出的结果不同？</h2><p>-g主要是加了debug section，它包含了符号表，如果没有-g的内容，用gdb进行debug时，它并不知道每一行是什么内容，也不能print i变量，因为local variable会丢失，它只知道有个内存地址，不知道变量是i，但是如果使用-g选项，就可以添加这些信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210330001135.jpg" alt="image-20210329234104958"></p><p><code>objdump</code>相当于只读了.text内容，其他地方都没有读。</p><h2 id="2-关于补充作业题中的链接时出现segmentation-fault"><a href="#2-关于补充作业题中的链接时出现segmentation-fault" class="headerlink" title="2.关于补充作业题中的链接时出现segmentation fault"></a>2.关于补充作业题中的链接时出现<code>segmentation fault</code></h2><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210330001208.jpg" alt="image-20210329234104958"></p><h3 id="出错原因（此处为tyf的解释，可能复述的有不到位的地方）："><a href="#出错原因（此处为tyf的解释，可能复述的有不到位的地方）：" class="headerlink" title="出错原因（此处为tyf的解释，可能复述的有不到位的地方）："></a>出错原因（此处为tyf的解释，可能复述的有不到位的地方）：</h3><p>-e main是进入到main，但是此前没有执行虚拟内存映射，导致地址出错，出现segmentation fault，进入_start可以，因为 _start中会调用libc_start，（因为源码不公开，所以并不知道这其中做了什么，但是猜想它进行了虚拟内存映射），如果删去-e _start，即为默认值，也是可以正常运行的。</p><p>libc_start是定义在crt1.o中的，只要把它放在main之前，就可以进入。</p><h3 id="用main也可以正常运行的方法："><a href="#用main也可以正常运行的方法：" class="headerlink" title="用main也可以正常运行的方法："></a>用main也可以正常运行的方法：</h3><p>不要链接crt1.o，将entry point设为main，这样会进入main，main会return，return之后立刻会有segmentation fault，此时将return 0 改为 exit 0就可以了，因为exit调用的是system call，会执行一个中断。</p><h2 id="3-程序加载的过程"><a href="#3-程序加载的过程" class="headerlink" title="3.程序加载的过程"></a>3.程序加载的过程</h2><p>在进入main函数之前，首先会有一个程序准备全局变量等，最后来调用main函数，把他的参数传入，执行main函数，会return 0 给一个结束的程序，它会将一些“善后”的工作做完。如果入口是main函数，则上述准备操作均没有做，就return到一个系统不知道在哪儿的位置，所以会segmentation fault，但如果用exit就没有问题。</p><h2 id="4-标准的链接格式"><a href="#4-标准的链接格式" class="headerlink" title="4.标准的链接格式"></a>4.标准的链接格式</h2><p><code>ld -o OUTPUT crt1.o crti.o crtbegin.o [-L paths] [user objects] [gcc libs] [C libs] [gcc libs] crtend.o crtn.o</code></p><p>感谢谭一凡的耐心解答！</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>曹丝露</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0324ICSHW答案</title>
    <link href="/AcceptedHelper/2021/03/29/0324ICSHW%E7%AD%94%E6%A1%88/"/>
    <url>/AcceptedHelper/2021/03/29/0324ICSHW%E7%AD%94%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="ICS作业-链接2参考"><a href="#ICS作业-链接2参考" class="headerlink" title="ICS作业-链接2参考"></a>ICS作业-链接2参考</h1><h2 id="7-10"><a href="#7-10" class="headerlink" title="7.10"></a>7.10</h2><p>A.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ p.o libx.a<br></code></pre></td></tr></table></figure><p>B.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ p.o libx.a liby.a libx.a<br></code></pre></td></tr></table></figure><p>C.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ p.o libx.a liby.a libx.a libz.a<br></code></pre></td></tr></table></figure><h2 id="7-11"><a href="#7-11" class="headerlink" title="7.11"></a>7.11</h2><p>因为有.BSS区域，该区域在可执行文件中并不分配空间；而在加载入内存时进行分配，因此要预留出0x230字节。</p><h2 id="7-12"><a href="#7-12" class="headerlink" title="7.12"></a>7.12</h2><p>A.</p><p>$*refptr = ADDR(r.symbol)+r.addend-refaddr$</p><p>$=0x4004f8-4-(0x4004e0+0xa)=0xa$</p><p>B.</p><p>$*refptr = ADDR(r.symbol)+r.addend-refaddr$</p><p>$=0x400500-4-(0x4004d0+0xa)=0x22$</p><h2 id="7-13"><a href="#7-13" class="headerlink" title="7.13"></a>7.13</h2><h3 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h3><h4 id="寻找libc-a和libm-a"><a href="#寻找libc-a和libm-a" class="headerlink" title="寻找libc.a和libm.a"></a>寻找libc.a和libm.a</h4><p>使用如下的命令，找到库的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc --print-file-name=libc.a<br>gcc --print-file-name=libm.a<br></code></pre></td></tr></table></figure><p>得出这两个文件均在<code>/usr/lib/aarch64-linux-gnu</code>目录下</p><h4 id="查找有多少个Object-Files"><a href="#查找有多少个Object-Files" class="headerlink" title="查找有多少个Object Files"></a>查找有多少个Object Files</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/lib/aarch64-linux-gnu<br>ar -t libc.a | wc -l<br>ar -t libm.a | wc -l<br></code></pre></td></tr></table></figure><p>得出结论，在libc.a下有1616个Object file，在libm.a下有576个Object file</p><h3 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h3><p>他们产生的二进制文件是不同的，-g会携带更多的debug和符号信息。</p><p>使用如下命令即可看出他们之间的差别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">xxd main&gt;main.binary<br>xxd maing&gt;maing.binary<br>colordiff -y main.binary maing.binary<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210329221556.png"></p><p>事实上，添加的部分为debug section，可以用readelf读出来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">readelf -wi main # No output<br>readelf -wi maing<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">i<br>=<span class="hljs-built_in">info</span><br></code></pre></td></tr></table></figure><p>Displays the contents of the ‘.debug_info’ section. Note: the output from this option can also be restricted by the use of the –dwarf-depth and –dwarf-start options.</p></blockquote><h4 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h4><p>使用ldd分析任意一个可执行文件，可看出在我的电脑上(Ubuntu20.04 aarch64)，动态链接库如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">ldd /usr/bin/ls</span>                <br>linux-vdso.so.1 (0x0000ffff81faf000)<br>libselinux.so.1 =&gt; /lib/aarch64-linux-gnu/libselinux.so.1 (0x0000ffff81f05000)<br>libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6 (0x0000ffff81d92000)<br>/lib/ld-linux-aarch64.so.1 (0x0000ffff81f7f000)<br>libpcre2-8.so.0 =&gt; /lib/aarch64-linux-gnu/libpcre2-8.so.0 (0x0000ffff81d04000)<br>libdl.so.2 =&gt; /lib/aarch64-linux-gnu/libdl.so.2 (0x0000ffff81cf0000)<br>libpthread.so.0 =&gt; /lib/aarch64-linux-gnu/libpthread.so.0 (0x0000ffff81cc0000)<br></code></pre></td></tr></table></figure><ul><li>linux-vdso.so.1</li><li>libselinux.so.1 =&gt; /lib/aarch64-linux-gnu/libselinux.so.1 </li><li>libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6</li><li>/lib/ld-linux-aarch64.so.1</li><li>libpcre2-8.so.0 =&gt; /lib/aarch64-linux-gnu/libpcre2-8.so.0 </li><li>libdl.so.2 =&gt; /lib/aarch64-linux-gnu/libdl.so.2</li><li>libpthread.so.0 =&gt; /lib/aarch64-linux-gnu/libpthread.so.0 </li></ul><h2 id="补充习题"><a href="#补充习题" class="headerlink" title="补充习题"></a>补充习题</h2><h3 id="1-补充源码"><a href="#1-补充源码" class="headerlink" title="1.补充源码"></a>1.补充源码</h3><p>源码和Makefile见附带的文件</p><p>编译成功后的截图如下</p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210329195524.png" style="zoom:50%;" /><h3 id="2-手动编译"><a href="#2-手动编译" class="headerlink" title="2. 手动编译"></a>2. 手动编译</h3><p>使用了两种方法，第一种直接使用<code>gcc -v</code>的编译参数，第二种使用更简单的手动链接</p><h4 id="gcc-v式的"><a href="#gcc-v式的" class="headerlink" title="gcc -v式的"></a>gcc -v式的</h4><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210329200556.png"></p><p>能正常编译并运行</p><h4 id="手动链接式的"><a href="#手动链接式的" class="headerlink" title="手动链接式的"></a>手动链接式的</h4><p>在我们进行链接之前，需要先解释各个系统库有什么用，才能进行选择性的简化链接</p><ul><li>libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3496d10000) - C标准库动态共享对象</li><li>/lib64/ld-linux-x86-64.so.2 (0x00007f3497303000) - 动态链接器/加载器</li><li>crt1.o：包含入口函数_start(该函数执行了上一节所描述的整个程序执行过程)，以及未定义的符号__libc_start_main、main</li><li>crti.o: 提供.init节和.fini节的序言(function prologs)</li><li>crtn.o: 提供.init节和.fini节的尾言(function epilogs)</li><li>crtbegin.o: 提供构造函数的首地址(但在本题中，因为没有构造函数，因此不需要链接)</li><li>crtend.o: 提供析构函数的首地址(同上)</li></ul><p>具体到本题中，使用如下命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">crt1.o=/usr/lib/x86_64-linux-gnu/crt1.o<br>crti.o=/usr/lib/x86_64-linux-gnu/crti.o<br>crtn.o=/usr/lib/x86_64-linux-gnu/crtn.o<br>crtbeginS.o=/usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o<br>crtendS.o=/usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o<br>ld.so=/lib64/ld-linux-x86-64.so.2<br>libc.so=/usr/lib/x86_64-linux-gnu/libc.so<br>ld -dynamic-linker $(ld.so) -o main $(crt1.o) $(crti.o) main.o BubbleSort.o add.o printResult.o $(libc.so) $(crtn.o)<br></code></pre></td></tr></table></figure><h3 id="3-OBJDUMP进行反汇编"><a href="#3-OBJDUMP进行反汇编" class="headerlink" title="3.OBJDUMP进行反汇编"></a>3.OBJDUMP进行反汇编</h3><p>使用<code>objdump -S main.o &gt; main.S</code>将反编译形成的汇编码写入<code>main.S</code>文件中</p><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210329201203.png"></p><h3 id="4-生成调试信息后，使用GDB进行调试"><a href="#4-生成调试信息后，使用GDB进行调试" class="headerlink" title="4. 生成调试信息后，使用GDB进行调试"></a>4. 生成调试信息后，使用GDB进行调试</h3><p>使用了list, break, start, run, continue, info等多种命令进行了调试，在此处限于截图篇幅，仅截取部分</p><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210329201939.png"></p><h3 id="5-相关问题"><a href="#5-相关问题" class="headerlink" title="5. 相关问题"></a>5. 相关问题</h3><ol><li><p>分析同一个源程序在不同机器上生成的可执行目标代码是否相同</p><ol><li>ISA: 在arm处理器和x86处理器上，显然有不同的可执行目标文件代码</li><li>OS：在windows和linux上有不同的寄存器分配规则，在windows64上的函数调用采用<code>RCX</code>,<code>RDX</code>,<code>R8</code>,<code>R9</code>的寄存器调用顺序，在Linux64上采用的函数调用寄存器为<code>RDI</code>,<code>RSI</code>,<code>RDX</code>,<code>RCX</code>,<code>R8</code>,<code>R9</code></li><li>编译器：不同编译器会采用不同的优化策略，生成的可执行目标代码可能不同</li></ol></li><li><p>你能在可执行目标文件中找出函数printf ()对应的机器代码段吗？能的话，请标示出来。</p><p>不能，printf函数所对应的机器代码段在libc.so中，是在运行时调用的，因此无法找到。</p><p>事实上，的确有printf@plt（Procedure linkage table)这一函数，但这仅仅是一个找到真实printf代码的stub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000000710 &lt;printf@plt&gt;:<br> 710:ff 25 9a 18 20 00    jmpq   *0x20189a(%rip)        # 201fb0 &lt;printf@GLIBC_2.2.5&gt;<br> 716:68 03 00 00 00       pushq  $0x3<br> 71b:e9 b0 ff ff ff       jmpq   6d0 &lt;.plt&gt;<br></code></pre></td></tr></table></figure></li><li><p>为什么源程序文件的内容和可执行目标文件的内容完全不同？</p><p>源程序文件的内容为文本文件，是编程语言代码；可执行目标文件为CPU可以运行的二进制代码，自然不同。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>王少文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code for ICS HW4</title>
    <link href="/AcceptedHelper/2021/03/28/Code-for-ICS-HW4/"/>
    <url>/AcceptedHelper/2021/03/28/Code-for-ICS-HW4/</url>
    
    <content type="html"><![CDATA[<p>本文提供了ICS HW4补充作业中需要的初始代码。</p><h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;add.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;BubbleSort.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;printResult.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> bool char</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LENGTH 10</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a[LENGTH],i;<br>    <span class="hljs-keyword">int</span> b[LENGTH];<br>    <span class="hljs-keyword">int</span> randValue = <span class="hljs-number">0</span>;<br>    srand(time(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;LENGTH;i++)&#123;<br>        randValue = <span class="hljs-number">1</span> + (<span class="hljs-keyword">int</span>)rand()%LENGTH;<br>        a[i] = randValue;<br>        b[i] = a[i];<br>    &#125;<br>    printResult(a,LENGTH,<span class="hljs-string">&quot;\nrandom array: &quot;</span>);<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(flag)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n1.Bubble Sort\n2.sum\n3.print result\n4.exit&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nchoose a number:&quot;</span>);<br>        <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;number);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">switch</span>(number)<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                BubbleSort(a,LENGTH);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                sum = add(a,LENGTH);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nresult of sum: %d\n&quot;</span>,sum);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                printResult(b,LENGTH,<span class="hljs-string">&quot;\noriginal array:\t&quot;</span>);<br>                printResult(a,LENGTH,<span class="hljs-string">&quot;\nsorted array:\t&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nplease choose a correct number and continue!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nDone!\n\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="add-c"><a href="#add-c" class="headerlink" title="add.c"></a>add.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;add.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[],<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">//Write your code here</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="add-h"><a href="#add-h" class="headerlink" title="add.h"></a>add.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[],<span class="hljs-keyword">int</span> n)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="BubbleSort-c"><a href="#BubbleSort-c" class="headerlink" title="BubbleSort.c"></a>BubbleSort.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;BubbleSort.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[], <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">//Write your code here</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BubbleSort-h"><a href="#BubbleSort-h" class="headerlink" title="BubbleSort.h"></a>BubbleSort.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[], <span class="hljs-keyword">int</span> n)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="printResult-c"><a href="#printResult-c" class="headerlink" title="printResult.c"></a>printResult.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;printResult.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[],<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">char</span>* str)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str);<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d&quot;</span>,s[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="printResult-h"><a href="#printResult-h" class="headerlink" title="printResult.h"></a>printResult.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[],<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">char</span>* str)</span></span>;<br></code></pre></td></tr></table></figure><p><del>愿天堂没有用word图片发布的作业代码。</del></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>祁昊</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学作业答案</title>
    <link href="/AcceptedHelper/2021/03/25/answer_of_discrete_math/"/>
    <url>/AcceptedHelper/2021/03/25/answer_of_discrete_math/</url>
    
    <content type="html"><![CDATA[<p>此处的答案为2020年春网课学期助教所发布的答案，可能与今年布置的作业有所出入，请同学们务必<strong>不要外传</strong>。第12章和13章的答案如下(需要用电脑版的Chrome浏览器访问):</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/FDU19CS/AcceptedHelper@hexo/source/_posts/answer_of_discrete_math/discrete_math_12_13.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>离散数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>王少文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELF头简介</title>
    <link href="/AcceptedHelper/2021/03/23/Readelf/"/>
    <url>/AcceptedHelper/2021/03/23/Readelf/</url>
    
    <content type="html"><![CDATA[<p>​    在linux中我们常用readelf指令来读取ELF (Executable and Linkable Format) 文件中的信息，本文主要介绍ELF头的基本信息</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Elf-layout--en.svg/260px-Elf-layout--en.svg.png" alt="ELF文件结构"></p><h3 id="ELF头"><a href="#ELF头" class="headerlink" title="ELF头"></a>ELF头</h3><p>elf头是位于elf文件的头部，里面存储着一些机器和该ELF文件的基本信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>   e_ident[EI_NIDENT];<br>        Elf64_Half      e_type;<br>        Elf64_Half      e_machine;<br>        Elf64_Word      e_version;<br>        Elf64_Addr      e_entry;<br>        Elf64_Off       e_phoff;<br>        Elf64_Off       e_shoff;<br>        Elf64_Word      e_flags;<br>        Elf64_Half      e_ehsize;<br>        Elf64_Half      e_phentsize;<br>        Elf64_Half      e_phnum;<br>        Elf64_Half      e_shentsize;<br>        Elf64_Half      e_shnum;<br>        Elf64_Half      e_shstrndx;<br>&#125; Elf64_Ehdr;<br></code></pre></td></tr></table></figure><p>我们分别介绍其含义</p><hr><h4 id="1、e-ident"><a href="#1、e-ident" class="headerlink" title="1、e_ident"></a>1、e_ident</h4><ul><li><strong>长度：16字节</strong></li><li><strong>简介：包含着文件和操作系统信息</strong></li><li><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosklimwgzj30m00fmq55.jpg" style="zoom:50%;" /></li></ul><h5 id="Magic-Num-e-ident-0-3"><a href="#Magic-Num-e-ident-0-3" class="headerlink" title="Magic Num - e_ident[0:3]"></a>Magic Num - e_ident[0:3]</h5><p>​    前四个字节包含着一个 magic number，表示该文件是一个 ELF 文件</p><h5 id="EI-Class-e-ident-4"><a href="#EI-Class-e-ident-4" class="headerlink" title="EI_Class - e_ident[4]"></a>EI_Class - e_ident[4]</h5><p>​    指示文件类型，是ELF32还是ELF64位</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskl3oqhyj30dq05qq3h.jpg" style="zoom:50%;" /><h5 id="EI-DATA-e-ident-5"><a href="#EI-DATA-e-ident-5" class="headerlink" title="EI_DATA - e_ident[5]"></a>EI_DATA - e_ident[5]</h5><p>​    指示文件的编码方式，是大端法还是小端法</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskkp5pdjj30fy05ggm5.jpg" style="zoom:50%;" /><p>​    <strong>ELFDATA2LSB - 小端法</strong></p><p>​    <strong>ELFDATA2MSB - 大端法</strong></p><h5 id="EI-Version-e-ident-6"><a href="#EI-Version-e-ident-6" class="headerlink" title="EI_Version - e_ident[6]"></a>EI_Version - e_ident[6]</h5><p>​    标识ELF Version, 该值等于EV_CURRENT，目前为1</p><h5 id="EI-OSABI-e-ident-7"><a href="#EI-OSABI-e-ident-7" class="headerlink" title="EI_OSABI - e_ident[7]"></a>EI_OSABI - e_ident[7]</h5><p>​    表示着该文件运行的操作系统</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskk8xx2wj30oi0jmadb.jpg" alt="操作系统类型对应" style="zoom:50%;" /><h5 id="EI-ABIVERSION-e-ident-8"><a href="#EI-ABIVERSION-e-ident-8" class="headerlink" title="EI_ABIVERSION - e_ident[8]"></a>EI_ABIVERSION - e_ident[8]</h5><p>​    标志着 ABI （应用二进制接口）的版本，ABI相当于硬件层级的API（见下图）</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosknnji29j31400u0qd8.jpg" alt="ABI解释" style="zoom:40%;" /><h5 id="EI-PAD-e-ident-8-15"><a href="#EI-PAD-e-ident-8-15" class="headerlink" title="EI_PAD - e_ident[8:15]"></a>EI_PAD - e_ident[8:15]</h5><p>​    填充位，用零填充用以对齐，可以预留给未来使用</p><h4 id="2、e-type"><a href="#2、e-type" class="headerlink" title="2、e_type"></a>2、e_type</h4><ul><li><p><strong>长度：2字节</strong></p></li><li><p><strong>简介：</strong>指示文件类型</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosm36oov3j30he0da40a.jpg" style="zoom:50%;" /></li></ul><p>​    </p><h4 id="3、e-machine"><a href="#3、e-machine" class="headerlink" title="3、e_machine"></a>3、e_machine</h4><ul><li><p><strong>长度：2字节</strong></p></li><li><p><strong>简介：</strong>指示机器类型</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosm42l3lxj30u00x2wkc.jpg" alt="部分机器类型" style="zoom:50%;" /></li></ul><h4 id="4、e-version"><a href="#4、e-version" class="headerlink" title="4、e_version"></a>4、e_version</h4><p>​    <strong>长度：4字节</strong></p><p>​    <strong>简介：指示文件版本</strong></p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosm8c0knij30dk04gglx.jpg" style="zoom:50%;" /><h4 id="5、e-entry"><a href="#5、e-entry" class="headerlink" title="5、e_entry"></a>5、e_entry</h4><p>​    <strong>长度：4字节（32位）/8字节（64位）</strong></p><p>​    <strong>简介：进程开始的虚拟地址</strong></p><h4 id="6、e-phoff"><a href="#6、e-phoff" class="headerlink" title="6、e_phoff"></a>6、e_phoff</h4><p>​    <strong>长度：4字节（32位）/8字节（64位）</strong></p><p>​    <strong>简介：指向程序头部表的开始</strong>    </p><h4 id="7、e-shoff"><a href="#7、e-shoff" class="headerlink" title="7、e_shoff"></a>7、e_shoff</h4><p>​    <strong>长度：4字节（32位）/8字节（64位）</strong></p><p>​    <strong>简介：指向节头部表的开始</strong>    </p><h4 id="8、e-flags"><a href="#8、e-flags" class="headerlink" title="8、e_flags"></a>8、e_flags</h4><p>​    <strong>长度：4字节</strong></p><p>​    <strong>简介：意义取决于目标架构</strong>    </p><h4 id="9、e-ehsize"><a href="#9、e-ehsize" class="headerlink" title="9、e_ehsize"></a>9、e_ehsize</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：该文件头部的大小</strong></p><h4 id="10、e-phentsize"><a href="#10、e-phentsize" class="headerlink" title="10、e_phentsize"></a>10、e_phentsize</h4><p>​    <strong>长度：2字节</strong>    </p><p><strong>简介：程序头部的大小</strong>    </p><h4 id="11、e-phnum"><a href="#11、e-phnum" class="headerlink" title="11、e_phnum"></a>11、e_phnum</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：程序头部的条目数</strong></p><h4 id="12、e-shentsize"><a href="#12、e-shentsize" class="headerlink" title="12、e_shentsize"></a>12、e_shentsize</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：节头部表的大小</strong></p><h4 id="13、e-shnum"><a href="#13、e-shnum" class="headerlink" title="13、e_shnum"></a>13、e_shnum</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：节头部表的条目数</strong></p><h4 id="14、e-shstrndx"><a href="#14、e-shstrndx" class="headerlink" title="14、e_shstrndx"></a>14、e_shstrndx</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：节头部表的条目和其位置 (idx) 的对应关系</strong></p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">https://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a></p><p>[2] <a href="https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html">https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>谢子飏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/AcceptedHelper/2021/03/18/hello_world/"/>
    <url>/AcceptedHelper/2021/03/18/hello_world/</url>
    
    <content type="html"><![CDATA[<h2 id="第一篇用以测试"><a href="#第一篇用以测试" class="headerlink" title="第一篇用以测试"></a>第一篇用以测试</h2><h3 id="一、-下面是一段C-代码"><a href="#一、-下面是一段C-代码" class="headerlink" title="一、 下面是一段C++代码"></a>一、 下面是一段C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Hello World!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、-下面是一段表格"><a href="#二、-下面是一段表格" class="headerlink" title="二、 下面是一段表格"></a>二、 下面是一段表格</h3><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">x</td></tr></tbody></table><h3 id="三、-下面是一段-Latex"><a href="#三、-下面是一段-Latex" class="headerlink" title="三、 下面是一段 Latex"></a>三、 下面是一段 Latex</h3><p>$$E= mc^2$$</p><h3 id="四、下面是一张图片"><a href="#四、下面是一张图片" class="headerlink" title="四、下面是一张图片"></a>四、下面是一张图片</h3><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRP-ciAYVH8UlH3ZaZC3NkN3ow9CrG36O5crg&usqp=CAU"></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>None</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
