<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>实习分享(第七弹)</title>
    <link href="/AcceptedHelper/2022/04/19/%E5%AE%9E%E4%B9%A0%E5%88%86%E4%BA%AB(%E7%AC%AC%E4%B8%83%E5%BC%B9)/"/>
    <url>/AcceptedHelper/2022/04/19/%E5%AE%9E%E4%B9%A0%E5%88%86%E4%BA%AB(%E7%AC%AC%E4%B8%83%E5%BC%B9)/</url>
    
    <content type="html"><![CDATA[<h1 id="实习分享-第七弹"><a href="#实习分享-第七弹" class="headerlink" title="实习分享(第七弹)"></a>实习分享(第七弹)</h1><h2 id="子豪-的面试分享"><a href="#子豪-的面试分享" class="headerlink" title="子豪 的面试分享"></a>子豪 的面试分享</h2><h3 id="实习准备"><a href="#实习准备" class="headerlink" title="实习准备"></a>实习准备</h3><p>投递时间大概是在二月底三月初的时间，之前项目经历较少，也没学过java的各种组件；各个网站的面经里似乎都是在分享java八股文，所以准备的重心还是背八股文。</p><h3 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h3><h4 id="蚂蚁金服-支付宝事业线"><a href="#蚂蚁金服-支付宝事业线" class="headerlink" title="蚂蚁金服-支付宝事业线"></a>蚂蚁金服-支付宝事业线</h4><ul><li><p>一面（电话面试）<br>整个面试的重点感觉和我之前在面经里看到的完全不同，就抓着我简历上的一个项目问到底，但是期间也会穿插着问一些项目用到的数据结构的知识，包括Java底层的一些数据结构的组成等等。<br>因为项目写的都是一些小型项目，没涉及到大量的多线程并发操作，却在这一块被追着问了好多知识点，大概是问我如果要做成一个上线的项目该怎么改进等等。<br>聊完了项目之后就是问个人的一些东西，包括曾经是否有质疑过老师的经历、个人思维是偏理性还是感性、平时看的书有哪些、学生工作里的一些组织经历、高考成绩和排名是多少（然后面试官还和我凡尔赛了下他当年是竞赛保送复旦的）<br>整个面试持续了大概一小时，我猜是因为阿里内推还是需要做笔试，所以最后也没有安排做算法题。可能因为面试官也是复旦的学长吧，最后的二十分钟都是他在争对我的情况提出他对我的建议。</p></li><li><p>二面（电话面试）<br>二面是需要做完阿里的笔试题才和我约的时间。笔试题包括智商（50题左右）、情商测试（100题左右）+cs知识点（6道单选+6道多选+3道算法编程题）<br>二面和我预想的一样还是抓着我的项目来问，八股文几乎没有问到。因为项目做的太简单导致这个面试官几乎半小时就问完了。<br>这个面试官倒也挺直率，刚开始先是问我是不是00后，然后跟我抒怀了一大通年轻多好多好他都已经要四十了等等，然后对我被封校的遭遇表示同情。可能是他感觉问到的亮点不多，所以也很直接地告诉我这次能不能给我过还是要和用我的部门主管再商量一下，然后还小心翼翼地问我“这应该不算PUA吧？我现在已经搞不懂你们年轻人的想法了”</p></li><li><p>HR面（视频面试）<br>我以为二面已经凉了，没想到第二天就给我打电话约了HR面的时间<br>hr是个挺好看的小姐姐，面得还是挺轻松愉快的，小姐姐人也很好（虽然她迟到了几分钟）<br>面的内容大概就是觉得自己是个怎样的人、最有成就感的事情是什么、工作地杭州可不可以、以及一些我提到的经历等等，总时间持续了半小时，小姐姐最后也表示对我挺欣赏的。</p></li></ul><h4 id="面试结果"><a href="#面试结果" class="headerlink" title="面试结果"></a>面试结果</h4><p>hr面完三四天后TL通过微信告诉我已经过了，给我分配了框架、数据库、测试、设计模式等学习的任务</p><h4 id="面试总结"><a href="#面试总结" class="headerlink" title="面试总结"></a>面试总结</h4><p>感觉蚂蚁的面试还是更注重项目些，会更看重你有什么代表作，八股文的东西背了几乎都没用上；可以试着在面试的时候尽量把问题引导到自己准备过的东西上，hr面前我看了挺多话术，大部分还是用上了，所以总的结果还是不错的吧。</p>]]></content>
    
    
    <categories>
      
      <category>实习分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>子豪</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实习分享(第六弹)</title>
    <link href="/AcceptedHelper/2022/04/18/%E5%AE%9E%E4%B9%A0%E5%88%86%E4%BA%AB(%E7%AC%AC%E5%85%AD%E5%BC%B9)/"/>
    <url>/AcceptedHelper/2022/04/18/%E5%AE%9E%E4%B9%A0%E5%88%86%E4%BA%AB(%E7%AC%AC%E5%85%AD%E5%BC%B9)/</url>
    
    <content type="html"><![CDATA[<h1 id="实习分享-第六弹"><a href="#实习分享-第六弹" class="headerlink" title="实习分享(第六弹)"></a>实习分享(第六弹)</h1><h2 id="George-Plover-的面试分享"><a href="#George-Plover-的面试分享" class="headerlink" title="George_Plover 的面试分享"></a>George_Plover 的面试分享</h2><h3 id="个人情况"><a href="#个人情况" class="headerlink" title="个人情况"></a>个人情况</h3><p>无实习经历，无项目经历（除了课程项目），无科研经历。课外主要经历是ACM比赛，取得过ICPC/CCPC金牌。</p><p>计划本校保研，但是想尝试一下实习，想知道工作是一种什么样的体验，想学习一些知识技能。</p><p>还有就是因为平时写的大量代码都是竞赛代码，这在实际应用中没有什么价值，因此我想去尝试一下实习。</p><p>考虑到个人的未来计划（不打算直接就业）和个人比较糟糕的 multitasking 能力，只打算暑期实习两个月。</p><h3 id="简历准备"><a href="#简历准备" class="headerlink" title="简历准备"></a>简历准备</h3><p>用 【<a href="https://www.wondercv.com/">超级简历</a>】 的模板准备了一份英文简历。至于为什么是英文，是因为最开始打算去投 Google 的，英文简历是必要的。</p><p>主要填写了竞赛经历、课程项目经历（C++面向对象、数据结构、五级流水线、数据库web和B+树）、组织经历。</p><h3 id="面试经历"><a href="#面试经历" class="headerlink" title="面试经历"></a>面试经历</h3><h4 id="Google-SWE"><a href="#Google-SWE" class="headerlink" title="Google SWE"></a>Google SWE</h4><h5 id="投递简历"><a href="#投递简历" class="headerlink" title="投递简历"></a>投递简历</h5><p>因为之前有同学推荐，再加上校赛赞助商 Google 的宣传，我打算去投一下 Google SWE 。</p><p>不过期末季比较忙，导致最后在实习项目简历 ddl 前一天（2022.01.17）才投出去。</p><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p>自此石沉大海。 至今没有任何回应……</p><h4 id="腾讯-天美-游戏客户端"><a href="#腾讯-天美-游戏客户端" class="headerlink" title="腾讯 天美 游戏客户端"></a>腾讯 天美 游戏客户端</h4><h5 id="投递简历-1"><a href="#投递简历-1" class="headerlink" title="投递简历"></a>投递简历</h5><p>参加了腾讯 ACM Open Day 活动，有机会听了HR的一些介绍，HR建议我去投北极光工作室。然后我试着投了一下。</p><p>不过中途被打断了，有个学长（似乎是ICS的TA）在天美说他们工作室在招实习，于是我改投天美了。</p><p>技术栈基本都是C++。</p><p>据说这个组在做 刺客信条手游。: )</p><h5 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h5><p>开视频面试，有两个面试官，一个问C++基础知识，一个问游戏算法相关知识。</p><p>问了一些 C++ 面向对象的内容。</p><ul><li> C++ 虚函数。new delete 的实现原理。</li></ul><p>说实话，我没怎么准备这些内容……凭着模糊的记忆描绘了一下虚函数。</p><p>new delete 的原理我直接瞎掰了（以至于下来都不知道自己是怎么扯的） ，也不知道对不对……反正面试的时候就拉扯……</p><ul><li>快速排序算法的时空间复杂度分析。</li><li>开放问题：平面上10万个点，如何快速查询一个点周围距离不超过10的点的数目？</li></ul><p>让我想到了一个平面最近点对的经典问题，我感觉KDTree可以做（但其实没想清楚细节，甚至正确性有没有也不知道），于是管不了那么多了就给面试官说用数据结构KDTree。</p><p>面试官又问还有没有其他做法。我又给了一个分块处理的思路。</p><p>我觉得，开放问题，思路应该比细节更重要吧，既然是开放问题肯定很难有标准答案的，因此重要的是向面试官展现你的思路和思考过程。</p><ul><li>如何判断两个方形是否相交？（边不一定与坐标轴平行）</li></ul><p>游戏一般都涉及到图形学、计算几何相关的算法。这似乎是一道经典题目，不过我没有做过准备。最后给出的方法是分别判断四条边是否有交，再判断有没有包含关系。面试官说还不够优秀，判断的东西太多了。</p><h5 id="二面以及之后"><a href="#二面以及之后" class="headerlink" title="二面以及之后"></a>二面以及之后</h5><p>之后都是电话面试的形式了，问的问题都是个人规划，实习时间，询问战胜困难的经历之类的问题，和专业知识关系不大。</p><p>个人规划上问到我是不是要读研究生，我还是如实回答了是。</p><h5 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h5><p>最近收到了offer。</p><h4 id="华为-计算产品线-软件开发工程师"><a href="#华为-计算产品线-软件开发工程师" class="headerlink" title="华为 计算产品线 软件开发工程师"></a>华为 计算产品线 软件开发工程师</h4><h5 id="投递简历-2"><a href="#投递简历-2" class="headerlink" title="投递简历"></a>投递简历</h5><p>因为去年参加过ICPC华为训练营，今年寒假收到了HR的联系和关照，交流之后把投向了计算产品线。</p><h5 id="机考"><a href="#机考" class="headerlink" title="机考"></a>机考</h5><p><a href="https://www.zhihu.com/question/462873802/answer/2361166272">华为机试（软件，3道编程题）到底是什么难度？</a></p><p>一共三道题目，分值100、200、300，给2小时做题。</p><p>第一题编程基础，后面两道题都涉及算法和图论了。</p><p>可以多次提交，每道题有部分分，每道题取最高分提交为最后成绩。</p><p>凭借算法竞赛经验拿到了满分。</p><h5 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h5><p>问了一些课程项目和专业基础知识，最后有一道题目的现场编程。</p><ul><li><p>五级流水线：简述五级流水线组成，问了实现流水线过程中遇到的困难。</p></li><li><p>数据库：问了事务、锁相关知识点。问了蔟聚索引的意义。</p></li><li><p>计算机网络：问了IP协议在哪个层，TCP/UDP区别。</p></li><li><p>编程题：一个宽度优先搜索的基础题目，问从起点能否遍历到所有的结点。</p></li></ul><p>非常值得庆幸的是，面试官问的专业知识都不太深入，刚好是我还记得一点的。</p><p>如果问什么进程线程通信、缓存内存、inode什么的，没准备真的不太答得上来。</p><h5 id="二面以及之后-1"><a href="#二面以及之后-1" class="headerlink" title="二面以及之后"></a>二面以及之后</h5><p>和腾讯类似，问的问题都和专业知识关系不大。</p><h5 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h5><p>最近收到了offer。</p><h3 id="感受和体会"><a href="#感受和体会" class="headerlink" title="感受和体会"></a>感受和体会</h3><ul><li>感觉面试官会从简历角度和面试者自我介绍的内容来问问题，因此尽量把话题往自己熟悉的方向上引。</li><li>遇到不会的问题可以先给出自己的思路和方向（有可能获得面试官的提示），尽量不要尬住。</li><li>最好还是复习一下专业基础知识和自己做过的项目。</li><li>然后就是要熟悉基础算法，达到能够当场写的熟练度。</li></ul>]]></content>
    
    
    <categories>
      
      <category>实习分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>George_Plover</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实习分享(第五弹)</title>
    <link href="/AcceptedHelper/2022/04/15/%E5%AE%9E%E4%B9%A0%E5%88%86%E4%BA%AB(%E7%AC%AC%E4%BA%94%E5%BC%B9)/"/>
    <url>/AcceptedHelper/2022/04/15/%E5%AE%9E%E4%B9%A0%E5%88%86%E4%BA%AB(%E7%AC%AC%E4%BA%94%E5%BC%B9)/</url>
    
    <content type="html"><![CDATA[<h1 id="实习分享-第五弹"><a href="#实习分享-第五弹" class="headerlink" title="实习分享(第五弹)"></a>实习分享(第五弹)</h1><h2 id="编者按"><a href="#编者按" class="headerlink" title="编者按"></a>编者按</h2><p>欢迎大家来到19CS的实习分享会，从4月11日起，将会每天更新一位同学的面试经历和经验，也欢迎大家积极投稿。</p><h2 id="2022暑期实习整理"><a href="#2022暑期实习整理" class="headerlink" title="2022暑期实习整理"></a>2022暑期实习整理</h2><p>所有的面试岗位都是Java开发实习生。</p><h3 id="投递公司："><a href="#投递公司：" class="headerlink" title="投递公司："></a>投递公司：</h3><p>蚂蚁（base上海、杭州），携程（base上海），美团（base上海），恒生电子（杭州）</p><h3 id="选择公司的原因"><a href="#选择公司的原因" class="headerlink" title="选择公司的原因"></a>选择公司的原因</h3><p>选择蚂蚁和恒生电子的原因很简单，因为想要去了解金融科技领域。蚂蚁有支付宝，恒生是金融科技公司。携程和美团我看中的是生活服务领域（携程的票务和美团的生活领域）。另一方面携程是Apoll开源项目的主要贡献者，去感受一下他们的注册配置中心也是不错的。。。</p><h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>无脑跟着java开发的路线走。我没有实验室，没有导师，没有科研，因此走开发的路似乎会轻松一些，因为这条路上，大家都缺少经验。直到上个寒假前，我也是没有任何开发技术的，算法不行，绩点拉胯，考研没兴趣，一切似乎都比较未知。但是上个寒假开始学习Java开发路线的一些基本常识框架，从Java web到Spring，再到Spring开发流程的各种各样的组件学习，比如SpringBoot，SpringCloud（springcloud是一堆组件构成的，东西比较多），之后学习了docker容器技术，方便搭建集群以及各种各样的工具的管理。。。。反正就是一堆，然后我抱着试一试的心态去进行面试。</p><h3 id="投递简历"><a href="#投递简历" class="headerlink" title="投递简历"></a>投递简历</h3><p>本人基本是通过官方渠道。有人关心内推的问题，我个人觉得是否内推无所谓，因为大部分企业内推只能帮你过简历关，实际上“复旦大学”已经足够帮你过简历关了。</p><h3 id="面经"><a href="#面经" class="headerlink" title="面经"></a>面经</h3><h4 id="蚂蚁-数字金融线"><a href="#蚂蚁-数字金融线" class="headerlink" title="蚂蚁-数字金融线"></a>蚂蚁-数字金融线</h4><p>第一场面试，准备不够充分，一面挂了。通过复盘，这是因为简历中写了很多技术点，但是这些技术点并没有准备充分，导致回答的时候不够好。</p><ul><li>简单介绍项目</li><li>项目中用了mybatis，询问mybatis<ul><li>mybatis二级缓存</li><li>底层连接数据库的原理（我当时直接答JDBC，但没讲到后面的sqlSession相关，因此没有得到正面反馈）</li></ul></li><li>mysql<ul><li>事务各种隔离级别</li><li>mysql主从复制</li></ul></li><li>算法题<ul><li>反转链表</li></ul></li></ul><h4 id="蚂蚁-支付宝事业线"><a href="#蚂蚁-支付宝事业线" class="headerlink" title="蚂蚁-支付宝事业线"></a>蚂蚁-支付宝事业线</h4><p>目前已经面完hr面</p><h5 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h5><ul><li>自我介绍，项目</li><li>你如何解决困难技术问题的</li><li>Java ArrayList中删除所有满足某特定条件的元素的方法（iteration）</li><li>大数据量如何多次寻找topK（答：扔到数据库维护一个视图）<ul><li>反问还有解决方法吗</li><li>答，使用redis的有序集合维护，balabala。。。</li></ul></li><li>两个表，一个表大量数据，一个表少量数据，怎么求他们的交集？</li><li>剩下的问题忘了，就先这样吧</li></ul><h5 id="一试加面笔试（写了一道编程题，注意：编程题不是算法题）"><a href="#一试加面笔试（写了一道编程题，注意：编程题不是算法题）" class="headerlink" title="一试加面笔试（写了一道编程题，注意：编程题不是算法题）"></a>一试加面笔试（写了一道编程题，注意：编程题不是算法题）</h5><ul><li>写一个模型，这个模型需要管理多个服务器，用户可以在多个服务器（A，B，C，…）进行login操作，每次login都会向这个模型发送用户在哪一台服务器进行的，并且计数。你需要写一个函数，这个函数在每分钟对每台服务器的login次数进行排序。（考察点：线程安全，模型优化等等）。</li><li>我自己的思路是用executor的schdule调度管理，fixed_rate设置为1分钟，然后存放login次数的结构是哈希表，每个元素是一个LongAdder，保证线程安全，同时分段锁的时候提高效率。（应该有其他优化方法，虽然scheduledAtFixedRate拉胯，但是我只知道这个。。。。）</li></ul><h5 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h5><p>突击面试，没有任何通知，直接一个电话打来说有时间吗，我们直接开面。我当时还在摆大烂。。。</p><p>基本没问啥，就批评了一下我项目太简单。我垃圾crud项目确实没啥亮点，我反驳接触开发时间不长，没有足够的时间沉淀技术</p><ul><li>发展方向？</li><li>对技术底层有没有热情（我答源码会看，但是伤脑，如果有前辈引领，我会有更大的信心与动力）</li><li>我看你实际开发经验缺乏，你有没有了解JVM的模型？</li><li>base地杭州，你可以吗？</li></ul><h5 id="hr面"><a href="#hr面" class="headerlink" title="hr面"></a>hr面</h5><p>也是突击面试，下午5点说可以立即面试吗？我说接下来有课，8点以后可以。</p><p>本来以为二面被嫌弃了一顿基本凉了，没想到进下一面了。</p><ul><li>自我介绍</li><li>压力最大时候</li><li>选择最艰难的时候</li><li>讲一下你通过项目学到了什么</li><li>。。。一些和技术毫不相干的东西</li></ul><h4 id="携程"><a href="#携程" class="headerlink" title="携程"></a>携程</h4><h5 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h5><p>基本都是八股，去牛客网上看看吧。</p><h4 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h4><p>稍微讲讲，基本都是针对项目问，问到你不会为止。比如我提到项目中mysql直接在text中存放json数据。面试官问text字段有没有字数限制，有问有没有其他解决思路，我回答可以转型mongodb，因为mongdb自带json存储。面试官反问，技术栈转型会带来什么问题？我tm咋知道，我就说了增加学习成本，可能出现意想不到的bug。面试官反问什么bug，，，反正给我整不会了。</p><p>提到spring和springboot，询问这两个的区别。我只答到springboot的autoconfiguration用于简化配置，“约定大于配置”的原则，不指定直接使用默认的，指定使用个性化的。主要强调sb是配置工具类，而spring时一个大框架，在spring中我们使用配置文件或者注解驱动进行Springbean的管理。</p><p>问到redis的缓存穿透和缓存击穿，以及他们的解决思路。</p><p>之后问了一下你最近在看什么书，喜欢读什么类型的书，你有什么爱好。</p>]]></content>
    
    
    <categories>
      
      <category>实习分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>匿名</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实习分享(第四弹)</title>
    <link href="/AcceptedHelper/2022/04/14/%E5%AE%9E%E4%B9%A0%E5%88%86%E4%BA%AB(%E7%AC%AC%E5%9B%9B%E5%BC%B9)/"/>
    <url>/AcceptedHelper/2022/04/14/%E5%AE%9E%E4%B9%A0%E5%88%86%E4%BA%AB(%E7%AC%AC%E5%9B%9B%E5%BC%B9)/</url>
    
    <content type="html"><![CDATA[<h1 id="实习分享-第四弹"><a href="#实习分享-第四弹" class="headerlink" title="实习分享(第四弹)"></a>实习分享(第四弹)</h1><h2 id="编者按"><a href="#编者按" class="headerlink" title="编者按"></a>编者按</h2><p>欢迎大家来到19CS的实习分享会，从4月11日起，将会每天更新一位同学的面试经历和经验，也欢迎大家积极投稿。</p><h2 id="面经分享"><a href="#面经分享" class="headerlink" title="面经分享"></a>面经分享</h2><h3 id="一、面试前的准备"><a href="#一、面试前的准备" class="headerlink" title="一、面试前的准备"></a>一、面试前的准备</h3><p>1、 自身基本情况（成绩/项目/实验室/实习等）<br>成绩中等，没有项目，未进实验室，没有实习经历；</p><p>2、 投了哪几个公司，具体职位，如何了解到这个机会的<br>只尝试投了ByteDance，后端研发，通过朋友圈推文</p><p>3、 面试之前准备了些什么（算法、OS等）<br>背了些八股文，刷了几道字节之前考过的题</p><p>4、 简历大概如何准备的<br>网上搜索“实习小白如何准备技术岗简历”，照猫画虎</p><p>5、 是否提前对该公司或岗位有过了解<br>了解过公司福利很好，其余不了解</p><p>6、 是否已经有过面试经验<br>否，第一次面试，紧张极了</p><h3 id="二、面试过程"><a href="#二、面试过程" class="headerlink" title="二、面试过程"></a>二、面试过程</h3><p>1、面试的方式和地点<br>视频面试+被推迟到第二天17:00-18:00</p><p>2、面试当天的穿着、随身物品、自我介绍等<br>穿着整洁但是随意+自我介绍100字非常简洁</p><p>3、现场被问了哪些问题（笔试、问答等都可以）<br>当我告诉他我第一次面试之后他就只问我简历上提到的知识点（比如：DB的索引，OS的内存管理，CN的TCP/UDP）</p><h3 id="三、面试结果"><a href="#三、面试结果" class="headerlink" title="三、面试结果"></a>三、面试结果</h3><p>1、面试是否成功<br>不成功</p><p>2、回顾：自己有哪些做的好或者不好的地方，自己成功或者失败的关键原因是什么<br>算法题太拉了</p><p>3、不同公司/岗位面试的共同点和不同点（难度、侧重点等）<br>不详</p><p>4、对大家提一些建议吧：如何才能顺利通过面试<br>多刷题，大家基础知识都很好了</p>]]></content>
    
    
    <categories>
      
      <category>实习分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>煜格</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实习分享(第三弹)</title>
    <link href="/AcceptedHelper/2022/04/13/%E5%AE%9E%E4%B9%A0%E5%88%86%E4%BA%AB(%E7%AC%AC%E4%B8%89%E5%BC%B9)/"/>
    <url>/AcceptedHelper/2022/04/13/%E5%AE%9E%E4%B9%A0%E5%88%86%E4%BA%AB(%E7%AC%AC%E4%B8%89%E5%BC%B9)/</url>
    
    <content type="html"><![CDATA[<h1 id="实习分享-第三弹"><a href="#实习分享-第三弹" class="headerlink" title="实习分享(第三弹)"></a>实习分享(第三弹)</h1><h2 id="编者按"><a href="#编者按" class="headerlink" title="编者按"></a>编者按</h2><p>欢迎大家来到19CS的实习分享会，从4月11日起，将会每天更新一位同学的面试经历和经验，也欢迎大家积极投稿。</p><h2 id="面经分享"><a href="#面经分享" class="headerlink" title="面经分享"></a>面经分享</h2><p>岗位：微软(苏州)STCA软件开发(提前批招录)</p><p>其实在面试微软之前也做了一个阿里提前批的一面，当时因为计网、操作系统都没有学，面试过程不是很顺利。面试官让我等二三四面的通知，结果半年过去音信全无。学期中的时候微软给我发了一封邮件(因为大二的时候投过explorer的项目，虽然当时笔试做完就音信全无了)，内容大约是校园星推官自荐之类的，然后就进了QA群。因为有内推，所以没要做笔试，加上我为了稳妥投的是苏州的开发岗，所以竞争压力非常小，假期里两轮面试之后就拿到了offer。这里简单分享一些个人经验给大家做参考。</p><h3 id="面试前准备"><a href="#面试前准备" class="headerlink" title="面试前准备"></a>面试前准备</h3><p>首先需要一份高质量的简历。我的简历是用latex模板写的(免费/美观/可拓展)，overleaf提供了很多<a href="https://www.overleaf.com/gallery/tagged/cv">简历模板</a>，可以去找自己满意的。也可以使用我用的<a href="https://www.overleaf.com/articles/ashish-sinhas-curriculum-vitae/rhcjpcxjjbyj">简历模板</a>(将其中photo项取消注释可以配置照片，如何使用中文请自行搜索)。我自己也试过markdown、word等，但都无法同时做到美观和容易拓展。个人认为一份好的简历有几个要点：</p><ul><li>姓名、联系方式、照片醒目</li><li>单栏单页，简洁明了，不要太多花哨。</li><li>写好项目经历：自己的工作，自己的收获【最好能把贡献量化】</li></ul><p>我的简历大概长这样：</p><img src="https://s2.loli.net/2022/03/29/xb1Bc3QmvEgqtsJ.png" alt="picture" style="zoom: 50%;" /><p>因为自己上过很多做project的课，加上实验室也做了一些工作，所以简历上堆了5,6个项目经历。关于算法题——我面试之前基本没准备，属于是吃大二数据结构的老本，加上面试职位难度低，所以才过了。</p><p>因为说听过一次微软宣讲，了解过一点微软的企业文化，自己也怀疑面试会不会问一些文化相关，所以面试之前去官网查了一下相关的——不过没啥用，面试的时候才知道：外企和中国企业面试内容都是一样的问答+算法。</p><p>也上网查了一些面经，说实话帮助不大。</p><h3 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h3><p>我面试的是微软提前批，一面过了就直接终面。一面没过的会走二面。两次面试都是45min，在线上面试。考虑到可能要现场写代码，所以准备了纸和笔。衣服就是日常妆束。</p><p>这里附一下一面和终面的问题</p><blockquote><p>一面45min：温柔nice的大叔</p><ul><li>你平时是否有应用过设计模式？(没学过，直接跳了)</li><li>面向对象三要素(忘了，阐述了一下自己的理解)</li><li>你熟悉的语言是如何实现多态的？什么情况下多态会起作用？(说了C++虚函数)</li><li>根据简历问项目经历(技术内容为主)</li><li>操作系统相关(进程和线程，同一进程线程之间是否有地址保护？地址空间在内存中的分段？)</li><li>简述五级流水线</li><li>实现非递归的二叉树后序遍历(时间不够了就大概讲了一下思路)</li><li>自由提问环节：<ul><li>转正要看部门的空位和实习期间performance</li></ul></li></ul><p>终面45min(实际用时1h)：没开摄像头，声音比较职业</p><ul><li>自我介绍、介绍一个你的项目</li><li>你遇到了什么困难，你是如何解决的？以后遇到类似的困难你会如何解决？</li><li>职业规划(之前听的字节讲座介绍了如何做合理的职业规划，我面试的时候现编，感觉对面听起来还算满意)</li><li>你对什么数据结构比较了解？我说我看实际使用需求，栈、队列、map什么的都会用，然后问我map原理，我说可以用红黑树实现，之后要求手写一个map，数据结构不限。我30min写了一个有序二叉树(浪费了好多时间，DS课结束就很少碰算法了)，写完让我自己写测试，差不多又用了15min的样子，幸好没出大问题能跑</li><li>自由提问环节：<ul><li>如果被录用，具体去哪个组看的是各个组的空缺和个人经历</li><li>我问我还有什么可以改进的，和我说代码写太慢了，他们需要的是熟练工</li></ul></li></ul></blockquote><h3 id="面试之后"><a href="#面试之后" class="headerlink" title="面试之后"></a>面试之后</h3><p>收到通过终面的邮件之后，微软给了确认offer的期限——比我想象的要早很多，绝没有再拿到其他offer的可能。权衡一下还是决定之后一个学期不要再花时间在刷题和准备面试上，最终确认了offer。</p><p>然后也花了一些时间查看了工作地点附近的交通情况，包括住宿之类的也用一些app查好了价格和位置。</p><p>个人总结<strong>自己本次</strong>面试成功的原因，以下按照重要性降序排序：</p><ul><li>职位Head Count多，竞争者少，面试压力非常小</li><li>对计算机基础知识的掌握(ICS/OS/计网/数据结构)【一面】</li><li>之前听一些讲座的积淀：“如何确定一个好的职业规划？”个人感觉自己临场编的的职业规划比较rational，面试官很满意【二面】</li><li>coding能力</li></ul><p>我自己感觉在<strong>多线程编程</strong>、<strong>算法题</strong>上还有很大的提升空间，也推荐大家积极参加算法课堂活动，每天做1~2题，对读研的上机考试以及面试都帮助非常大。</p>]]></content>
    
    
    <categories>
      
      <category>实习分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>傻东西</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实习分享(第二弹)</title>
    <link href="/AcceptedHelper/2022/04/12/%E5%AE%9E%E4%B9%A0%E5%88%86%E4%BA%AB(%E7%AC%AC%E4%BA%8C%E5%BC%B9)/"/>
    <url>/AcceptedHelper/2022/04/12/%E5%AE%9E%E4%B9%A0%E5%88%86%E4%BA%AB(%E7%AC%AC%E4%BA%8C%E5%BC%B9)/</url>
    
    <content type="html"><![CDATA[<h1 id="实习分享-第二弹"><a href="#实习分享-第二弹" class="headerlink" title="实习分享(第二弹)"></a>实习分享(第二弹)</h1><h2 id="编者按"><a href="#编者按" class="headerlink" title="编者按"></a>编者按</h2><p>欢迎大家来到19CS的实习分享会，从4月11日起，将会每天更新一位同学的面试经历和经验，也欢迎大家积极投稿。</p><h2 id="夜雨声烦的凉经"><a href="#夜雨声烦的凉经" class="headerlink" title="夜雨声烦的凉经"></a>夜雨声烦的凉经</h2><h3 id="一些个人情况："><a href="#一些个人情况：" class="headerlink" title="一些个人情况："></a>一些个人情况：</h3><p>保研边缘人，项目经历比大家只少不多（只有些划水项目）；寒假刚从大数据学院的内生安全实验室润走；无实习经历；目前在本校的技术社团“凌客工坊”摸鱼orz</p><h3 id="正-文-开-始-↓"><a href="#正-文-开-始-↓" class="headerlink" title="正 文 开 始 ↓"></a>正 文 开 始 ↓</h3><p>一开始其实是没想到要投实习的，然后上学期微软的软件工程师暑期实习提前批开招后被朋友拉去试了个水（但是因为简历交错地方直接G到正式批），在本学期初又投了字节的飞书后端，美团的前端Web工程师，然后找认识的学长内推了阿里的Java工程师。</p><p>了解实习机会的话，一般各个（大）厂在校招开始前都会开微信群，我们的院信息交流群也会发各种实习信息（u1s1这个信息群真的良心）；或者可以主动出击找认识的学长学姐内推，再直接一点的可以直接去公司官网查实习信息。</p><p>下面是亿些面（shi）试（bai）经历：</p><h5 id="1-阿里——Java工程师"><a href="#1-阿里——Java工程师" class="headerlink" title="1.阿里——Java工程师"></a>1.阿里——Java工程师</h5><p>阿里那边是电话面试。先上来简单自我介绍，问了一下未来的生涯规划，然后：</p><p>1）请讲一下二进制文件的执行过程（扯了一大堆编译原理，ICS相关的知识，好像把对面绕晕了最后为了拖时长硬生生去扯JVM的转化）<br>2）请讲一下OS中怎么把二进制文件变成进程的（不会，但和他硬扯了一下进程和程序的区别）<br>3）请描述一下用户态→内核态的转换过程（就xzp讲的那些，我当时漏讲了一个触发中断，其他点好像都答到了）<br>4）请描述一下线程和进程的区别（课上的知识）<br>5）什么是xie程（超纲了，弱弱表示不会。对面学长表示是个很古早的概念不会正常）<br>6）C++中class和struct什么区别（大致只记得默认访问修饰符和用途不一样，其他就硬扯）<br>7）free 和 delete啥区别？new 的东西可以free吗？（没反应过来，new会调用对象析构函数；new的应该用delete）</p><p>最后以两道算法题收尾：</p><p>1）删除链表倒数第n个节点，并返回链表头（经典双指针了）<br>2）实现内存拷贝函数（C好久不写了直接翻车，对面看着伪码一脸懵。坑：无法去读原内存的大小所以就是直接拷，不过考虑到安全问题也无伤大雅）</p><blockquote><p>PS：不用跑测试，所以要注意打注释以及和面试官交流</p></blockquote><h6 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h6><p>对面最后表示是来招日常实习的。因为下学期还不想日常实习就主动拒了……</p><h5 id="2-微软暑习一面"><a href="#2-微软暑习一面" class="headerlink" title="2.微软暑习一面"></a>2.微软暑习一面</h5><p>算法题：</p><p>字符串S1，模式串S2，不考虑S2的顺序，找出所有匹配S2的S1的子串的起始位置。</p><h6 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h6><p>一道基础题硬是做了40多分钟，面试官估计被我整不会了都…</p><h5 id="3-微软暑习二面"><a href="#3-微软暑习二面" class="headerlink" title="3.微软暑习二面"></a>3.微软暑习二面</h5><p>被各种狂问项目，就是各种底层知识……</p><p><img src="https://pic.imgdb.cn/item/62431e4527f86abb2a03727c.jpg"></p><blockquote><p>当时写的时候很多东西确实是单纯面向浏览器编程，也没有彻底弄懂，确实不应该…</p></blockquote><h6 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h6><p>还能期待什么呢第二天中午就感谢信了…</p><h5 id="4-字节——飞书一面"><a href="#4-字节——飞书一面" class="headerlink" title="4.字节——飞书一面"></a>4.字节——飞书一面</h5><p>至今记忆犹新，面完后人都麻了（物理意义上坐麻了）：</p><p><strong>操作系统：</strong></p><ol><li><p>操作系统的特征（并发，异步，虚拟，共享）</p></li><li><p>操作系统功能（内存管理，文件管理，设备管理，进程管理）</p></li><li><p>进程和线程区别</p></li><li><p>进程间通信方式（管道，共享内存，信号量）</p></li><li><p>谈谈对管道的理解</p></li><li><p>死锁的必要条件（4个）</p></li><li><p>预防死锁？（讲了银行家算法）</p></li><li><p>文件系统的组织结构？（对比数据库B+树，inode直接块一级间接balabala）</p></li><li><p>阐述一下并发和并行的区别</p></li></ol><p><strong>数据库：</strong></p><ol><li><p>B树和B+树的区别？</p></li><li><p>用过哪些数据库？</p></li><li><p>MySQL的主键索引和普通索引的区别</p></li><li><p>事务的基本特征</p></li><li><p>事务的传播机制了解吗？谈谈你对其原理的理解（？至今不懂）</p></li><li><p>谈谈你对InnoDB的了解</p></li></ol><p><strong>数据结构（JAVA）</strong>：</p><ol><li><p>HashMap的底层原理了解吗？（后来还给我科普了一些hash算法相关知识）</p></li><li><p>简单实现一个定长数组扩容的方式（就两倍增长，参考C++ push_back底层）</p></li><li><p>简单说一下你对Java集合类的了解吧</p></li><li><p>谈谈OOP语言的基本特性</p></li><li><p>讲一下对多态的理解；举个例子说明多态机制的意义</p></li></ol><p><strong>计算机网络：</strong></p><ol><li><p>解释一下半双工和全双工</p></li><li><p>OSI模型和TCP/IP模型描述一下，各层是干什么的？为什么要分层？（开放题）</p></li><li><p>TCP和UDP描述（可靠和快）</p></li><li><p>描述一下同一个局域网内的计算机传输数据的过程（物理层，数据链路层，传输层）</p></li><li><p>在浏览器中输入一个URL链接，然后跳转到一个网页。中间发生的过程描述一下？</p></li><li><p>谈谈你对IP协议和IP层的理解？</p></li></ol><p><strong>软件工程：</strong></p><ol><li>像抖音这种大型软件，主要由哪几部分构成？你会怎么开发抖音这种大型APP？（和面试官说还在学，就当开放题答了）</li></ol><p><strong>算法题：</strong><br>Combination Sum（leetcode）</p><p>（挺可惜的当时其实写出来了，但是一个超小的bug愣是没看出来，我会个锤子的Java）</p><h5 id="5-字节——飞书二面"><a href="#5-字节——飞书二面" class="headerlink" title="5.字节——飞书二面"></a>5.字节——飞书二面</h5><p>出了一道要用树的直径做的算法题，没写出来…</p><p>And 面试官貌似对我的项目经历不太满意</p><p>回头搜了一下题目：</p><p><img src="https://pic.imgdb.cn/item/6243235327f86abb2a14b209.jpg"></p><blockquote><p>我爪巴</p></blockquote><h6 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h6><p>吊瓶里通电——输麻了</p><h5 id="6-美团——Web前端工程师"><a href="#6-美团——Web前端工程师" class="headerlink" title="6.美团——Web前端工程师"></a>6.美团——Web前端工程师</h5><h6 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h6><p>美团的笔试是五道算法题（技术岗），最后一道会根据岗位的不同变换风格。然后笔试成绩会作为是否能进面试环节的参考：</p><p>1.抽k张（我用集合+dp AC的）<br>2.旋转数组的最长子序列（也是dp，没修出来，最后只过了30%样例…）<br>3.切豆腐（以前DS上机做过切矩形，就不太会，现在还切三维，G）<br>4.区间操作（线段树好像是，还不是模板题，G）<br>5.XaYb（这是题目名称，应该是特殊技术岗专属题，然后我以为120min是前面四道题的没想到是整场考试的，G）</p><blockquote><p>直接从聊天记录里摘来的，因为大多数题目没有名字只记住了内容orz</p></blockquote><h6 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h6><p>就和面试官聊天，包括但不限于：有无前端开发经历；学了哪些框架；平时看什么前端技术博客；是否了解前端的行业发展趋势；我看你Java学的挺多的那为什么选择前端 balabala</p><p>也问了几个技术问题：</p><ol><li><p>进程和线程的区别？</p></li><li><p>ES6中怎么判断一个对象是不是数组？</p></li><li><p>闭包是什么？应用场景是什么？</p></li><li><p>CSS的盒子模型</p></li><li><p>JS的变量提升是什么？</p></li><li><p>VUE在改动后不用重新运行就能刷新，为什么？</p></li></ol><p>算法题水了一道最长公共前缀</p><h6 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h6><p>至今杳无音讯……(美团前端应该是三轮技术面，上面只是一面)</p><blockquote><p>他甚至连感谢信都不愿意发一封，哭死QAQ</p></blockquote><h5 id="7-字节——技术中台"><a href="#7-字节——技术中台" class="headerlink" title="7.字节——技术中台"></a>7.字节——技术中台</h5><p>收到面试邀请时一脸懵因为根本没投，问了朋友知道字节有捞人的习惯</p><p>然后被狂问了各种高并发开发和数据库底层的问题，彻底没准备过这方面的…</p><blockquote><p>（dpq没记下来具体问题….）</p></blockquote><p>最后怒吃感谢信</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h6 id="吐槽版"><a href="#吐槽版" class="headerlink" title="吐槽版"></a>吐槽版</h6><p>字节这场耻辱性的面试，已经成为了这两天互联网大厂最大的话题，我们来看一下前HR范XX对此的点评。一向直性子的范XX直言道，面试者这样G只怕是连脸都不要了：</p><p>– 你说技术部门，技术部门一个一个面了多少轮了，改过吗啦，换汤不换药啊。人家美团也有理由说的，我（想要）招的是什么队啊，我招的校ACM队（指北斗计划）。你是什么人啊，你叫我招？后端开发什么水平，就这么点知识量，你树的直径什么都打不出来那能过吗？过不了没这个能力知道吗？再下去的话要发感谢信了</p><p>– 另一方面来说，（对面的）面试者是备战HR面最早的</p><p>– 哦呦，谢天谢地了，你这样的面试本身就没有打好基础，你能跟我保证在二轮或者三轮技术面这样关键的面试他能过啊？务实一点，我劝你们，把自己的技术栈，基础算法题先搞懂。数据库课程PJ设计的挺好的你把它水了干嘛，问点底层原理就G，你到告诉我怎么解释呢？脸都不要了</p><h6 id="正经版"><a href="#正经版" class="headerlink" title="正经版"></a>正经版</h6><p>简单来说就是算法没刷熟+项目没准备好(；′⌒`)，以及很多做过的题没有真正搞懂以致于换个马甲就认不出来了。</p><h4 id="亿点后话："><a href="#亿点后话：" class="headerlink" title="亿点后话："></a>亿点后话：</h4><h6 id="1）关于面试难度"><a href="#1）关于面试难度" class="headerlink" title="1）关于面试难度"></a>1）关于面试难度</h6><p>上文的面试经历可能会让很多同学觉得面试很难而打退堂鼓，其实大部分互联网公司（即使是大厂）面试还是相对温和的，并且大部分面试官会对学生特殊照顾（如果碰上学长学姐来面甚至可能放海）</p><p>除了字节，真的难…</p><h6 id="2）关于项目经历"><a href="#2）关于项目经历" class="headerlink" title="2）关于项目经历"></a>2）关于项目经历</h6><ul><li><p>有一种trick：如果你希望面试官更多问到自己的项目，就在自我介绍时提一下做过balabala；如果没啥拿得出手的项目就要好好准备基础知识了（俗称八股文），因为面试官必然会各种狂轰滥炸</p></li><li><p>不要因为害怕简历过不了而硬写各种乱七八糟但知之甚少的项目。内推途径投递一般都能过简历关，面试官也知道一般大学生能会有多少项目经历，不会故意在这点上卡简历（特殊热点部门可能除外，比如字节飞书）。但是答不好自己简历上的项目会大大影响面试官对你的印象</p></li><li><p>谨慎宣称自己了解/掌握/精通SpringBoot，因为可能有“意外之喜”。要么招来面试官对底层原理的各种灵魂拷问，要么引来其它硬核部门把你简历截了（可能看简历本来以为有点东西，面完发现是个水货，我怀疑中台那边就是这么搞我的……）</p><p>当然，大佬请放心宣称。搞不好直接把他拿下</p><blockquote><p>仅代表个人观点，大家见仁见智…</p></blockquote></li><li><p>如果你已经100%确认以后要直接实习工作了，请速速卷好剩下的每一个PJ（或者把以前的重构一遍）</p></li></ul><h6 id="3）关于面试题"><a href="#3）关于面试题" class="headerlink" title="3）关于面试题"></a>3）关于面试题</h6><p>主要复习手段就是网上各种面经，这边列几个：</p><p><a href="https://www.iamshuaidi.com/">帅地玩编程</a></p><p><a href="https://web.qianguyihao.com/">千古前端</a></p><p><a href="https://vue3js.cn/interview/vue/vue.html">面试官系列</a></p><p>几个答题小tirck：</p><ul><li><p>被问到不会的问题时大胆说不会，最好能主动说自己知道其它balabala</p></li><li><p>开放题能答多少答多少，尽量把知识点展开细说</p></li></ul><p>知识点密集区：</p><ul><li><p>OS：进程线程区别，调度算法，死锁，进程间通信</p></li><li><p>计网：七层模型，TCP/IP模型，TCP和UDP，三次握手四次挥手相关</p></li><li><p>数据结构：二叉搜索树，哈希表（Java被问的多）</p></li><li><p>数据库：索引，事务，B/B+树</p></li><li><p>其它：OOP，编译，……</p></li></ul><h6 id="4）关于岗位-公司选择"><a href="#4）关于岗位-公司选择" class="headerlink" title="4）关于岗位/公司选择"></a>4）关于岗位/公司选择</h6><ul><li><p>尽量不要在前后端之间横跳，要么都投前端要么都投后端，这样方便准备</p></li><li><p>选择简历相对稀缺的岗位可以提升OC率，没有把握可以先绕开那些面试过于硬核的大厂（点名字节）</p></li><li><p>可以先确定目标岗位再有针对性的准备自己的简历（比如哪些项目要强调，哪些可以不提甚至不放）</p></li><li><p>最好提前了解目标公司和岗位，有条件的可以去找有经验的学长学姐</p></li></ul><h6 id="5）关于算法"><a href="#5）关于算法" class="headerlink" title="5）关于算法"></a>5）关于算法</h6><p>认真刷leetcode热题，不然真的会G</p>]]></content>
    
    
    <categories>
      
      <category>实习分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>夜雨声烦</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>实习分享(第一弹)</title>
    <link href="/AcceptedHelper/2022/04/11/%E5%AE%9E%E4%B9%A0%E5%88%86%E4%BA%AB(%E7%AC%AC%E4%B8%80%E5%BC%B9)/"/>
    <url>/AcceptedHelper/2022/04/11/%E5%AE%9E%E4%B9%A0%E5%88%86%E4%BA%AB(%E7%AC%AC%E4%B8%80%E5%BC%B9)/</url>
    
    <content type="html"><![CDATA[<h1 id="实习分享-第一弹"><a href="#实习分享-第一弹" class="headerlink" title="实习分享(第一弹)"></a>实习分享(第一弹)</h1><h2 id="编者按"><a href="#编者按" class="headerlink" title="编者按"></a>编者按</h2><p>欢迎大家来到19CS的实习分享会，从4月11日起，将会每天更新一位同学的面试经历和经验，也欢迎大家积极投稿。</p><h2 id="Google-STEP面试经验"><a href="#Google-STEP面试经验" class="headerlink" title="Google STEP面试经验"></a>Google STEP面试经验</h2><h3 id="一、面试前"><a href="#一、面试前" class="headerlink" title="一、面试前"></a>一、面试前</h3><p>面试之前的成绩有ACM ICPC/CCPC区域赛的金银牌，项目经历有数据库的课程项目和参加Google Girl Hackathon的一个WebAPP，没做过科研，无实习经历。<br>只投了Google STEP这一个岗位，这是一个针对大二少数群体（在国内基本指女生）的实习项目，算是大三SWE的简单版本。了解到这个机会是因为大一在ACM队教练孙老师的介绍下参加Google开放日，去Google上海办公室参观（蹭饭），之后每次Google招实习生都会收到邮件，大二办校赛的时候和Google的HR也有一些交流，Google的招聘公众号”Google招聘包打听“会有推送，校赛也一直在打广告。对公司的了解就是食堂挺好吃的，工作很自由，dalao特别多。之前有队里的学姐成功申到了这个岗位，但是因为疫情没能线下办公，所以对具体工作内容和形式也不了解。<br>面试前因为期末季在狂赶ddl，没做什么准备。之前的面试经历有高中学竞赛时面过我们学校和其他几个大学，大一参加牛客女生赛面试了一次。Google开放日组织了一次线下模拟面试，做了一道很简单的题目，也了解了面试官对面试者的期待，所以对这次面试比较放松。开放日也做过简历指导，大概就是老生常谈的刚好一页纸、简洁清楚、最重要的是写清毕业年份；当时因为没做过啥项目，写了好多组织经历，勉强凑够了一页纸的简历。</p><h3 id="二、面试过程"><a href="#二、面试过程" class="headerlink" title="二、面试过程"></a>二、面试过程</h3><p>在宿舍线上面试，给了个网页写代码，功能挺差的，勉强能运行吧。因为Google的面试邮件里有要求用耳机，那天就用了新耳机，结果操作失误没声，最后还是关了耳机直接外放的。<br>自我介绍只简单说了一下学校、年级、专业、奖项，随便寒暄一下就开始出题了。两次面试好像都是只有一道要写的题和一些相关的讨论问题；写的题都是三四十行左右的简单题目，不太需要想，但是要对算法复杂度认识得比较清楚。二面的代码有一个特殊情况没有考虑，但是在和面试官的沟通中很快修正了bug。写完题目就没什么事了，为了拖时间随便聊天，一面的面试官问了我一个偏硬件和系统的问题，当时我还没学过，他让我随便凭直觉讲一下，然后告诉我其实他也不会；二面的面试官让我提问，问了如果去Google实习需要提前学习什么，面试官说什么都不用学。</p><h3 id="三、面试后"><a href="#三、面试后" class="headerlink" title="三、面试后"></a>三、面试后</h3><p>二面当天下午收到了口头offer电话。似乎STEP是两个面试官都说ok就可以直接过，所以出结果很快，SWE还是有一些招聘委员会复审之类的流程要走的。<br>STEP的题目比SWE要简单一些，然后因为年级低不太会问系统类的问题，不知道SWE是不是一样。<br>Google因为是直接让软件工程师在工作之余去面试，不是专门的面试官，所以好像不太会问工作中完全用不到的知识。我跟同事们交流的时候发现很多人已经完全忘了数字逻辑、操作系统、编译之类的课，甚至有些同事就不是计算机系科班出身的，大家去当面试官时可能也就是准备了几道算法题；当然虚拟化之类的语言特性工作中还是会用的。既然是软件工程师选理想的同事，我觉得最重要的是友好交流，题目不懂就要及时问，口头描述的题目不够严谨也是完全有可能的，开放日时面试官甚至说有些条件就是有意等大家来确定的；写之前要能清楚地阐述自己的想法，遇到bug要善于归纳出了什么问题，然后积极接受修改意见。能力方面，我实习时听说有些SWE题没做出来也过了，比较关键的可能还是写代码的习惯，变量名、结构之类尽量易读易懂；还有写完代码要给出一些有针对性的测试来覆盖各种情况，毕竟coding和testing都是工程师的重要工作。这些我们在ACM队里每天做的事情差不多，所以觉得这次面试很自然。<br>Google的面试还是算法为主，这方面我也是靠题目数量堆出来的条件反射，没什么捷径。不过希望我们的周末算法讨论班能帮大家少走些弯路，我对动态规划这个主题挺期待的，感觉有好多有用有意思的方法和题目，在这也打个广告，希望大家期中季抽时间来听orz。祝大家面试顺利！</p>]]></content>
    
    
    <categories>
      
      <category>实习分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>孙若诗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学笔记</title>
    <link href="/AcceptedHelper/2022/01/13/computer_graphics/"/>
    <url>/AcceptedHelper/2022/01/13/computer_graphics/</url>
    
    <content type="html"><![CDATA[<h1 id="基本情况"><a href="#基本情况" class="headerlink" title="基本情况"></a>基本情况</h1><p><strong>考试时间地点：</strong></p><p>邯郸校区H4201，2022-01-04，08:30~10:30</p><p><strong>考试形式：</strong></p><p>课堂报告20%+Project 30%+期末闭卷考试50%</p><p><strong>Project说明：</strong></p><p>每人独立完成，参考文献及开发工具自选，严禁拷贝抄袭。</p><p>期末考试前打包提交源代码、程序说明、算法原理、参考文献、及可执行文件给助教。以姓名+Project1/2/3命名</p><p><strong>Projects内容（全部都做，每题10分）：</strong></p><ol><li>编程实现音乐节奏或旋律的可视化</li><li>编程画一个真实感静态或动画景物</li><li>创作一个Flash动画（用现成的软件，发挥艺术想象力）</li></ol><p><strong>tips：</strong></p><ol><li>主要考点在四五章，有时候说占60%有时候说占80%；其次是六七章，余下章节只占四五分。</li><li>2021-2022年期末：十道大题，没标分值，大概一题十分？<ul><li>P1：写概念。什么是图形、图像、计算机图形学、数字图像处理、计算机视觉</li><li>P2：10个判断，各个章节都有，提到了OpenGL和DirectX</li><li>P3：10个OpenGL函数名解释</li><li>P4：椭圆的中点画圆法，下半弧，写算法流程，求递推式</li><li>P5：梁友栋算法，按PPT上的图解释</li><li>P6：解释插值、逼近、拟合、光顺，写出最小二乘法逼近定理</li><li>P7：写出Bezier的基函数、基函数的端点性质、基函数的递推关系、曲线的端点性质和几何含义、曲线的导矢性质和几何含义</li><li>P8：给出B样条的de Door算法递推式，画递推关系图和割角</li><li>P9：写出绕空间中任意轴旋转的操作步骤</li><li>P10：消除隐藏面的四分支树算法，画图，包围和分离的转角检查法</li></ul></li><li>老师讲课完全面向考试，会直接说这个算法考/不考/怎么考，所以考试内容是比较容易了解的。笔记中和考法相关的内容都加粗了。</li><li>课堂报告推荐选SIGGRAPH论文，注意不要和ATOG混淆。期末要交PRE的PPT。</li><li>真实感景物推荐《Ray Tracing In One Weekend》，是一本非常简洁而清晰的教材。如果不想手写光追，可以考虑直接opengl调库。</li><li>flash已经EOL了，但是An继承了需要的功能，从复旦信息办可以下载官方软件。</li></ol><h1 id="一、图形设备、系统和应用"><a href="#一、图形设备、系统和应用" class="headerlink" title="一、图形设备、系统和应用"></a>一、图形设备、系统和应用</h1><h2 id="1-1-计算机图形学的研究内容"><a href="#1-1-计算机图形学的研究内容" class="headerlink" title="1.1 计算机图形学的研究内容"></a>1.1 计算机图形学的研究内容</h2><p>内容：图形硬件，图形标准，图形交互技术，光栅图形生成算法，曲线曲面造型，实体造型，真实感图形计算与显示算法，以及科学计算可视化，计算机动画，自然景物仿真，虚拟现实</p><p>图像：计算机内以位图形式存在的灰度信息</p><p>图形含有几何属性，更强调场景的几何表示，是由场景的几何模型和景物的物理属性共同组成的</p><p>计算机图形学（生成图像）/数字图像处理（优化图像）/计算机视觉（认识图像）</p><h2 id="1-2-计算机图形学的发展简史"><a href="#1-2-计算机图形学的发展简史" class="headerlink" title="1.2 计算机图形学的发展简史"></a>1.2 计算机图形学的发展简史</h2><p>50年代出现图形显示器。图形学处于”被动式“图形学。</p><p>50-60年代 </p><ul><li>MIT林肯实验室首先使用具有指挥和控制功能的CRT显示器。</li><li>1962 Sutherland的博士论文提出Computer Graphics，证明交互计算机图形学是可行的、有用的研究领域。</li><li>1964 Coons教授提出超限插值，通过插值四条任意的边界曲线来构造曲面。</li><li>60年代早期Bezier发明贝塞尔曲线、曲面，用于几何外形设计。</li><li>Coons奖是计算机图形学最高奖，第一和第二届颁给Sutherland和Bezier。</li></ul><p>70年代 </p><ul><li>光栅显示器产生，光栅图形学算法迅速发展。</li><li>两个重要进展：真实感图形学、实体造型技术（出现CAD技术）</li><li>1974提出制定有关标准的基本规则，ACM图形标准化委员会1977、1979制定和修改了核心图形系统</li></ul><p>80年代 </p><ul><li>光线跟踪算法出现，真实感图形的显示算法逐渐成熟。</li><li>超大规模集成电路发展使图形学广泛应用于各领域。</li></ul><p>ACM SIGGRAPH会议：60年代中期发起</p><h2 id="1-3-应用及研究前沿"><a href="#1-3-应用及研究前沿" class="headerlink" title="1.3 应用及研究前沿"></a>1.3 应用及研究前沿</h2><p>计算机辅助设计与制造CAD，三维几何造型系统，科学计算可视化，图形实时绘制与自然景物仿真，计算机动画，用户接口，计算机艺术</p><h2 id="1-4-图形设备"><a href="#1-4-图形设备" class="headerlink" title="1.4 图形设备"></a>1.4 图形设备</h2><p><strong>（硬件考试不考）</strong></p><p>图形系统：图形处理器+图形输入设备+图形输出设备（显示器）</p><p><strong>显示器</strong></p><ul><li>CRT显示器：高中物理题那种，偏转电子束持续击打荧光屏，靠荧光点直接发光。<ul><li>劣势：磁偏转的最大角度有限，显示屏越大需要显像管越长，导致显示屏体积很大。</li><li>60Hz才不闪烁，85Hz以上人眼才舒服，为了补帧有隔行扫描技术。</li><li>彩色显示器：荫罩式，荫栅式，点距越密集越好。</li><li>产生辐射和电磁波干扰。</li></ul></li><li>液晶显示器（LCD）：一直发光，加压才变黑，不会出现闪烁问题，成像原理是光的折射<ul><li>可以看到清晰图像的最大角度为可视角度</li><li>主动式，被动式，区别在于背光源和偏光板的设计和方向不同</li><li>点距是两个液晶颗粒之间的距离</li><li>分辨率为真实分辨率，不向下兼容</li></ul></li></ul><p>图形处理器（显卡）：显示主芯片GPU+显示缓存（显存）+数字模拟转换器（RAMDAC）</p><p>图形扫描仪：分辨率（300dpi起步）、颜色</p><h1 id="二、数据接口与交换标准"><a href="#二、数据接口与交换标准" class="headerlink" title="二、数据接口与交换标准"></a>二、数据接口与交换标准</h1><p><strong>（可能考几分选择题，名词解释之类的。知道每个标准最上层的含义即可，关于细节内容不要求。）</strong></p><p>1974成立图形标准化规划委员会GSPC 提出第一个图形标准方案Core</p><p>德国GKS，后来成为国际计算机图形信息标准计算机图形核心系统</p><h2 id="2-1-图形核心系统GKS"><a href="#2-1-图形核心系统GKS" class="headerlink" title="2.1 图形核心系统GKS"></a>2.1 图形核心系统GKS</h2><p>独立于语言的图形核心系统，定义应用程序和图形输入输出设备之间的功能接口</p><p>GKS元文件称为GKSM，是GKS用于保存信息的一种机制；GKSM为GKS设计，但是本身不是GKS的一部分，在计算机图形元文件标准CGM中规定了GKSM的内容和格式。</p><p>GKSM的格式：首尾特殊，中间是各个项。每个项也分为首部和内容。</p><p><strong>（考过GKSM和GKS、CGM的关系）</strong></p><h2 id="2-2-计算机图形元文件标准CGM"><a href="#2-2-计算机图形元文件标准CGM" class="headerlink" title="2.2 计算机图形元文件标准CGM"></a>2.2 计算机图形元文件标准CGM</h2><p>提供在虚拟设备接口上存贮与传输图形信息的标准。</p><p>CGM功能类似GKSM，但是不局限于GKS生成的图形。</p><p>CGM由一套标准的与设备无关的定义图形的语法和词法元素组成。</p><p>元文件=一个元文件描述+若干逻辑上独立的画面集。</p><p>画面=一个画面描述+一个包含实际画面的画面体。</p><h2 id="2-3-计算机图形接口标准CGI"><a href="#2-3-计算机图形接口标准CGI" class="headerlink" title="2.3 计算机图形接口标准CGI"></a>2.3 计算机图形接口标准CGI</h2><p>包含图形函数库，是针对图形设备接口的交互式计算机图形标准，在用户程序和虚拟设备之间提供通信</p><h2 id="2-4-基本图形交换规范标准IGES"><a href="#2-4-基本图形交换规范标准IGES" class="headerlink" title="2.4 基本图形交换规范标准IGES"></a>2.4 基本图形交换规范标准IGES</h2><p>主要用于CAD/CAM系统中</p><h2 id="2-5-DXF数据接口"><a href="#2-5-DXF数据接口" class="headerlink" title="2.5 DXF数据接口"></a>2.5 DXF数据接口</h2><p>AutoCAD系统的图形数据文件，由于市场统治力成为事实上的数据交换标准</p><h2 id="2-6-产品数据表达与交换标准STEP"><a href="#2-6-产品数据表达与交换标准STEP" class="headerlink" title="2.6 产品数据表达与交换标准STEP"></a>2.6 产品数据表达与交换标准STEP</h2><p>关于产品数据计算机可理解的表示和交换的国际标准，描述产品生命周期中的产品数据</p><h1 id="三、图形输入与交互技术"><a href="#三、图形输入与交互技术" class="headerlink" title="三、图形输入与交互技术"></a>三、图形输入与交互技术</h1><p><strong>（第三章一二节没考过）</strong></p><h2 id="3-1-逻辑输入设备"><a href="#3-1-逻辑输入设备" class="headerlink" title="3.1 逻辑输入设备"></a>3.1 逻辑输入设备</h2><p>定位设备，描画设备，定值设备，选择设备，拾取设备，字符串设备</p><h2 id="3-2-图形输入控制"><a href="#3-2-图形输入控制" class="headerlink" title="3.2 图形输入控制"></a>3.2 图形输入控制</h2><p>一些操作原语</p><p>set_locator_mode(ws, device_code, input_mode)</p><p>常用设备编号：键盘1，鼠标9</p><p>input_mode：</p><ul><li>请求方式（<strong>request</strong>）：输入设备等待请求-遇到请求指令-进入工作，效率比较低</li><li>采样方式（<strong>sample</strong>）：输入设备不断产生数据存入缓冲区，程序遇到采样语句就到缓冲区去取最新输入数据</li><li>事件方式（<strong>event</strong>）：所有输入数据放在一个事件队列中，程序运行到事件处理语句时就从事件队列取出队首处理，队列为空则等待一定时间</li></ul><h2 id="3-3-交互技术"><a href="#3-3-交互技术" class="headerlink" title="3.3 交互技术"></a>3.3 交互技术</h2><p>定位技术，橡皮条技术，拖拽技术，菜单技术，定值技术，拾取技术（特征点法、边界矩形法、分类法、直接法），网格与吸附</p><p><strong>（橡皮条技术考过简答题，画图。应当看到图片想到这是什么技术，或给出图形画出某样技术变化后的结果。）</strong></p><h2 id="3-4-三维图形输入"><a href="#3-4-三维图形输入" class="headerlink" title="3.4 三维图形输入"></a>3.4 三维图形输入</h2><p>3D扫描仪</p><h1 id="四、光栅图形学"><a href="#四、光栅图形学" class="headerlink" title="四、光栅图形学"></a>四、光栅图形学</h1><p>光栅显示器：一个像素矩阵</p><p>光栅图形都是具有多种颜色和灰度像素的集合，是实际图形的近似</p><h2 id="4-1-直线段的扫描转换算法"><a href="#4-1-直线段的扫描转换算法" class="headerlink" title="4.1 直线段的扫描转换算法"></a>4.1 直线段的扫描转换算法</h2><p><strong>（画直线的三个算法轮流考，中点画线法和Bresenham算法一定要写出递推的优化算法）</strong></p><h3 id="数值微分（DDA）法"><a href="#数值微分（DDA）法" class="headerlink" title="数值微分（DDA）法"></a>数值微分（DDA）法</h3><p>先根据两个端点坐标求出斜率k。</p><p>x一个像素一个像素地步进，计算y并取整。为了方便可以直接每次给y加斜率k。</p><p>k&gt;1时应将xy互换。需用浮点数。</p><h3 id="中点画线法"><a href="#中点画线法" class="headerlink" title="中点画线法"></a>中点画线法</h3><p>k在0到1之间，仍是x步进，y只有保持或者+1两种选项。根据直线离哪个更近来选，也就是在中点上方还是下方。</p><p>$F(x,y)=ax+by+c$  直线方程，判别式</p><p>$F(M)=F(x_p+1,y_p+0.5)=a(x_p+1)+b(y_p+0.5)+c$，结果小于0中点在下，选上面的点；结果大于0中点在上，选下面的点；等于零约定选下方。</p><p>相邻的两个判别式有递推关系，增量只可能是$a$或$a+b$。判别式初值为$a+0.5b$，由于只使用判别式的符号，可以乘2摆脱小数。</p><p><strong>（中点画线法经常考简答题，写原理+伪代码+画图）</strong></p><h3 id="Bresenham算法"><a href="#Bresenham算法" class="headerlink" title="Bresenham算法"></a>Bresenham算法</h3><p>算直线与竖线交点到下一格的距离d，超过0.5就向上一格。</p><p>x每增加1，距离增加k，超过1就减1。</p><p>判别式e=d-0.5，和0比。可以乘2避免小数。</p><h2 id="4-2-圆弧的扫描转换算法"><a href="#4-2-圆弧的扫描转换算法" class="headerlink" title="4.2 圆弧的扫描转换算法"></a>4.2 圆弧的扫描转换算法</h2><p>圆的八对称性，只需要画1/8圆弧。</p><h3 id="简单方程产生圆弧"><a href="#简单方程产生圆弧" class="headerlink" title="简单方程产生圆弧"></a>简单方程产生圆弧</h3><p>利用其函数方程，直接离散计算</p><p>可以用笛卡尔坐标或极坐标</p><h3 id="中点画圆法"><a href="#中点画圆法" class="headerlink" title="中点画圆法"></a>中点画圆法</h3><p>x一次挪动一个像素，仍然只有两个候选的y。</p><p>判断中点是在圆内部还是外部。圆的方程，内部小于0，外部大于0。</p><p>$F(x,y)=x^2+y^2-R^2$，判别式$d=F(x_p+1,y_p-0.5)$，初值为$F(1,R-0.5)$。</p><p>仍旧可递推，增量为$2x_p+3$或$2(x_p-y_p)+5$</p><p><strong>(一般考中点画直线4分，中点画圆10分，要解释为什么伪代码的增量是上式)</strong></p><h3 id="圆的Bresenham算法"><a href="#圆的Bresenham算法" class="headerlink" title="圆的Bresenham算法"></a>圆的Bresenham算法</h3><p>$d_1=y_i^2-y^2$，$d_2=y^2-(y_i-1)^2$</p><p>$y=r^2-(x_i+1)^2$</p><p>判别式$p_i=d_1-d_2$，初值$x_i=0,y_i=r$可得$p_1=3-2r$，也可以算递推式。</p><h3 id="椭圆的中点画线法"><a href="#椭圆的中点画线法" class="headerlink" title="椭圆的中点画线法"></a>椭圆的中点画线法</h3><p>$F(x,y)=b^2x^2+a^2y^2-a^2b^2=0$</p><p>法向量$2b^2xi+2a^2yj$</p><p>不能八对称，只能四对称，所以要根据法向量将1/4圆弧分为两部分，决定是步进x还是y。</p><p><strong>（因为计算量太大只考过一次）</strong></p><h2 id="4-3-多边形填充"><a href="#4-3-多边形填充" class="headerlink" title="4.3 多边形填充"></a>4.3 多边形填充</h2><h3 id="多边形表示方法"><a href="#多边形表示方法" class="headerlink" title="多边形表示方法"></a>多边形表示方法</h3><p>顶点表示：直观，几何意义强，占内存小，易于变换，不能直接用于面着色</p><p>点阵表示：丢失几何信息，便于帧缓冲器表示图形，是面着色需要的表示形式</p><h3 id="扫描线算法"><a href="#扫描线算法" class="headerlink" title="扫描线算法"></a>扫描线算法</h3><p>一条扫描线的转换步骤：求交、排序、配对、着色</p><p>活性边表(AET：$x,\Delta x,y_{max}$)：与当前扫描线相交的边按x坐标递增顺序存放的链表。</p><p>新边表(NET)：存放在每一条扫描线新出现的边，即将边存入较低端点对应扫描线的NET</p><p>要下端点不要上端点，每条边在下端点处加入活性边表，在上端点处从活性边表删除。</p><p><strong>（考过好几次。给图形，写出活性边表的迭代过程，还要写出扫描线的四个转换步骤。可能也要写伪代码，或解释活性边表项的内容）</strong></p><h3 id="边界标志算法"><a href="#边界标志算法" class="headerlink" title="边界标志算法"></a>边界标志算法</h3><p>在帧缓冲器中对边界经过的像素打上标志，然后对每行循环每个像素填充颜色</p><p>简单暴力，计算量大，适合硬件实现</p><p>对多边形形状没有要求</p><h3 id="种子填充算法"><a href="#种子填充算法" class="headerlink" title="种子填充算法"></a>种子填充算法</h3><p>四联通/八联通的搜索，边界一种颜色，内部一种颜色</p><p>要求填充区域是联通的</p><p>原理简单，递归费时费内存，效率不高</p><h3 id="种子填充的扫描线算法"><a href="#种子填充的扫描线算法" class="headerlink" title="种子填充的扫描线算法"></a>种子填充的扫描线算法</h3><p>从种子点向左右填充，再从两端向上下找未填充像素作为种子压栈</p><p>每个区间只需入栈一次</p><h2 id="4-4-字符的生成"><a href="#4-4-字符的生成" class="headerlink" title="4.4 字符的生成"></a>4.4 字符的生成</h2><h3 id="字符表达"><a href="#字符表达" class="headerlink" title="字符表达"></a>字符表达</h3><p>美国信息交换标准代码集ASCII码</p><p>汉字编码国家标准字符集GB2312-80</p><p>字符最高位 0表示ASCII码，1表示汉字编码</p><p>字符表达和生成：</p><ul><li>点阵式：硬件操作快，可以加粗、旋转90度、斜体、比例缩放等，任意角度旋转比较困难<ul><li>黑白段压缩法：简单，还原快，不失真，压缩较差，使用不方便，用于低级文字处理系统</li><li>部件压缩法：压缩比大，字型质量不能保证</li><li>轮廓字型法：压缩比大，能保证质量，符合工业标准化方法<ul><li>采用直线或二/三次贝塞尔曲线的集合来描述一个字符的轮廓线，加上指示横宽、竖宽、基点、基线等的控制信息，采用适当的区域填充算法</li><li>TrueType轮廓字型技术由Apple和Microsoft联合开发。</li><li>占领主要电子印刷市场的是北大方正激光照排系统。</li></ul></li></ul></li><li>矢量式：存储空间小，美观，变换方便</li><li>方向式：右为0，逆时针8方向编码；容易填入帧缓存寄存器显示，所占空间小，易放大缩小或45度旋转，但难以进行任意角度的旋转</li></ul><h2 id="4-5-裁剪"><a href="#4-5-裁剪" class="headerlink" title="4.5 裁剪"></a>4.5 裁剪</h2><p>一般先裁剪再扫描转换</p><h3 id="直线段裁剪"><a href="#直线段裁剪" class="headerlink" title="直线段裁剪"></a>直线段裁剪</h3><ul><li>Cohen-Sutherland裁剪算法：九个区域，上下右左四位编码。全为0则在窗口内。端点取与看是否有1，有则完全在窗口外。否则将线段与对应窗口边界求交点，舍弃线段在区域外的部分</li><li>中点分割裁剪算法：在上述算法中用中点分割算法求交，适合硬件实现和并行计算</li><li>梁友栋-Barskey算法：源于线段的两点式，将线段不等式改写为$up_k\le q_k$。<ul><li>$p_k=0$且$p_j&lt;0$，线段在外</li><li>否则$p_k&lt;0$，线段从外到内；$p_k&gt;0$，线段从内到外。</li><li>对每个$k$，交点的$u=q_k/p_k$。$p&lt;0$中取最大的$u$作为$u_1$（与0取max），$p&gt;0$中取最小作为$u_2$（与1取min），$u_1&gt;u_2$则线段完全落在裁剪窗口外</li></ul></li></ul><h3 id="多边形裁剪"><a href="#多边形裁剪" class="headerlink" title="多边形裁剪"></a>多边形裁剪</h3><p>Sutherland-Hodgeman算法：每次用窗口的一条边裁剪多边形，依次将多边形各边视为有向边考虑：如果窗口和边有交点，留交点；如果终点可见，留终点。将输出的所有点连接起来。</p><h3 id="字符串裁剪"><a href="#字符串裁剪" class="headerlink" title="字符串裁剪"></a>字符串裁剪</h3><p>字符串精度裁剪（外包盒box与窗边值比较），字符精度裁剪（逐个测量字符的box），像素精密裁剪（对部分留的字符每一笔划用直线剪裁法）</p><p><strong>（经常考，给出字符，画出三种裁剪的结果）</strong></p><h2 id="4-6-反走样"><a href="#4-6-反走样" class="headerlink" title="4.6 反走样"></a>4.6 反走样</h2><p>走样：用离散量表示连续量引起的失真现象，直线段或图形边界呈锯齿状</p><p>光栅图形走样现象：阶梯状的边界，图形细节失真、狭小图形遗失</p><h3 id="提高分辨率"><a href="#提高分辨率" class="headerlink" title="提高分辨率"></a>提高分辨率</h3><p>依靠硬件设施，简单但不经济</p><h3 id="区域采样"><a href="#区域采样" class="headerlink" title="区域采样"></a>区域采样</h3><p>假定像素是一个具有一定面积的小区域，根据直线与像素相交面积决定亮度</p><p>面积可以用离散估计的方法</p><p>加权区域采样：给像素每个区域加权  中间权重大 124</p><p><strong>（区域采样很可能考简答题）</strong></p><h1 id="五、曲线与曲面"><a href="#五、曲线与曲面" class="headerlink" title="五、曲线与曲面"></a>五、曲线与曲面</h1><p><strong>（第五章占40分左右）</strong></p><h3 id="曲线和曲面的发展历史"><a href="#曲线和曲面的发展历史" class="headerlink" title="曲线和曲面的发展历史"></a>曲线和曲面的发展历史</h3><p>1963 波音公司的Ferguson引入参数三次曲线</p><p>1964 MIT的Coons用封闭曲线的四条边界定义一张曲面</p><p>1971 雷诺汽车公司的Bezier发明了控制多边形定义曲线和曲面的方法。同年雪铁龙汽车公司的德卡斯特里奥也独立研发了类似的方法。</p><p>1972 德布尔给出了B样条的标准计算方法</p><p>1974 美国通用汽车公司的戈登和里森菲尔德提出了B样条曲线和曲面</p><h2 id="5-1-曲线曲面参数表示的基础知识"><a href="#5-1-曲线曲面参数表示的基础知识" class="headerlink" title="5.1 曲线曲面参数表示的基础知识"></a>5.1 曲线曲面参数表示的基础知识</h2><p>非参数表示：显式表示 隐式表示 </p><p>参数表示：可以满足几何不变性的要求，自由度更大，易于用矢量和矩阵运算，便于向高维空间扩展</p><h3 id="位置矢量-切矢量-法矢量"><a href="#位置矢量-切矢量-法矢量" class="headerlink" title="位置矢量 切矢量 法矢量"></a>位置矢量 切矢量 法矢量</h3><p>位置矢量</p><p>切矢量  $T=P’(t)/|P’(t)|$</p><p>法矢量</p><ul><li>主法矢$N=B*T$  副法矢$B=\frac{P’(t)*P’’(t)}{|P’(t)*P’’(t)|}$</li><li>法平面 T=NxB  密切平面  B=TxN   从切/化直平面 N=BxT</li></ul><h3 id="曲率和挠率"><a href="#曲率和挠率" class="headerlink" title="曲率和挠率"></a>曲率和挠率</h3><p>曲率：T的夹角比弧长，衡量弧的弯曲程度，越大越弯 $k=|P’(t)*P’’(t)|/|P’(t)^3|$</p><p>曲率半径：曲率的倒数</p><p>挠率：副法矢量的夹角比弧长，衡量曲线是否保持在一个平面里</p><p><strong>(以上五个量对计算和推导过程都不要求，选择题可能考概念)</strong></p><h3 id="参数曲面的定义"><a href="#参数曲面的定义" class="headerlink" title="参数曲面的定义"></a>参数曲面的定义</h3><p>参数曲面片，角点，边界线，切矢，偏导矢，跨界切矢，扭矢</p><p>球面写法</p><p>双三次参数曲面的代数形式</p><p>简单回转面：一条由$[x(u),z(u)]$定义的曲线绕z轴旋转</p><p>直纹面（动直线）：单叶双曲面，双曲抛物线（马鞍面），切线曲面</p><p><strong>（给出几种曲面的图，要能选出它的名称）</strong></p><h3 id="插值-逼近-拟合-光顺"><a href="#插值-逼近-拟合-光顺" class="headerlink" title="插值 逼近 拟合 光顺"></a>插值 逼近 拟合 光顺</h3><p><strong>（70-80%的概率会考）</strong></p><p>插值：构造曲线顺序通过给出的有序数据点（线性插值，二次插值）<strong>（要会计算）</strong></p><p>逼近：不一定经过已知点，用最小二乘法判定<strong>（要写出差的平方和、偏导为0）</strong></p><p>拟合：统称插值或逼近</p><p>光顺：拐点（导数变号）不能太多，要求曲率变化较小，具有二阶几何连续性</p><h3 id="参数化"><a href="#参数化" class="headerlink" title="参数化"></a>参数化</h3><p>对型值点参数化</p><p>均匀参数化</p><p>累加弦长参数化</p><p>向心参数化法</p><p>修正弦长参数化法</p><p>参数区间的规格化</p><h3 id="参数曲线的代数和几何形式"><a href="#参数曲线的代数和几何形式" class="headerlink" title="参数曲线的代数和几何形式"></a>参数曲线的代数和几何形式</h3><p><strong>（很可能考，要现场算并粗略地画出调和函数的形状，6分简答题）</strong></p><p>用$P(0),P(1),P’(0),P’(1)$表示出参数$a_0、a_1、a_2、a_3$，把代数形式改写为几何形式</p><p>$F_0、F_1、G_0、G_1$称为调和函数，也即几何形式中$P_0、P_1、P’_0、P’_1$的系数</p><p>调和函数的性质：$F_i(j)=G’<em>i(j)=\delta</em>{ij},F_i’(j)=G_i(j)=0$</p><h3 id="连续性"><a href="#连续性" class="headerlink" title="连续性"></a>连续性</h3><p><strong>（考简答题，要会写对应的式子）</strong></p><p>$G_0$连续和$C_0$连续：含义相同，表示两曲线在结合处位置连续 $Q(0)=P(1)$</p><p>$G_1$连续：$G_0$连续并有方向相同但大小不同切矢 $Q’(0)=aP’(1)\ \ a&gt;0$</p><p>$C_1$连续：$G_0$连续且切矢方向大小均相同 $Q’(0)=P’(1)$</p><p>$G_2$连续：$G_1$连续且有同向曲率矢 $P’(1)*P’’(1)/|P’(1)|^3=Q’(0)*Q’’(0)/|Q’(0)|^3$</p><p>$C_2$连续：$G_1$连续且有相同曲率矢 $Q’’(0)=\alpha^2P’’(1)+\beta P’(1), \alpha=1,\beta=0$</p><h2 id="5-2-Bezier曲线与曲面"><a href="#5-2-Bezier曲线与曲面" class="headerlink" title="5.2 Bezier曲线与曲面"></a>5.2 Bezier曲线与曲面</h2><p><strong>（Bezier和B样条是最重要的两节，据说各至少占20分）</strong></p><h3 id="Bezier曲线的定义和性质"><a href="#Bezier曲线的定义和性质" class="headerlink" title="Bezier曲线的定义和性质"></a>Bezier曲线的定义和性质</h3><p>由一系列控制点（折线集/Bezier特征多边形）来定义</p><p>Bezier曲线起点、终点与多边形重合，起点与终点的切线方向和特征多边形第一条边及最后一条边的走向一致</p><p>各点坐标的插值公式：$p(t)=\sum_{i=0}^nP_iB_{i,n}(t)$，相当于特征多边形的顶点加权求和</p><p>Bernstein基函数：$B_{i,n}(t)=C_n^it^i(1-t)^{n-i}$</p><h3 id="Bernstein基函数的性质"><a href="#Bernstein基函数的性质" class="headerlink" title="Bernstein基函数的性质"></a>Bernstein基函数的性质</h3><p><strong>（要求能现场推导）</strong></p><p>正性：在端点为0，在其他点为正</p><p><strong>端点性质</strong>：$B_{i,n}(0)$在$i=0$时为1，其他值都为0；$B_{i,n}(1)$在$i=n$时为1，其他值都为0，表示Bezier曲线的两端只与特征多边形的端点有关</p><p>权性：由二项式定理，对某个给定的$t$，枚举所有$i$，所有基函数加和恒为1</p><p>对称性：$B_{i,n}(t)=B_{n-i,n}(1-t)$</p><p>递推性：$B_{i,n}(t)=(1-t)B_{i,n-1}(t)+tB_{i-1,n-1}(t)$</p><p><strong>导函数</strong>：$B’<em>{i,n}(t)=n[B</em>{i-1,n-1}(t)-B_{i,n-1}(t)]$</p><p>最大值：$t=i/n$处达到最大值</p><p>升阶公式、积分</p><h3 id="Bezier曲线的性质"><a href="#Bezier曲线的性质" class="headerlink" title="Bezier曲线的性质"></a>Bezier曲线的性质</h3><p><strong>端点性质</strong>：Bezier曲线的起点、终点与特征多边形的起点、终点重合</p><p><strong>一阶导矢与切矢量</strong>：$P’(t)=n\sum_{i=0}^nP_i[B_{i-1,n-1}(t)-B_{i,n-1}(t)]$，所以$P’(0)=n(P_1-P_0)$，$P’(1)=n(P_n-P_{n-1})$，Bezier曲线起点和终点处的切线方向与特征多边形第一条边和最后一条边走向一致</p><p>二阶导矢与曲率：$P’’(t)=n(n-1)\sum_{i=0}^{n-2}(P_{i+2}-2P_{i+1}+P_i)B_{i,n-2}(t)$，r阶导矢只与r+1个相邻点有关</p><p>k阶导可差分递推</p><p>对称性：说明Bezier曲线的形状只依赖于控制点</p><p>凸包性：Bezier曲线落在控制点构成的凸包中</p><p>坐标不变性、仿射不变性</p><p>变差缩减性：平面内任意直线与Bezier曲线的交点个数不多于直线与特征多边形的交点个数，反映曲线比特征多边形波动小，更光顺</p><h3 id="Bezier曲线的矩阵表示"><a href="#Bezier曲线的矩阵表示" class="headerlink" title="Bezier曲线的矩阵表示"></a>Bezier曲线的矩阵表示</h3><p><strong>（一次二次要求计算，三次不要求）</strong></p><p>先用代数形式求出C(t)，再用矩阵表示</p><p>一次曲线是连接起点和终点的直线段</p><p>二次曲线是起点在P0终点在P2的抛物线</p><p>工程中常用的是二、三次的Bezier曲线</p><h3 id="Bezier曲线的递推算法"><a href="#Bezier曲线的递推算法" class="headerlink" title="Bezier曲线的递推算法"></a>Bezier曲线的递推算法</h3><p>抛物线三切线定理</p><p>n次Bezier曲线可以由两个n-1次Bezier曲线求出</p><p>$P_i^k(t)=(1-t)P_i^{k-1}(t)+tP_{i+1}^{k-1}(t)$</p><p>几何作图实现（此处看PPT的76页的图容易理解）</p><p><strong>（考试给出t，要求画图）</strong></p><h3 id="Bezier曲线的拼接"><a href="#Bezier曲线的拼接" class="headerlink" title="Bezier曲线的拼接"></a>Bezier曲线的拼接</h3><p>连接处三点共线达到$G_1$连续，$a=1$则$C_1$连续</p><p>满足上述条件且连接处五点共面则$G_2$连续，$a=1,\beta = 0$则$C_2$连续</p><h3 id="Bezier曲线的升阶与降阶"><a href="#Bezier曲线的升阶与降阶" class="headerlink" title="Bezier曲线的升阶与降阶"></a>Bezier曲线的升阶与降阶</h3><h3 id="Bezier曲面"><a href="#Bezier曲面" class="headerlink" title="Bezier曲面"></a>Bezier曲面</h3><h2 id="5-3-B样条曲线"><a href="#5-3-B样条曲线" class="headerlink" title="5.3 B样条曲线"></a>5.3 B样条曲线</h2><p>Bezier曲线的不足：没有局部性，拼接较复杂</p><h3 id="B样条曲线方程的定义和性质"><a href="#B样条曲线方程的定义和性质" class="headerlink" title="B样条曲线方程的定义和性质"></a>B样条曲线方程的定义和性质</h3><p>$P(t)=\sum_{i=0}^nP_iN_{i,k}(t)$</p><p>$N_{i,k}(t)$称为$k$阶B样条基函数（调和函数），采取递推定义</p><p>每个B样条只和支撑区间内的节点有关</p><h3 id="B样条基函数的性质"><a href="#B样条基函数的性质" class="headerlink" title="B样条基函数的性质"></a>B样条基函数的性质</h3><p>局部支撑性：$N_{i,k}(t)$只在$[t_i,t_{i+k}]$区间内大于等于0</p><p>权性</p><h3 id="B样条曲线类型的划分"><a href="#B样条曲线类型的划分" class="headerlink" title="B样条曲线类型的划分"></a>B样条曲线类型的划分</h3><p>开曲线，闭曲线（周期闭曲线，非周期闭曲线）</p><p><strong>均匀B样条曲线</strong>，准均匀的B样条曲线，分段Bezier曲线，非均匀B样条曲线</p><h3 id="B样条曲线的性质"><a href="#B样条曲线的性质" class="headerlink" title="B样条曲线的性质"></a>B样条曲线的性质</h3><p><strong>局部性</strong></p><p>连续性</p><p>凸包性，变差缩减性</p><p>分段参数多项式，导数公式</p><p>几何不变性，仿射不变性</p><p>直线保持性</p><p>造型灵活性</p><h3 id="均匀B样条曲线的矩阵表示"><a href="#均匀B样条曲线的矩阵表示" class="headerlink" title="均匀B样条曲线的矩阵表示"></a>均匀B样条曲线的矩阵表示</h3><p><strong>（要求算二次曲线，给出矩阵，乘开带入求端点、一二阶导并绘图，15分）</strong></p><p><strong>（三次B样条也考过，比较麻烦。指望现场算不如背结论了）</strong></p><p>二次B样条：端点在第一条边中点；端点处切线（一阶导）与边矢量重合，节点处一阶导连续；曲线的二阶导矢量等于前两条边矢量形成的对角线矢量</p><p>三次B样条：端点在前两边夹对角线的1/6处；一阶导矢量平行1、3点之间矢量且模长为一半，节点处一阶导相同；二阶导矢量等于前两条边矢量形成的对角线矢量，二阶导连续</p><h3 id="de-Boor算法"><a href="#de-Boor算法" class="headerlink" title="de Boor算法"></a>de Boor算法</h3><p>递推B样条基函数，割角</p><p><strong>（给出递推公式，考画递推三角形和画示意图）</strong></p><h3 id="节点插入算法"><a href="#节点插入算法" class="headerlink" title="节点插入算法"></a>节点插入算法</h3><h3 id="B样条曲面"><a href="#B样条曲面" class="headerlink" title="B样条曲面"></a>B样条曲面</h3><p><strong>（考试没什么考的）</strong></p><h2 id="5-4-NURBS曲线与曲面"><a href="#5-4-NURBS曲线与曲面" class="headerlink" title="5.4 NURBS曲线与曲面"></a>5.4 NURBS曲线与曲面</h2><p>B样条曲线适于设计自由型曲线，但是不适于设计初等曲线</p><p>NURBS是非均匀有理B样条方法，在B样条的基础上增加了一个吸引力权重</p><p>性质和B样条曲线类似，只有一些权重相关的新性质</p><p>NURBS可表示圆锥曲线，$w_1^2/(w_0w_2)$为形状因子，0为直线段，0到1之间为椭圆，1为抛物线，大于1为双曲线</p><p><strong>（要把形状因子的大小和图形对应起来）</strong></p><h2 id="5-5-Coons曲面"><a href="#5-5-Coons曲面" class="headerlink" title="5.5 Coons曲面"></a>5.5 Coons曲面</h2><p>构造插值曲面，先定边界</p><h3 id="双线性Coons曲面"><a href="#双线性Coons曲面" class="headerlink" title="双线性Coons曲面"></a>双线性Coons曲面</h3><p>给定四条在空间围成封闭曲边四边形的参数曲线</p><p>从两个方向插值出两个直纹面，再以两条直线段为边界构造直纹面</p><p>$P(u,v)=P_1(u,v)+P_2(u,v)-P_3(u,v)$</p><p><strong>(考了很多次，给出图，写P1、P2、P3和矩阵，10分)</strong></p><h3 id="双三次Coons曲面"><a href="#双三次Coons曲面" class="headerlink" title="双三次Coons曲面"></a>双三次Coons曲面</h3><p>构造光滑的Coons曲面，给点边界的跨界切矢</p><p><strong>（之前没考过，今年可能考，写出P1和P2）</strong></p><h1 id="六、图形变换"><a href="#六、图形变换" class="headerlink" title="六、图形变换"></a>六、图形变换</h1><h2 id="6-1-数学基础"><a href="#6-1-数学基础" class="headerlink" title="6.1 数学基础"></a>6.1 数学基础</h2><h2 id="6-2-几何变换"><a href="#6-2-几何变换" class="headerlink" title="6.2 几何变换"></a>6.2 几何变换</h2><p>窗口区到视图区的坐标变换</p><p>二维齐次坐标变换</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">缩放<span class="hljs-regexp">/旋转/</span>对称/错切  平移 <br>投影               整体缩放  <br></code></pre></td></tr></table></figure><p><strong>（经常考错切）</strong></p><p>三维齐次坐标变换</p><p><strong>（经常考绕空间中任意轴旋转）</strong></p><h2 id="6-3-图形的投影变换"><a href="#6-3-图形的投影变换" class="headerlink" title="6.3 图形的投影变换"></a>6.3 图形的投影变换</h2><p>三视图，正平行投影</p><p><strong>（画三视图考过简答题）</strong></p><p>斜平行投影</p><p><strong>（给图片，算斜平行投影公式）</strong></p><p>透视：一点透视投影，两点透视投影，三点透视投影</p><h1 id="七、真实感图形学-消隐"><a href="#七、真实感图形学-消隐" class="headerlink" title="七、真实感图形学-消隐"></a>七、真实感图形学-消隐</h1><p><strong>（每年考试都有一道题，10分）</strong></p><h3 id="消除隐藏线"><a href="#消除隐藏线" class="headerlink" title="消除隐藏线"></a>消除隐藏线</h3><h3 id="消除隐藏面"><a href="#消除隐藏面" class="headerlink" title="消除隐藏面"></a>消除隐藏面</h3><p>V*N&lt;0 前向面</p><p>V*N&gt;0 后向面</p><p>画家算法（列表优先算法）</p><h3 id="检验深度优先级表中相邻面的顺序"><a href="#检验深度优先级表中相邻面的顺序" class="headerlink" title="检验深度优先级表中相邻面的顺序"></a>检验深度优先级表中相邻面的顺序</h3><p>深度重叠判断，投影重叠判断</p><h3 id="Z缓冲区算法"><a href="#Z缓冲区算法" class="headerlink" title="Z缓冲区算法"></a>Z缓冲区算法</h3><p>不断刷新每个像素的颜色和深度</p><p>简单，但是占用空间非常大</p><p>每个像素的深度可以用增量方法加速</p><h3 id="区间扫描线算法"><a href="#区间扫描线算法" class="headerlink" title="区间扫描线算法"></a>区间扫描线算法</h3><p>按扫描线来处理</p><h3 id="区域子分割算法"><a href="#区域子分割算法" class="headerlink" title="区域子分割算法"></a>区域子分割算法</h3><p>分割到至多只有一个多边形在最前方</p><p>转角检查法 ，正负8说明多边形包含窗口，0说明分离</p><h3 id="光线投射算法"><a href="#光线投射算法" class="headerlink" title="光线投射算法"></a>光线投射算法</h3><p>对屏幕上每个像素，投出射线与每个物体求交，显示最近交点所属颜色的像素</p><h1 id="八、虚拟现实技术简介"><a href="#八、虚拟现实技术简介" class="headerlink" title="八、虚拟现实技术简介"></a>八、虚拟现实技术简介</h1><p><strong>（八九章基本不考）</strong></p><h1 id="九、OpenGL图形开发环境-DierctX概述"><a href="#九、OpenGL图形开发环境-DierctX概述" class="headerlink" title="九、OpenGL图形开发环境+DierctX概述"></a>九、OpenGL图形开发环境+DierctX概述</h1>]]></content>
    
    
    <categories>
      
      <category>CG</category>
      
    </categories>
    
    
    <tags>
      
      <tag>孙若诗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据挖掘笔记</title>
    <link href="/AcceptedHelper/2021/12/03/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AC%94%E8%AE%B0/"/>
    <url>/AcceptedHelper/2021/12/03/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="数据挖掘笔记"><a href="#数据挖掘笔记" class="headerlink" title="数据挖掘笔记"></a>数据挖掘笔记</h1><h2 id="习题课"><a href="#习题课" class="headerlink" title="习题课"></a>习题课</h2><ol><li>盒图：五数概括不用判定离群点，盒图要判定离群点</li><li>中位数概括宽度不用+1</li><li>OLAP基础操作 专有名词</li><li>15选择（1分）+5填空（2分）+4大题</li><li>upd：<strong>20-21春学期期末</strong><ul><li>大题考了用基尼系数做朴素贝叶斯概率、频繁模式挖掘、k近邻聚类、神经网络参数计算（求导大法）。确实都是作业出现过的题型，但是数不好算，聚类和基尼系数要按的计算器太多了。老师最后开始频繁催“算不出来数没关系，写对公式就给绝大部分分；写不出来公式写算法，至少写点东西好给分”。</li><li>前几章的计算只考了小题，比如算卡方、选正确的盒图。</li><li>小题里有概念题，比如写出三种集成学习算法。</li></ul></li><li>不挂人但是也不保B+，作业/PJ/期末考三部分占比未知</li></ol><h2 id="第一章-引论"><a href="#第一章-引论" class="headerlink" title="第一章 引论"></a>第一章 引论</h2><p>数据挖掘/KDD：从大量数据中挖掘有趣模式和知识的过程，通常包括数据清理、数据集成、数据选择、数据变换、模式发现、模式评估、知识表示。</p><h3 id="挖掘的对象"><a href="#挖掘的对象" class="headerlink" title="挖掘的对象"></a>挖掘的对象</h3><ol><li>关系数据库：表的汇集，有实体-联系（<strong>ER</strong>）等数据模型</li><li>数据仓库：从多个数据源收集的信息存储库，存放在一致的模式下，通常驻留在单个站点上。围绕主题组织，从历史的角度提供信息，通常是汇总的。用<strong>数据立方体</strong>建模。</li><li>事务数据：挖掘频繁项集</li></ol><h3 id="数据挖掘功能"><a href="#数据挖掘功能" class="headerlink" title="数据挖掘功能"></a>数据挖掘功能</h3><ol><li>类/概念描述：特征化与区分</li><li>挖掘频繁模式、关联和相关性</li><li>用于预测分析的分类与回归</li><li>聚类分析</li><li>离群点分析</li></ol><h2 id="第二章-认识数据"><a href="#第二章-认识数据" class="headerlink" title="第二章 认识数据"></a>第二章 认识数据</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ol><li>数据对象用属性描述；属性表示数据对象的一个特征，同义词有属性（数据挖掘、数据库）、特征（机器学习）、变量（统计学）、维（数据仓库）。</li><li>标称属性：意味着“与名称相关”，值是一些符号或事物的名称，是分类的、枚举的、不定量、无序的。只有众数，没有其他数学运算（eg：颜色、编号、职业）。</li><li>二元/布尔属性：01的标称属性。若两种状态有同等价值且权重相同，称为对称的（eg：性别）；否则称为非对称的（eg：病毒阳性），一般将重要结果用1编码。</li><li>序数属性：可能的值之间具有意义的序或秩评定，但是相继值之间的差是未知的（eg：饮料大小杯、成绩等级、职位）。记录不能客观度量的主观质量评估，或通过把数值属性离散化得到。有众数和中位数，没有平均值。</li><li>数值属性：定量的可度量的量。区间标度属性用相等的单位尺度度量，可以做差，但是由于没有真正的零不能做商（eg：华氏温度、日期）；比率标度属性是具有固定零点的数值属性，可以做差和商（eg：开式温标、文档字数、速度）。数值属性都可以求众数、中位数、平均值。</li><li>总结：无序的只有众数、有序的可以求中位数、数值的可以做差和平均值、有零点的可以做商。</li><li>离散属性具有有限或无限可数个值（eg：头发颜色、顾客编号、邮政编码）；不离散的属性是连续属性（可与数值属性互换使用），一般用浮点变量表示。</li></ol><h3 id="数据的基本统计描述"><a href="#数据的基本统计描述" class="headerlink" title="数据的基本统计描述"></a>数据的基本统计描述</h3><ol><li>中心趋势度量<ul><li>均值/mean：算术均值/加权均值（对极端值很敏感）、截尾均值（丢弃高低极端值之后的均值）</li><li>中位数/median（对倾斜、非对称数据描述更好）：数据个数为偶数时，中位数不唯一，取中间两个值和它们之间的任意值；对于数值属性，约定取中间两个值的平均值。中位数的近似值。</li><li>众数/mode：根据众数个数将数据集合分为单峰的、双峰的、三峰的、多峰的（两个或更多个峰），N峰也称为N模。每个数据值只出现一次，则没有众数。</li><li>对于适度倾斜的单峰数值数据，有经验关系：$mean-mode \approx 3(mean-median)$</li><li>中列数/midrange：数据集最大和最小值的平均值。</li><li>完全对称的单峰频率曲线中，均值、中位数、众数都是相同的中心值。</li><li>正倾斜：众数小于中位数。反之则为负倾斜。</li></ul></li><li>数据散布度量<ul><li>极差/range：最大值与最小值之差</li><li>分位数/quantile：把数据划分成基本上大小相等的连贯集合，有$q-1$个q-分位数，第$k$个q-分位数是值$x$，小于$x$的数据值最多为$k/q$，大于$x$的数据值最多为$(q-k)/q$。2-分位数是中位数，四分位数依次为$Q_1$、$Q_2$、$Q_3$，又常用百分位数。</li><li>四分位数极差：$IQR=Q_3-Q_1$，给出被数据的中间一半覆盖的范围。</li><li>五数概括：最小观测值、$Q_1$、中位数、$Q_3$、<strong>最大观测值</strong>。</li><li>盒图：端点在四分位数上，长度是IQR，中位数用盒内的线标记，胡须延伸到最大最小观测值。若最大最小观测值距四分位数超过1.5IQR，胡须在距四分位数<strong>1.5IQR内最极端的观测值处</strong>终止，剩下的情况个别绘出。</li><li>方差：到均值距离的平方和的均值，或$(\frac{1}{N}\sum_{i=1}^{n}x_{i}^2)^2-\bar{x}^2$。标准差：方差的平方根，度量关于均值的发散。一个观测一般不会远离均值超过标准差的数倍，最少$(1-\frac{1}{k^2})*100%$的观测值离均值不超过k个标准差。</li></ul></li><li>基本统计描述的图形显示<ul><li>分位数图（观察单变量数据分布）：横轴为f值(i-0.5)/N，纵轴为观测值。</li><li>分位数-分位数图（观察两个分布之间是否有漂移）：横轴为一个观测值，纵轴为另一个观测值，每个点在两个数据集离对应的分位数相同。若两个观测集数据个数不同，以小的为准，需要在大的观测集里插值。</li><li>直方图：标称属性的直方图常被称为条形图。数值属性的直方图横轴为不相交的连续子域（桶/箱），通常是等宽的，纵轴为子域内数据的计数。</li><li>散点图（确定两个数值变量之间是否存在联系）：每个值对视为一个代数坐标对，作为一个点画在平面上。左下-右上暗示正相关，左上-右下暗示负相关。</li></ul></li></ol><h3 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h3><ol><li>基于像素的可视化技术：对每一维创建一个窗口。线性填充、空间填充曲线，圆弓分割技术。</li><li>几何投影可视化技术：散点图矩阵（随着维数增加变得不太有效）、平行坐标（视觉上的簇和重叠导致不能有效地显示具有很多记录的数据集）</li><li>基于图符的可视化技术：切尔诺夫脸（容易被用户消化，在表示多重联系的能力方面存在局限性，最多18维，眼睛大小和眉毛的歪斜是重要的）、非对称的切尔诺夫脸（达到36维）、人物线条画（两个维映射到显示轴，其他维映射到人物线条画，数据关于两个显示维相对稠密则结果显示纹理模式）。</li><li>层次可视化技术：世界中的世界（将部分维固定为选定的值，以这个值为原点绘制内世界三维图，在外世界三维图中改变原点位置观察内世界变化）、树图</li><li>可视化复杂对象和关系：标签云（用大小表示次数）、图</li></ol><h3 id="度量数据的差异性和相似性"><a href="#度量数据的差异性和相似性" class="headerlink" title="度量数据的差异性和相似性"></a>度量数据的差异性和相似性</h3><ol><li><p>数据矩阵/二模矩阵：对象-属性结构，n*p。每行对应一个对象，又称数据样本/特征向量。</p></li><li><p>相异性矩阵/单模矩阵：对象-对象结构，n*n，存放对象两两之间的邻近度，对称矩阵。对于标称数据，$sim(i,j)=1-d(i,j)$</p></li><li><p>标称属性的邻近性度量：$d(i,j)=\frac{p-m}{p}$，m可加权</p></li><li><p>二元属性的邻近性度量</p><ul><li>对称的二元相异性$d(i,j)=\frac{r+s}{q+r+s+t}$</li><li>非对称的二元相异性$d(i,j)=\frac{r+s}{q+r+s}$</li><li>非对称的二元相似性$sim(i,j)=\frac{q}{q+r+s}$，称为Jaccard系数。</li></ul></li><li><p>数值属性的相异性</p><ul><li>先对数据规范化，如变换到$[-1,1]$或$[0,1]$</li><li>欧几里得距离，加权的欧几里得距离</li><li>曼哈顿距离</li><li>度量：满足非负性、同一性、对称性、三角不等式</li><li>闵可夫斯基距离/$L_p$范数：各维距离的p次方之和，开p次方，p是不小于1的实数。$L_1$范数为曼哈顿距离，$L_2$范数为欧几里得距离。</li><li>上确界距离/$L_{max}$/$L_{∞}$范数/一致范数/切比雪夫距离：各维距离的最大值</li></ul></li><li><p>序数属性的邻近性度量：对于第$i$个对象，用对应排位$r_{if}$取代序数属性组$x_{if}$，将每个属性的值域映射到$[0,1]$，$z_{if}=\frac{r_{if}-1}{M_f-1}$，再对$z$使用数值属性的距离度量计算相异性</p></li><li><p>混合类型属性的相异性</p><ul><li>计算两者均不缺失的所有属性相异性并取平均数</li><li>数值属性$d_{ij}^{(f)}=\frac{|x_{if}-x_{jf}|}{max_hx_{hf}-min_hx_{hf}}$</li><li>序数属性计算$z$后按数值属性处理</li><li>标称属性$d$即为是否相等</li></ul></li><li><p>余弦相似性</p><ul><li>处理很长的、稀疏的向量，数据往往高度非对称（eg：信息检索、生物学分类）</li><li>$sim(x,y)=\frac{x*y}{||x||||y||}$，分母为两个向量欧几里得范数（即长度）之积</li><li>0代表两个向量正交，余弦值越小向量之间的匹配越大</li><li>不遵守度量测度性质，被称为非度量测度</li><li>二值属性的余弦相似性可以用共享特征或属性解释，分子是共同具有的属性数，分母是两个向量具有的属性数的几何均值，sim成为公共属性相对拥有的一种度量，$sim(i,j)=\frac{x<em>y}{x</em>x+y<em>y-x</em>y}$，称为Tanimoto系数或Tanimoto距离</li></ul></li></ol><h2 id="第三章-数据预处理"><a href="#第三章-数据预处理" class="headerlink" title="第三章 数据预处理"></a>第三章 数据预处理</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ol><li><p>数据质量的三个要素：准确性、完整性、一致性</p></li><li><p>影响数据质量的要素：时效性、可解释性、可信性</p></li><li><p>主要步骤：数据清理、数据集成、数据归约、数据变换</p></li></ol><h3 id="数据清理"><a href="#数据清理" class="headerlink" title="数据清理"></a>数据清理</h3><ol><li>缺失值</li><li>噪声数据：分箱、回归、离群点分析</li><li>偏差检测，数据变换两步的迭代过程</li><li>数据清洗工具，数据审计工具，数据迁移工具，ETL工具</li></ol><h3 id="数据集成"><a href="#数据集成" class="headerlink" title="数据集成"></a>数据集成</h3><ol><li>实体识别问题：使用元数据</li><li>冗余和相关分析<ul><li>标称数据的卡方检验：相依表中$o_{ij}$为联合事件观测频度，$e_{ij}$为期望频度，可用$e_{ij}=\frac{count(A=a_i)<em>count(B=b_j)}{n}$计算，卡方=$\sum_{i=1}^c\sum_{j=1}^r\frac{(o_{ij}-e_{ij})^2}{e_{ij}}$，对卡方贡献越大的单元实际计数与期望计数越不符。卡方检验假设A和B是独立的，具有自由度$(r-1)</em>(c-1)$，自由度和置信水平决定拒绝假设的值</li><li>数值数据的相关系数/Pearson积矩系数：$r_{A,B}=\frac{\sum_{i=1}^n(a_i-\bar A)(b_i-\bar B)}{n\sigma_A\sigma_B}=\frac{\sum_{i=1}^n(a_ib_i)-n\bar A\bar B}{n\sigma_A\sigma_B}$；r越接近1，正相关越强；越接近-1，负相关越强；r为0，A和B独立。相关性不蕴涵因果关系</li><li>数值数据的协方差：$Cov(A,B)=E((A-\bar A)(B-\bar B))=\frac{\sum_{i=1}^n(a_i-\bar A)(b_i-\bar B)}{n}=E(A*B)-\bar A\bar B=r_{A,B}\sigma_A\sigma_B$；协方差为正表示正相关，协方差为负表示负相关；A和B独立时协方差一定为0，但A和B不独立协方差也可能为0，只有当数据满足多元正态分布等限制条件时协方差为0才充分说明数据独立。方差是属性和自身的协方差</li></ul></li><li>元组重复</li><li>数据值冲突的检测与处理</li></ol><h3 id="数据归约"><a href="#数据归约" class="headerlink" title="数据归约"></a>数据归约</h3><ol><li>维归约：小波变换、主成分分析、属性子集选择、属性创建</li><li>数量归约：参数方法（回归、对数-线性模型）、非参数方法（直方图、聚类、抽样、数据立方体聚集）</li><li>数据压缩：有损的、无损的</li><li>离散小波变换（DWT）<ul><li>将数据向量X变换成不同的数值小波系数向量X’，变换后数据可以截短，仅存放一部分最强的小波系数，消除噪声</li><li>有损压缩，比DFT更准确，空间局部性好，对稀疏或倾斜数据和具有有序属性的数据效果好</li><li>层次金字塔算法：每次迭代数据减半，先后使用光滑和加权差分函数，得到两个长度为L/2的数据集，分别代表光滑后的版本或低频版本和它的高频内容</li><li>有若干族DWT，小波名后的数是小波的消失瞬间</li><li>将矩阵乘法用于输入数据，所用的矩阵必须是标准正交的</li><li>处理多维数据，首先将变换用于第一个维，然后第二个，复杂度关于立方体中单元的个数是线性的</li></ul></li><li>主成分分析/PCA<ul><li>搜索k个最能代表数据的n维正交向量，k&lt;=n</li><li>对输入数据规范化，计算k个标准正交向量（主成分），对主成分按重要性或强度降序排列，主成分本质上充当新坐标系，通过去掉较弱的成分（方差较小的那些）来规约数据</li><li>可用于有序和无序的属性，可以处理稀疏和倾斜数据，可以用做多元回归和聚类分析的输入</li><li>多于二维的多维数据可以通过将问题归约为二维问题来处理</li><li>小波变换更适合高维数据，PCA能够更好处理稀疏数据</li></ul></li><li>属性子集选择<ul><li>删除不相关或冗余属性，目标是找出最小属性集，使数据类的概率分布尽可能接近原分布</li><li>压缩搜索空间的启发式算法：贪心，取局部最优解</li><li>确定”最好/差的“属性：统计显著性检验/信息增益度量</li><li>具体技术：逐步向前选择、逐步向后删除、逐步向前选择和逐步向后删除的组合、决策树归纳</li></ul></li><li>回归和对数线性模型<ul><li>参数化数据归约</li><li>线性回归（最小二乘法求解回归系数）、多元回归</li><li>对数线性模型：近似离散的多维概率分布，基于维组合的一个较小子集估计多维空间中每个点的概率</li><li>都可以用于稀疏数据。回归对倾斜数据可望更好，对数线性模型对高维数据伸缩性好，可达10维</li></ul></li><li>直方图<ul><li>等宽直方图，等频/等深直方图</li><li>对于近似稀疏和稠密数据，以及高倾斜和均匀的数据，都是非常有效的</li><li>多维直方图可以表现属性间的依赖，能有效近似多达5个属性的数据</li><li>对于存放具有高频率的离群点，单值桶是有用的</li></ul></li><li>聚类<ul><li>直径：簇中两个对象的最大距离</li><li>形心距离：簇中每个对象到簇形心（平均对象/空间中的平均点）的平均距离</li><li>数据归约中用簇代表替换实际数据，对于能够组织成不同的簇的数据较为有用</li></ul></li><li>抽样<ul><li>s个样本的无放回简单随机抽样（SRSWOR）</li><li>s个样本的有放回简单随机抽样（SRSWR）</li><li>簇抽样：每次抽取一个簇</li><li>分层抽样：数据倾斜时可以帮助确保样本的代表性</li><li>得到样本的花费正比例于样本集的大小s，而不是数据集的大小N，因此复杂度亚线性于数据大小，仅根据数据的维数n线性增加</li><li>常用来估计聚集查询的回答，通过简单的增加样本大小可以进一步求精</li></ul></li><li>数据立方体聚集<ul><li>每个属性都可能存在概念分层，允许在多个抽象层进行数据分析</li><li>数据立方体提供对与计算的汇总数据进行快速访问，适合联机数据分析和数据挖掘</li><li>在最低抽象层创建的立方体称为基本方体，应当对应于感兴趣的个体实体</li><li>最高抽象层的立方体称为顶点方体</li><li>不同层创建的数据立方体称为方体，数据立方体可以看作方体的格</li><li>回答询问时使用与给定任务相关的最小可用方体</li></ul></li></ol><h3 id="数据变换与数据离散化"><a href="#数据变换与数据离散化" class="headerlink" title="数据变换与数据离散化"></a>数据变换与数据离散化</h3><ol><li>光滑：去掉数据中的噪声，包括分箱、回归和聚类</li><li>属性构造/特征构造：由给定属性创造新属性</li><li>聚集：一般用来维多个抽象层的数据分析构造数据立方体</li><li>规范化/标准化：把属性数据按比例缩放到特定小区间<ul><li>最小-最大规范化：$v_i’=\frac{v_i-min_A}{max_A-min_A}(max_A’-min_A’)+min_A’$，保持原始数据之间的联系，但新输入落在原始数据值域外可能越界</li><li>z分数规范化/z-score规范化/零均值规范化：$v_i’=\frac{v_i-\bar A}{\sigma_A}$，实际最大最小值未知或离群点左右了最小-最大规范化时是有用的。标准差可用均值绝对偏差$s_A$替换，对离群点更鲁棒</li><li>小数定标规范化：通过移动属性A的小数点位置进行规范化，$v_i’=\frac{v_i}{10^j}$，j是使得$max(|v_i’|)&lt;1$的最小整数</li><li>有必要保留规范化参数，以便将来的数据可以用一致的方式规范化</li></ul></li><li>离散化：将数值属性原始值用区间标签或概念标签替换<ul><li>监督的离散化和非监督的离散化：是否使用类信息</li><li>自顶向下离散化/分裂，自底向上离散化/合并</li><li>分箱离散化：等宽/等频分箱，用箱均值/中位数替换箱中的每个值，是非监督的离散化技术，对用户指定的箱个数和离群点很敏感</li><li>直方图离散化：非监督，可以递归地用于每个分区，自动产生多级概念分层，用预设概念层数或最小区间长度控制递归过程</li><li>聚类</li><li>决策树：监督的离散化，选择最小化熵的值作为划分点</li><li>相关分析离散化：监督的离散化，ChiMerge，自底向上递归找出具有最小卡方值的相邻区间并合并（对于精确的离散化，相对类频率在一个区间内应当完全一致）</li></ul></li><li>由标称数据产生概念分层：利用模式和属性值计数信息</li></ol><h2 id="第四章-数据仓库与联机分析处理"><a href="#第四章-数据仓库与联机分析处理" class="headerlink" title="第四章 数据仓库与联机分析处理"></a>第四章 数据仓库与联机分析处理</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>主要特征：面向主题的、集成的、时变的、非易失的</li><li>使用更新驱动而非查询驱动方法</li><li>操作数据库与数据仓库分离，OLTP和OLAP分离</li><li>OLAP系统面向市场（而非面向顾客），管理大量历史数据（而非当前数据），采用星形或雪花模型和面向主题的数据库设计（而非ER模型和面向应用的数据库设计），常常跨越数据库模式的多个版本，存放在多个存储介质上，大部分是只读操作</li><li>三层体系结构：底层是仓库数据库服务器，中间层是OLAP服务器，顶层是前端客户层</li><li>数据仓库模型：企业仓库，数据集市和虚拟仓库</li><li>数据提取、变换和装入</li><li>元数据库：关于数据的数据，应当持久存放和管理（即存放在磁盘上）</li></ol><h3 id="数据立方体与OLAP"><a href="#数据立方体与OLAP" class="headerlink" title="数据立方体与OLAP"></a>数据立方体与OLAP</h3><ol><li>数据立方体由维和事实定义，是n维的</li><li>数据立方体称作方体。给定维的集合，可以对给定诸维的每个子集产生一个方体，结果形成方体的格，称作数据立方体。存放最低层汇总的方体称作基本方体，最高层汇总的方体称作顶点方体。</li><li>多维数据模型<ul><li>星形模式：一个事实表+一组维表</li><li>雪花模式：在星形模式的基础上将某些维表规范化</li><li>星系模式/事实星座：多个事实表共享维表</li><li>数据仓库通常使用事实星座模式，数据集市流行采用星形或雪花模式</li></ul></li><li>概念分层<ul><li>模式分层：形成数据库模式中属性的全序或偏序的概念分层</li><li>集合分组分层：将给定维或属性的值离散化或分组</li></ul></li><li>度量的分类和计算<ul><li>数据立方体度量是一个数值函数，可以对数据立方体空间的每个点求值，通过对给定点的各维-值对聚集数据，计算该点的度量值</li><li>度量分类：分布的（可以划分计算，eg：sum、count、min）、代数的（可以由多个划分计算的结果得到，eg：avg、min_N)、整体的（描述子聚集所需的存储没有常数界，eg：median、mode、rank）</li></ul></li><li>典型的OLAP操作<ul><li>上卷（roll-up）/上钻（drill-up）：通过沿一个维的概念分层向上攀升，泛化</li><li>下钻（drill-down）：通过沿一个维的概念分层向下或引入附加的维，特殊化</li><li>切片（slice）：在一个维进行选择</li><li>切块（dice）：在两个或多个维进行选择</li><li>转轴（pivot）/旋转（rotate）：转动数据视角</li><li>钻过（drill-across）：执行涉及多个事实表的查询</li><li>钻透（drill-through）：使用关系SQL机制钻透到后端关系表</li></ul></li><li>星网模型：由从中心点发出的射线组成，其中每一条射线代表一个维的概念分层，概念分层上的每个”抽象级“称为一个足迹，代表 OLAP操作可用的粒度</li></ol><h3 id="数据仓库的设计与使用"><a href="#数据仓库的设计与使用" class="headerlink" title="数据仓库的设计与使用"></a>数据仓库的设计与使用</h3><ol><li>商务分析框架：自顶向下视图、数据源视图、数据仓库视图、商务查询视图</li><li>开发方法：瀑布式方法、螺旋式方法</li><li>数据仓库应用：信息处理、分析处理、数据挖掘</li><li>多维数据挖掘/探索式多维数据挖掘/联机分析挖掘/OLAM</li></ol><h3 id="数据仓库的实现"><a href="#数据仓库的实现" class="headerlink" title="数据仓库的实现"></a>数据仓库的实现</h3><ol><li>compute cube：在操作指定的维的所有子集上计算聚集</li><li>维灾难：n维方体总数=$\prod_{i=1}^n(L_i+1)$</li><li>不物化、完全物化、部分物化</li><li>冰山立方体：只存放聚集值大于某个最小支持度阈值的立方体单元</li><li>外壳立方体</li><li>位图索引，连接索引，复合连接索引，位图连接索引</li><li>关系OLAP（ROLAP）服务器：伸缩性好，映射到关系操作；多维OLAP（MOLAP）服务器：适用稠密子立方体，映射到数组结构；混合OLAP（HOLAP）服务器；特殊的SQL服务器</li></ol><h3 id="数据泛化：面向属性的归纳"><a href="#数据泛化：面向属性的归纳" class="headerlink" title="数据泛化：面向属性的归纳"></a>数据泛化：面向属性的归纳</h3><ol><li>属性删除：某个属性有大量不同值但没有泛化操作符，或较高层概念用其他属性表示</li><li>属性泛化：某个属性有大量不同值且存在泛化操作符</li><li>属性泛化控制：属性泛化阈值控制、广义关系阈值控制</li><li>面向属性归纳：关系查询-收集初始关系上的统计量-导出主关系P</li><li>类比较：数据收集-维相关分析-同步泛化-导出比较的表示</li></ol><h2 id="第五章-数据立方体技术"><a href="#第五章-数据立方体技术" class="headerlink" title="第五章 数据立方体技术"></a>第五章 数据立方体技术</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>基本方体的单元是基本单元，非基本方体的单元是聚集单元</li><li>祖先和后代单元，父母和子女单元</li><li>闭覆盖：一个单元c是闭单元，如果不存在后代d与c有相同的度量值；闭立方体是只由闭单元组成的数据立方体</li><li>立方体外壳，外壳片段</li><li>优化技术：散列、排序、分组、同时聚集和缓存中间结果、由最小的子女聚集、先验剪枝</li></ol><h3 id="数据立方体计算方法"><a href="#数据立方体计算方法" class="headerlink" title="数据立方体计算方法"></a>数据立方体计算方法</h3><ol><li>多路数组聚集（MultiWay）：扫描顺序决定保持二维平面在块内存中的最小内存需求量；适合维的基数乘积适中且数据不是太稀疏的情况，但是不能先验剪枝</li><li>BUC：自顶向下，容易受维的次序和倾斜数据的影响，理想情况下应先处理最有区分能力的维，应当以维的基数减序处理</li><li>Star-Cubing<ul><li>共享维剪枝</li><li>方体树，星树</li><li>计算完全立方体，稠密时接近MultiWay，比BUC快；稀疏时比MultiWay快很多，大部分情况下比BUC快</li><li>计算冰山立方体，比BUC快</li></ul></li><li>计算外壳片段：倒排索引，Frag-Shells</li><li>点查询，子立方体查询</li></ol><h3 id="高级查询"><a href="#高级查询" class="headerlink" title="高级查询"></a>高级查询</h3><ol><li>抽样立方体<ul><li>置信区间$\bar x ±t_c\sigma_{\bar x}$，$t_c$与置信水平相关，$\sigma_{\bar x}=\frac{s}{\sqrt l}$是均值的估计标准误差，自由度为$l-1$，$l$为样本数</li><li>提升小样本置信度：方体内查询扩展、方体间查询扩展</li></ul></li><li>排序立方体</li></ol><h3 id="多维数据分析"><a href="#多维数据分析" class="headerlink" title="多维数据分析"></a>多维数据分析</h3><ol><li>预测立方体</li><li>多特征立方体：多粒度上多个依赖的聚集的复杂查询</li><li>基于异常的、发现驱动的立方体空间探查<ul><li>SelfExp，InExp，PathExp</li><li>给定单元的值和它的期望值之间的差称为残差，残差越大越异常，要对残差定标</li></ul></li></ol><h2 id="第六章-挖掘频繁模式、关联和相关性：基本概念和方法"><a href="#第六章-挖掘频繁模式、关联和相关性：基本概念和方法" class="headerlink" title="第六章 挖掘频繁模式、关联和相关性：基本概念和方法"></a>第六章 挖掘频繁模式、关联和相关性：基本概念和方法</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>频繁模式：频繁出现在数据集中的模式，如频繁项集、频繁序列模式</li><li>有趣的关联规则：满足最小支持度阈值和最小置信度阈值</li><li>支持度support(A-&gt;B)=P(A$\cup$B)</li><li>置信度confidence(A-&gt;B)=P(B|A)=support(A$\cup$B)/support(A)</li><li>闭频繁项集：不存在频繁项集X的真超集Y，使得Y与X在D中支持度相同</li><li>极大频繁项集：不存在频繁项集X的超集Y，使得Y在D中是频繁的</li></ol><h3 id="频繁项集挖掘方法"><a href="#频繁项集挖掘方法" class="headerlink" title="频繁项集挖掘方法"></a>频繁项集挖掘方法</h3><ol><li><p>Apriori（先验）算法</p><ul><li>先验性质，属于反单调性</li><li>连接步，剪枝步</li><li>由频繁项集枚举子集，产生关联规则</li><li>优化方法：散列技术、事务压缩、划分、抽样、动态项集计数</li></ul></li><li><p>FP-growth（频繁模式增长）算法</p><ul><li>导出频繁项的集合，构造FP树</li><li>从表后端的后缀模式开始构造条件模式基</li></ul></li><li><p>使用垂直数据格式挖掘频繁项集</p><ul><li><p>不需要扫描数据库来确定k+1项集的支持度</p></li><li><p>差集技术：数据集稠密和包含长模式时，可以显著降低总开销</p></li></ul></li><li><p>挖掘闭模式和极大模式</p><ul><li>项合并</li><li>子项集剪枝</li><li>项跳过</li></ul></li></ol><h3 id="模式评估方法"><a href="#模式评估方法" class="headerlink" title="模式评估方法"></a>模式评估方法</h3><ol><li>提升度：$lift(A,B)=\frac{P(A\cup B)}{P(A)P(B)}=\frac{P(B|A)}{P(B)}=\frac{conf(A-&gt;B)}{sup(B)}$，小于1为负相关，大于1为正相关，等于1为独立</li><li>全置信度：min{P(A|B),P(B|A)}</li><li>最大置信度：max{P(A|B),P(B|A)}</li><li>Kulczynski（Kulc）度量：0.5(P(A|B)+P(B|A))</li><li>余弦度量：$\sqrt{P(A|B)+P(B|A)}$</li><li>不平衡比：$IR(A,B)=\frac{|sup(A)-sup(B)|}{sup(A)+sup(B)-sup(A\cup B)}$</li><li>全置信度、最大置信度、Kulc和余弦是零不变的，推荐Kulc和IR配合使用</li></ol><h2 id="第七章-高级模式挖掘"><a href="#第七章-高级模式挖掘" class="headerlink" title="第七章 高级模式挖掘"></a>第七章 高级模式挖掘</h2><h3 id="多层、多维空间中的模式挖掘"><a href="#多层、多维空间中的模式挖掘" class="headerlink" title="多层、多维空间中的模式挖掘"></a>多层、多维空间中的模式挖掘</h3><ol><li>挖掘多层关联规则</li><li>检查多层关联规则的冗余性：根据规则的祖先，它的支持度和置信度都接近于期望值</li><li>挖掘多维关联规则</li><li>挖掘量化关联规则</li><li>挖掘稀有模式和负模式<ul><li>稀有模式支持度远低于用户指定的最小支持度阈值</li><li>负相关：X和Y都是频繁的，但很少一起出现</li><li>直接用sup定义的强负相关并不是零不变的</li><li>零不变的强负相关定义：Kulc度量小于负模式阈值</li></ul></li></ol><h3 id="基于约束的频繁模式挖掘"><a href="#基于约束的频繁模式挖掘" class="headerlink" title="基于约束的频繁模式挖掘"></a>基于约束的频繁模式挖掘</h3><ol><li>用模式剪枝约束对模式空间剪枝<ul><li>反单调的</li><li>单调的</li><li>简洁的</li><li>可转变的</li><li>不可转变的</li></ul></li><li>用数据剪枝约束对数据空间剪枝<ul><li>数据简洁</li><li>数据反单调</li></ul></li></ol><h3 id="挖掘高维数据和巨型模式"><a href="#挖掘高维数据和巨型模式" class="headerlink" title="挖掘高维数据和巨型模式"></a>挖掘高维数据和巨型模式</h3><ol><li>通过模式融合挖掘巨型模式<ul><li>核模式（核后代）、核比率</li><li>鲁棒</li><li>模式距离</li><li>池初始化-迭代的模式融合</li></ul></li></ol><h3 id="挖掘压缩或近似模式"><a href="#挖掘压缩或近似模式" class="headerlink" title="挖掘压缩或近似模式"></a>挖掘压缩或近似模式</h3><ol><li>通过模式聚类挖掘压缩模式：模式距离</li><li>提取感知冗余的top-k模式<ul><li>显著性度量S</li><li>S(p,q)联合显著性，S(p|q)=S(p,q)-S(q)相对显著性</li><li>冗余性R(p,q)=S(p)+S(q)-S(p,q)，所以S(p|q)=S(p)-R(p,q)</li><li>可以用模式间的距离近似冗余度</li></ul></li></ol><h3 id="模式探索与应用"><a href="#模式探索与应用" class="headerlink" title="模式探索与应用"></a>模式探索与应用</h3><ol><li>频繁模式的语义注解：互信息</li><li>模式挖掘的应用</li></ol><h2 id="第八章-分类：基本概念"><a href="#第八章-分类：基本概念" class="headerlink" title="第八章 分类：基本概念"></a>第八章 分类：基本概念</h2><h3 id="决策树归纳"><a href="#决策树归纳" class="headerlink" title="决策树归纳"></a>决策树归纳</h3><ol><li>属性选择度量<ul><li>信息增益：信息需求$Info(D)=-\sum_{i=1}^mp_ilog_2(p_i)$，$p_i$用$|C_{i,D}|/|D|$估计；$Info_A(D)=\sum_{j=1}^v\frac{|D_j|}{D}*Info(D_j)$，$Info_A(D)$越小，分区纯度越高；信息增益$Gain(A)=Info(D)-Info_A(D)$</li><li>增益率：分裂信息$SplitInfo_A(D)=-\sum_{j=1}^v\frac{|D_j|}{D}*log_2(\frac{|D_j|}{|D|})$，增益率$GRianRate(A)=\frac{Gain(A)}{SplitInfo_A(D)}$</li><li>基尼系数：$Gini(D)=1-\sum_{i=1}^mp_i^2$度量数据分区或训练元组集D的不纯度；考虑二元划分裂时，计算每个结果分区不纯度加权和；对连续值属性，最大化不纯度降低</li><li>基于最小描述长度原理的属性</li></ul></li><li>树剪枝：先剪枝，后剪枝（代价复杂度剪枝算法，应用剪枝集）</li><li>可伸缩性与决策树归纳：雨林（在每个结点维护每个属性的AVC-集），树构造的自助乐观算法（BOAT）</li><li>决策树归纳的可视化挖掘：基于感知的分类（PBC）</li></ol><h3 id="贝叶斯分类方法"><a href="#贝叶斯分类方法" class="headerlink" title="贝叶斯分类方法"></a>贝叶斯分类方法</h3><ol><li>贝叶斯定理<ul><li>后验概率P(H|X)</li><li>P(H|X)=P(X|H)P(H)/P(X)</li></ul></li><li>朴素贝叶斯分类<ul><li>预测X属于在X条件下有最高后验概率的类</li><li>等价于最大化P(X|Ci)P(Ci)</li><li>若P(Ci)未知则假定等概率，否则用Ci/D估计</li><li>类条件独立的朴素假定：P(X|Ci)=P(x1|Ci)P(x2|Ci)……P(xn|Ci)</li><li>连续值属性的概率用高斯分布定义</li><li>拉普拉斯校准/拉普拉斯估计法</li></ul></li></ol><h3 id="基于规则的分类"><a href="#基于规则的分类" class="headerlink" title="基于规则的分类"></a>基于规则的分类</h3><ol><li>规则：规则前件/前提IF，规则结论THEN</li><li>覆盖率$coverage(R)=n_{covers}/|D|$</li><li>准确率$accuracy(R)=n_{correct}/n_{covers}$</li><li>规模序：优先最苛刻的规则，即前件规模最大、激活具有最多属性测试的被触发的规则</li><li>规则序：预定规则的优先次序</li><li>由决策树提取规则：规则是互斥的和穷举的</li><li>使用顺序覆盖算法的规则归纳<ul><li>贪心的深度优先策略</li><li>用于规则学习的称为正元组pos，其余称为负元组neg</li><li>信息增益$FOIL-Gain=pos’*(log_2\frac{pos’}{pos’+neg’}-log_2\frac{pos}{pos+neg})$；似然率统计量$Likelihood-Ratio=2\sum_{i=1}^mf_ilog(\frac{f_i}{e_i})$，似然率越高正确预测数与随机猜测差越显著</li><li>规则剪枝$FOIL-Prune(R)=\frac{pos-neg}{pos+neg}$</li></ul></li></ol><h3 id="模型评估与选择"><a href="#模型评估与选择" class="headerlink" title="模型评估与选择"></a>模型评估与选择</h3><ol><li>混淆矩阵——真阳性：TP；真阴性：TN；假阳性：FP；假阴性：FN</li><li>准确率/总体识别率：$accuracy=\frac{TP+TN}{P+N}$</li><li>错误率：1-accuracy</li><li>灵敏性/召回率：$sensitivity=\frac{TP}{P}=\frac{TP}{TP+FN}=recall$</li><li>特效性：$specificity=\frac{TN}{N}$</li><li>精度：$precision=\frac{TP}{TP+FP}$</li><li>$F_x$分数：$F_x=\frac{(1+x^2)<em>precision</em>recall}{x^2*precision+recall}$，x为1时称为F度量/F分数</li><li>保持方法和随机二次抽样</li><li>交叉验证<ul><li>k-折交叉验证：初始数据随机划分成k个互不相交的子集D，训练和检验进行k次，每次留下一个D检验</li><li>留一：每次只给检验集留出一个样本</li><li>分层交叉验证</li><li>建议用分层10-折交叉验证估计准确率</li></ul></li><li>自助法：有放回，.632，$Acc(M)=\sum_{i=1}^k(0.632<em>Acc(M_i)_{test-set}+0.368</em>Acc(M_i)train-set)$</li><li>统计显著性：t-test，显著水平sig，置信界z=sig/2<ul><li>$t=\frac{\bar {err}(M_1)-\bar {err}(M_2)}{\sqrt{var(M_1-M_2)/k}}$，var为模型差的方差，若有两个检验集，方差估计为$\sqrt{var(M_1)/k_1+var(M_2)/k_2}$</li></ul></li><li>成本效益</li><li>ROC曲线<ul><li>真正例率TPR=TP/P</li><li>假正例率TFR=FP/N</li><li>概率从高到低排序，真正例TP增加，假正例FP增加</li><li>用当前混淆矩阵计算(FPR,TPR)并将点绘在图中</li><li>ROC曲线越接近随机猜测，模型准确率越低</li></ul></li></ol><h3 id="提高分类准确率的技术"><a href="#提高分类准确率的技术" class="headerlink" title="提高分类准确率的技术"></a>提高分类准确率的技术</h3><ol><li>组合分类方法</li><li>装袋：有放回抽样，多数表决</li><li>提升和AdaBoost：给不正确分类的元组加权，不同分类器的表决权重也取决于错误率</li><li>随机森林</li><li>提高类不平衡数据的分类准确率：过抽样、欠抽样、阈值移动、组合技术</li></ol><h2 id="第九章-分类：高级方法"><a href="#第九章-分类：高级方法" class="headerlink" title="第九章 分类：高级方法"></a>第九章 分类：高级方法</h2><h3 id="贝叶斯信念网络"><a href="#贝叶斯信念网络" class="headerlink" title="贝叶斯信念网络"></a>贝叶斯信念网络</h3><ol><li>计算梯度</li><li>沿梯度方向前进一小步</li><li>重新规格化权重</li></ol><h3 id="用后向传播分类"><a href="#用后向传播分类" class="headerlink" title="用后向传播分类"></a>用后向传播分类</h3><ol><li>多层前馈神经网络</li><li>后向传播：初始化权重，向前传播输入，向后传播误差</li><li>可增强可解释性</li></ol><h3 id="支持向量机"><a href="#支持向量机" class="headerlink" title="支持向量机"></a>支持向量机</h3><ol><li>对线性和非线性数据进行分类</li><li>SVM搜索最大边缘超平面（MMH）</li><li>支持向量：最难分类的元组，给出最多支持信息</li></ol><h3 id="使用频繁模式分类"><a href="#使用频繁模式分类" class="headerlink" title="使用频繁模式分类"></a>使用频繁模式分类</h3><h3 id="惰性学习法（近邻学习）"><a href="#惰性学习法（近邻学习）" class="headerlink" title="惰性学习法（近邻学习）"></a>惰性学习法（近邻学习）</h3><ol><li>距离最近的k个中取最多</li><li>训练元组趋于无穷，k=1，错误率不超过贝叶斯错误率的2倍；k趋于无穷，错误率趋向于贝叶斯错误率</li><li>基于案例的推理</li></ol><h3 id="其他分类方法"><a href="#其他分类方法" class="headerlink" title="其他分类方法"></a>其他分类方法</h3><ol><li>遗传算法</li><li>粗糙集算法</li><li>模糊集算法</li><li>多类分类</li><li>半监督分类</li><li>主动学习</li><li>迁移学习</li></ol><h2 id="第十章-聚类分析：基本概念和方法"><a href="#第十章-聚类分析：基本概念和方法" class="headerlink" title="第十章 聚类分析：基本概念和方法"></a>第十章 聚类分析：基本概念和方法</h2><ol><li>划分方法：k-均值，k-中心点</li><li>层次方法</li><li>基于密度的方法</li><li>基于网格的方法</li><li>簇的形心、半径、直径</li><li>聚类评估</li></ol>]]></content>
    
    
    <categories>
      
      <category>数据挖掘</category>
      
    </categories>
    
    
    <tags>
      
      <tag>孙若诗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网笔记</title>
    <link href="/AcceptedHelper/2021/11/17/web_note/"/>
    <url>/AcceptedHelper/2021/11/17/web_note/</url>
    
    <content type="html"><![CDATA[<p>本文件为计算机网络的笔记</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/FDU19CS/AcceptedHelper@hexo/source/_posts/web_note/Note.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>唐侨</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OS笔记</title>
    <link href="/AcceptedHelper/2021/11/13/os_note/"/>
    <url>/AcceptedHelper/2021/11/13/os_note/</url>
    
    <content type="html"><![CDATA[<p>本文件为操作系统的笔记</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/FDU19CS/AcceptedHelper@hexo/source/_posts/os_note/Note.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>黄绵秋</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算理论基础复习笔记</title>
    <link href="/AcceptedHelper/2021/06/24/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/AcceptedHelper/2021/06/24/%E8%AE%A1%E7%AE%97%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算理论基础复习笔记"><a href="#计算理论基础复习笔记" class="headerlink" title="计算理论基础复习笔记"></a>计算理论基础复习笔记</h1><p>待更新</p><h2 id="预备知识与基本文法理论（讲义第一章、第二章）"><a href="#预备知识与基本文法理论（讲义第一章、第二章）" class="headerlink" title="预备知识与基本文法理论（讲义第一章、第二章）"></a>预备知识与基本文法理论（讲义第一章、第二章）</h2><p>第一章大部分内容在其他课程里讲过了，新的内容只有：</p><blockquote><p>前缀性质：L 中任何字符串都不是另一个字符串的真前缀</p></blockquote><p>第二章讲了文法的基本概念。</p><blockquote><p><strong>文法</strong> $G$ 是四元组 $(V, T, P, S)$， V 是变元的有限集，T 是终结符有限集，P 是生成式有限集， S 是开始符号。</p></blockquote><blockquote><p>=&gt; 关系为<strong>直接派生</strong>，多步直接派生为<strong>派生</strong>。</p></blockquote><blockquote><p>文法 $G$ 产生的<strong>语言</strong> $L(G)$ 是 S 派生出来的终结符号串的全体。</p></blockquote><blockquote><p>0型文法（短语结构文法 PSG ）：对生成式无限制。</p><p>1型文法（上下文有关文法 CSG ）：每个生成式左侧长度≤右侧长度</p><p>1°型文法（上下文有关文法的另一种形式）：每个生成式，左侧至少包含一个变元，删去该变元后的前缀与后缀（可为空）也是右侧的前缀与后缀。$\alpha_1A\alpha_2 \rightarrow \alpha1\beta\alpha_2, \beta不为空$，前缀$\alpha_1$和后缀$\alpha_2$即为上下文。</p><p>2型文法（上下文无关文法 CFG ）：每个生成式左侧仅包含一个变元</p><p>3型文法（正规文法 RG ）：每个生成式左侧仅包含一个变元，且右侧必须形如 $a$ 或 $aB$ ，$a \in T \ 或a为空串$</p></blockquote><p>将1型文法转为1°型文法：</p><ol><li>对所有终结符$a$，添加变元$[a]$。</li><li>将原有生成式中所有终结符替换为对应新变元（如将$a$替换为$[a]$）。此时，所有生成式都只含变元。</li><li>对所有终结符$a$，添加生成式$[a]\rightarrow a$。</li><li>对所有不符合1°型文法的生成式，若左侧为$A_1A_2\ …\ A_n$，右侧为$B_1B_2…B_m$ ，则添加$n$个变元，用新的 $2n$ 个生成式替换这个生成式。新的生成式中：<ul><li>第 $i+1$ 个生成式的左侧是第 $i$ 个生成式的右侧；</li><li>前 $n$ 个生成式将 $A_1A_2…A_n$ 逐渐替换为 $C_1C_2…C_n$，每个生成式替换一个最靠前的 $A$（第一个生成式为$A_1A_2…A_n\rightarrow C_1A_2…A_n$）；</li><li>接下来的 $n-1$ 个生成式将 $C_1C_2…C_n$ 逐渐替换为 $B_1B_2…B_{n-1}C_n$， 每个生成式替换一个最靠前的 $C$ （第 $n+1$个生成式为$C_1C_2…C_n\rightarrow B_1C_2…C_n$）；</li><li>最后的生成式将 $C_n$ 替换为 $B_nB_{n+1}…B_m$ 。</li></ul></li></ol><p>2型文法的<strong>派生树</strong>：根节点为 S ；内部节点为变元；某个节点（有标记A）的孩子从左到右收集而成的字符串s，必有$A\rightarrow s$属于生成式集合（对应<em>直接派生</em>）；<strong>边缘</strong>是叶子节点从左到右收集而成的字符串（对应<em>派生</em>）。派生树可对应一个字符串从 S 开始的派生过程。</p><p><strong>最左派生</strong>：派生过程每一步都只替换最左边的变元。（同理有<strong>最右派生</strong>）</p><p><strong>多义</strong>：某个字符串有两种不同派生过程。</p><h2 id="有穷自动机、正规表达式、正规集（讲义第三、四章，MIT教材第一章）"><a href="#有穷自动机、正规表达式、正规集（讲义第三、四章，MIT教材第一章）" class="headerlink" title="有穷自动机、正规表达式、正规集（讲义第三、四章，MIT教材第一章）"></a>有穷自动机、正规表达式、正规集（讲义第三、四章，MIT教材第一章）</h2><blockquote><p><strong>有穷自动机</strong> （FA） 是五元组 $(Q,\Sigma,\delta,q_0,F)$，分别对应：有穷状态集、有穷输入字符表、转移函数、初始状态、终结状态集。</p><p>转移函数的输入为单个字符，可扩充为字符串。</p><p>FA 接收的字符串 s ：以 s 作为 FA 的输入，状态从初始的 $q_0$ 转移到 F 里的状态。</p></blockquote><h3 id="几种转换"><a href="#几种转换" class="headerlink" title="几种转换"></a>几种转换</h3><ol><li><p>$DFA \rightarrow Regular\ Expression$</p><p>讲义上的方法是：</p><ul><li><p>如果有 $k$ 个状态，算出 $k^3$ 个正规表达式 $r_{ij}^k$，表示输入串使状态机从状态 i 到 j 中间不经过编号高于 k 的状态。</p></li><li><p>$k = 0$ 时，状态图中若有从状态 i 到状态 j 的箭头，就把箭头上的字符加到集合里。$i == j$ 时，这个集合里还要包含空串。</p></li><li><p>$k \ne 0$ 时，有递推式 $r_{ij}^k = r_{ik}^{k-1}(r_{kk}^{k-1})^*r_{kj}^{k-1} \cup r_{ij}^{k-1}$</p></li></ul><p>MIT 教材上的方法是：</p><ul><li>将 DFA 转为 GNFA （GNFA的转换条件可以是正规表达式）：添加两个状态 s 和 t ，s 为新的初始状态，t 为新的终结状态。s 通过 $\epsilon$ 动作到原有的每个初始状态，原有的每个终结状态通过 $\epsilon$ 动作到 t</li><li>将 GNFA 的状态数缩减到2：下面的 RE 三种四句的反向操作，可将状态数减1</li><li>将 2-state GNFA 转换为 RE：转换条件即为所求</li></ul></li><li><p>$Regular Expression \rightarrow \epsilon-NFA$</p><p>处理三种类型的子句即可。讲义 p65-p66 的三张图</p><ul><li>$r_1+r_2$：两路分叉、两路归并</li><li>$r_1r_2$：前面的终结状态指向后面的初始状态</li><li>$r_1^*$：终结状态回到初始状态</li></ul></li><li><p>$\epsilon-NFA \rightarrow NFA$</p><p>讲义 p59</p><p>先检查 $q_0$ 是否为终结状态。</p><p>转移函数取一个闭包。</p></li><li><p>$NFA \rightarrow DFA$</p><p>讲义 p55</p><p>NFA 中，$\delta(q, a)$ 的结果是一个状态集。建立状态集到状态元组双射，把状态元组看作一个新的状态。将状态元组作为 $\delta$ 的输入，结果为元组中状态作为输入的结果的并集。一直做下去，直到不产生新的状态。</p></li></ol><p>正规文法转为 $\epsilon-NFA$：</p><ul><li>每个变元为状态，每个终结符为输入字符</li><li>转移函数的输入：派生左侧的变元、派生右侧的终结符（或 $\epsilon$）；输出为派生右侧的变元（或终结状态）</li></ul><p>DFA 转为正规文法：同上。</p><h3 id="缩胀定理"><a href="#缩胀定理" class="headerlink" title="缩胀定理"></a>缩胀定理</h3><p><strong>正规集缩胀定理</strong>：A 是正规集，则存在 p (pumping length) 使长度大于等于 p 的 A 中任意 s，可拆成三部分 $s=xyz$，满足：</p><ul><li>$xy^iz\in A, \forall i \ge 0$</li><li>$|y| \gt 0$</li><li>$|xy|\le p$</li></ul><p>（讲义上的定理给 s 和 $xy^iz$ 加了前缀和后缀，移去了最后一个限制。）</p><p>正规集在并、连接、闭包运算（由正规表达式的定义）、补运算（终结状态取补）、交运算（两个 DFA 的状态集、终结状态集取笛卡尔积）、商运算（ 在 R1/R2 中，R1 状态集为 Q，建立 |Q| 个 DFA，分别以 Q 中每个状态为初始状态，检测这些 DFA 交 R2 是否为空）下封闭。这些性质可以用来判定某个集合 C 不是正规集：取已知正规集 A 和已知非正规集 B，使 A 和 C 在某种封闭运算下变为 B，则 C 不是正规集。</p><p>一些判定问题：具有 n 个状态的 FA 有以下性质</p><ul><li>接受集合非空，iff 接受一个长度小于 n 的串</li><li>接受集合无穷，iff 接受一个长度在 [n, 2n) 之间的串</li><li>是否为空、是否无穷、是否等价 是可判定的</li></ul><h3 id="极小化算法"><a href="#极小化算法" class="headerlink" title="极小化算法"></a>极小化算法</h3><blockquote><p>状态的等价：$\forall x \in \Sigma^*, \delta(p,x)\in F\ \leftarrow \ \delta(q,x)\in F$</p><p>商自动机：状态集是 Q 的各等价类；自动机和它的商自动机等价</p></blockquote><p>极小化算法：</p><ul><li>对所有状态对 {p, q} 画一个下三角矩阵</li><li>对 $p\in F,q\notin F$ 的 ${p, q}$，在相应位置做标记</li><li>重复此步直到矩阵不再变化：$\exists a\in\Sigma,{\delta(p,a),\delta(q,a)}$ 被标记，则标记 $(p,q)$</li><li>没被标记的状态对是等价的</li></ul><h3 id="Myhill-Nerode-定理"><a href="#Myhill-Nerode-定理" class="headerlink" title="Myhill-Nerode 定理"></a>Myhill-Nerode 定理</h3><blockquote><p>两个 DFA 同构：状态集存在双射，且满足一些性质</p><p>右不变：对于等价关系 R，xRy 可推出 xzRyz</p><p>关于集合 A 的 <code>Myhill-Nerode</code> 关系：右不变、细分A、具有有穷指数</p></blockquote><p><strong>DFA 与 <code>Myhill-Nerode</code> 的关系</strong>：</p><ul><li><p>DFA M $\rightarrow$ <code>Myhill-Nerode</code> 关系 $R_M$：$xR_My\leftarrow\delta(q_0,x)=\delta(q_0,y)$</p></li><li><p><code>Myhill-Nerode</code> 关系 $\rightarrow$ DFA $M_R$ : $Q = {[x]|x\in\Sigma^*}, q_0 = {[e]}, F = {[x]|x\in A}, \delta([x],a)=[xa]$，有 $L(M_R) = A$</p></li></ul><p><strong>反复横跳</strong>：</p><ul><li>$R_{M_R}=R$，R 是 <code>Myhill-Nerode</code> 关系</li><li>$M_{R_M}$ 同构于 $M$，M 是 FA</li></ul><blockquote><p>等价关系 $R_A$：$xR_Ay:\forall z\in\Sigma^*,xz\in A \leftarrow yz \in A$. $R_A$ 右不变、细分 A </p></blockquote><p><strong>Myhill-Nerode定理</strong>：</p><ul><li>正规集有一个 <code>Myhill-Nerode</code> 关系 $R_M$</li><li>若 A 有 <code>Myhill-Nerode</code> 关系，则 $R_A$ 有有穷指数</li><li>若 $R_A$ 有有穷指数，则$R_A$ 是 $Myhill-Nerode$ 关系，构造 $M_{R_A}$ 接受 A</li></ul><p>$M_{R_A}$ 是状态数最少的。</p><h3 id="归纳：判定某个集合不是正规集"><a href="#归纳：判定某个集合不是正规集" class="headerlink" title="归纳：判定某个集合不是正规集"></a>归纳：判定某个集合不是正规集</h3><ul><li>缩胀定理</li><li>利用封闭运算</li><li>集合的关系 $R_A$ 没有有穷指数</li></ul><h2 id="上下文无关文法、下推自动机（讲义第五、六章，MIT教材第二章）"><a href="#上下文无关文法、下推自动机（讲义第五、六章，MIT教材第二章）" class="headerlink" title="上下文无关文法、下推自动机（讲义第五、六章，MIT教材第二章）"></a>上下文无关文法、下推自动机（讲义第五、六章，MIT教材第二章）</h2><h3 id="化简-CFG"><a href="#化简-CFG" class="headerlink" title="化简 CFG"></a>化简 CFG</h3><blockquote><p>无用符号：$X\in V\cup T$ 但 $X$ 不出现在 S 派生出的字符串中；$X\in V$ 但 X 不能派生任何终结符号串</p></blockquote><p>消去无用符号的步骤：</p><ul><li>先消去 (2) 类无用符号（引理5.1）：构造新的 $V’$ ，若生成式 $A\rightarrow X_1X_2…X_n$ 右侧的每一 $X_i \in T^*\cup V’$，则把 A 加到 $V’$ 中。</li><li>再消去 (1) 类无用符号（引理5.2）：构造新的 $V’$ 和 $T’$，首先将 S 放入 $V’$ 中，若某个生成式左侧的变元属于 $V’$，则将该生成式右侧的变元放入 $V’$ 中，终结符放入 $T’$ 中。</li></ul><blockquote><p>变元 A 可为零：A 可以派生空串</p><p>$\epsilon$-生成式：右端为空</p></blockquote><p>消去 $\epsilon$-生成式（使 $L(G’) = L(G) -{\epsilon}$）的步骤：</p><ul><li>确定可为零的变元集 Z：先把直接派生空串的变元放入 Z 中，然后检查右侧全为变元的生成式，若右侧变元全在 Z 中，则把该生成式左侧变元放入 Z 中。</li><li>构造新的生成式集合 $P’$：对 $P$ 中所有生成式，检查右侧的每一个符号，如果不属于 Z 则不改变，属于 Z 则改为 $\epsilon$ 或不改变（不改变的情况是防止修改后右侧全为 $\epsilon$）。</li><li>消去无用符号</li></ul><blockquote><p>单一生成式：左右端皆为一个变元</p></blockquote><p>不含空串的 CFL，消去单一生成式的步骤：</p><ul><li>构造新的生成式集合 $P’$：先将 $P$ 中非单一生成式放入 $P’$，对单一生成式 $A\rightarrow B$，如果 $B\rightarrow \alpha$ 是 $P’$ 中元素，则将 $A\rightarrow \alpha$ 放入 $P’$。</li><li>消去无用符号</li></ul><h3 id="CFG-范式"><a href="#CFG-范式" class="headerlink" title="CFG 范式"></a>CFG 范式</h3><blockquote><p><code>Chomksky</code> 范式：每个生成式右侧为两个变元或一个终结符</p></blockquote><p>不含空串的 CFL 转为 <code>Chomsky</code> 范式的步骤：</p><ul><li>消去单一生成式、$\epsilon$-生成式和无用符号</li><li>如果某生成式右侧只有一个符号，则它一定是终结符</li><li>如果某生成式 $p$ 右侧同时包含变元和终结符，则对每个终结符 $a$，添加变元 $C_a$ 和生成式 $C_a \rightarrow a$ ，用这个变元替换掉 $p$ 右侧的对应终结符</li><li>此时，所有生成式除去形如 $A\rightarrow a$ 的，其他生成式右侧不含终结符。如果某个生成式仅包含 $m(m\ge 2)$ 个变元，则添加 $m-2$ 个变元和若干个生成式，使每个生成式右侧仅含2个变元。如 $A\rightarrow B_1B_2B_3$ 可拆成 $A\rightarrow B_1D_1, D_1 \rightarrow B_2B_3$</li></ul><blockquote><p><code>Greibach</code> 范式：每个生成式右侧的第一个符号为终结符</p></blockquote><p>不含空串的 CFL 转为 <code>Greibach</code> 范式的步骤：</p><ul><li>转为 <code>Chomsky</code> 范式</li><li>对变元进行编号。保证每个形如 $A_k \rightarrow A_j\alpha$ 生成式右侧的第一个变元编号 $A_j$ 大于左侧变元，如果不大于则用已检查过的 $A_j \rightarrow A_m\alpha$ 替换，这样右侧第一个变元的编号严格递增，这一步可以在有限次数内完成。如果遇到 $A_k \rightarrow A_k\alpha$ 则加入新的生成式 $B_k \rightarrow \alpha,\ B_k \rightarrow \alpha B_k,\ A_k \rightarrow \beta B_k$，对一切已有的 $A_k \rightarrow \beta$</li><li>处理 $A_i \rightarrow A_j \gamma\ ,j&gt;i$。左部变元编号从大到小开始处理：编号为最大时，生成式右侧第一个符号必为终结符；其他情况，右侧第一个变元用已有生成式代入，代入后编号递增，达到编号最大时，再代入一次，右侧第一个符号也变为终结符。</li><li>处理以新加入的 $B_i$ 变元为左部的生成式。其右侧第一个符号只可能是是终结符或 $A_j$，出现后者时再做一次编号递增即可。</li></ul><h3 id="下推自动机"><a href="#下推自动机" class="headerlink" title="下推自动机"></a>下推自动机</h3><blockquote><p>下推自动机 PDA 是七元组 $(Q,\Sigma,\Gamma,\delta,q_0,Z_0,F)$，比 DFA 多了 $\Gamma$ 有穷的栈符号表，$Z_0$ 栈底符号。</p><p>转移函数的形式是 $\delta(q,a,Z) = {(p_1,\gamma_1),…,(p_m,\gamma_m)}$，表示当状态为 q，读入字符 a，且栈顶为 Z 时，将状态改为 p，栈顶改为 $\gamma$。</p><p>瞬时描述 ID 是三元组 $(q,w,\gamma)$，w 为未读过的输入，$\gamma$ 为栈中符号串（左侧为栈顶）。$(p_1,\gamma_1) \in \delta(q,a,Z)$ 可表示为 $(q,aw,Z\alpha) \vdash (p_1, w, \gamma_1\alpha)$</p><p>L(M) 是 M 按终结状态方式接受的语言，N(M) 是 M 按空栈方式接受的语言。它们是等价的。</p></blockquote><p>已知 $M_1$， 构造 $M_2$ 使 $L(M_1) = N(M_2)$：</p><ul><li>添加两个状态 $q_e, q_0’$，$q_e$为接受完毕并准备清空栈，$q_0’$为新的初始状态。添加栈符号 $X_0$ 作为栈底符号</li><li>初始：$\delta’(q_0,\epsilon,X_0)={(q_0,Z_0X_0)}$，$Z_0$ 为 $M_1$ 栈底符号</li><li>终结：$\delta’(q,\epsilon,Z)包含(q_e,\epsilon)$，当 q 是终结状态，并清空栈：$\delta’(q_e,\epsilon,Z)={(q_e,\epsilon)}$</li></ul><p>已知 $M_1$， 构造 $M_2$ 使 $N(M_1) = L(M_2)$：</p><ul><li>添加新的初始状态、终结状态、栈底符号</li><li>初始：状态改为 $M_1$ 的初始状态，将 $M_1$ 的栈底符号压入栈</li><li>终结：当栈顶符号为 $M_2$ 栈底符号是，说明栈为空，如果没有输入了，就转至终结状态</li></ul><p>已知 CFL L，构造 PDA M 使 $L = N(M)$：</p><ul><li>若 L 接受空串，则加上 $\delta(q,\epsilon,S) = {(q,\epsilon)}$</li><li>除去空串，设 G 为产生 L 的 <code>Greibach</code> 文法，构造转移函数：若 $A\rightarrow a\gamma\in P$ 则 $\delta(q,a,A) 包含 (q,\gamma)$</li></ul><p>已知 PDA M， 构造 CFL L 使 $L=N(M)$：</p><ul><li>构造 $V={[q,A,p]|q,p\in Q,A\in\Gamma}\cup{S}$</li><li>初始：$S\rightarrow [q_0,Z_0,q], q \in Q$</li><li>当 $\delta(q,a,A)包含(q_1,B_1B_2…B_m)$ 则有 $[q,A,q_{m+1}]\rightarrow a[q_1,B_1,q_2][q_2,B_2,q_3]…[q_m,B_m,q_{m+1}]$。</li></ul><h3 id="缩胀定理-1"><a href="#缩胀定理-1" class="headerlink" title="缩胀定理"></a>缩胀定理</h3><blockquote><p>基础版：</p><p>$\forall k\ge 0,\exists z\in L, |z| \ge k, z = uvwxy, |vx|\ge 1,|vwx|\le k, \exists i \ge 0, uv^iwx^iy \notin L$， 则 L 不是 CFL。</p></blockquote><p>步骤：</p><ul><li>拆成5份</li><li>中间部分不超过k，要扩展的部分不都为空</li><li>将第2、4部分进行复制，或删除</li></ul><blockquote><p><code>Ogden</code> 定理：</p><p>若 L 是 CFL，存在 $k\ge 0$，对每个 $z\in L, z=uvwxy$，在 z 中标出 $\ge k$ 个特别符号，使：vx 至少包含一个特别符号、vwx 最多包含 k 个特别符号。</p></blockquote><p>CFL 在并、连接、闭包运算下封闭，在交、补运算下不封闭（不可判定）。</p><p>CFG 接受的语言是否为空、是否有穷的问题可判定。</p><p>成员资格问题的 CYK 算法：</p><ul><li>将 CFG 转为 <code>Chomsky</code> 范式。记 $x_{ij}$ 为 $x.substr(i,j)$。</li><li>判别 $x_{ij}$ 可由哪些变元派生，从 $j=1\ to\ n$ 依次判别。<ul><li>当 j = 1 时，可由生成式得出。</li><li>当 j &gt; 1 时，A 可派生出 $x_{ij}$，当且仅当 $\exists A\rightarrow BC$ 且 B 派生 $x_{ij}$ 的前一段，C 派生 $x_{ij}$ 的后一段。</li></ul></li></ul><h2 id="图灵机、递归集、不可判定性（讲义第七、八章）"><a href="#图灵机、递归集、不可判定性（讲义第七、八章）" class="headerlink" title="图灵机、递归集、不可判定性（讲义第七、八章）"></a>图灵机、递归集、不可判定性（讲义第七、八章）</h2><blockquote><p>确定的单带图灵机 TM 是9元组 $(Q,\Sigma,\Gamma,左端标记,空白符号,\delta,初始状态,接受状态,拒绝状态)$</p><p>$\delta(p,a)=(q,b,R)$</p><p>瞬时描述 ID 为 $\alpha_1 q \alpha_2$，（读写头左侧，状态，读写头及其右侧）</p><p>完全的图灵机：对一切输入都能停机</p><p>图灵机接受的语言：递归可枚举集（r.e.）</p><p>完全图灵机接受的语言：递归集</p></blockquote><h3 id="图灵机的构造技术"><a href="#图灵机的构造技术" class="headerlink" title="图灵机的构造技术"></a>图灵机的构造技术</h3><ul><li>有限控制器中的存储：状态可以是 n 元组</li><li>移动：将带上符号吸收到状态上</li><li>多道技术：每个带符号是 n 元组</li><li>查讫符号：带符号是2元组 (字符，标记)</li><li>子程序技术<ul><li>调用：转到子程序的初始状态</li><li>返回：到达子程序的返回状态</li></ul></li></ul><h3 id="图灵机的类型"><a href="#图灵机的类型" class="headerlink" title="图灵机的类型"></a>图灵机的类型</h3><ul><li>双向无限带</li><li>多带</li><li>非确定</li><li>双栈</li><li>带字母最少</li><li>枚举器</li></ul><h3 id="递归集与不可判定问题"><a href="#递归集与不可判定问题" class="headerlink" title="递归集与不可判定问题"></a>递归集与不可判定问题</h3><table><thead><tr><th></th><th>递归集</th><th>递归可枚举</th></tr></thead><tbody><tr><td>补</td><td>封闭</td><td>如果 L 和 L 的补是递归可枚举的，它们是递归的</td></tr><tr><td>并</td><td>封闭</td><td>封闭</td></tr><tr><td>交</td><td>封闭</td><td>封闭</td></tr></tbody></table><blockquote><p>通用图灵机 U 是能模拟任何图灵机的图灵机</p></blockquote><p>$L(U)={M#x|x\in L(M)}$，#为分隔符</p><p>任意给定的 TM M 对任意给定的输入串 x 是否停机的问题是不可判定的。</p><p>对任意给定的 TM M 和输入串 x，M 是否接受 x 的问题是不可判定的。</p><p>给定一个 TM M，它是否接受空串的问题是不可判定的。</p><blockquote><p>A 到 B 的<strong>归约</strong>：存在函数 f，$x\in A \leftarrow f(x) \in B$，记 $A\le_m B$，m 表明归约是多对一的。</p></blockquote><p>若 $A\le_m B$：</p><ul><li>B 是 r.e. =&gt; A 是 r.e.</li><li>B 是递归集 =&gt; A 是递归集</li></ul><blockquote><p><strong>性质</strong> 是一个映射：定义域是 $\Sigma^*$ 的 r.e. 子集，值域是 {True, False}</p><p>平凡性质：映射只取 True 或 False</p></blockquote><p>Rice 定理：r.e. 集合类的任一非平凡性质都是不可判定的。</p>]]></content>
    
    
    <categories>
      
      <category>计算理论基础</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Malloc Lab 动态内存分配器</title>
    <link href="/AcceptedHelper/2021/05/22/MallocLab/"/>
    <url>/AcceptedHelper/2021/05/22/MallocLab/</url>
    
    <content type="html"><![CDATA[<h1 id="Malloc-Lab"><a href="#Malloc-Lab" class="headerlink" title="Malloc Lab"></a>Malloc Lab</h1><p>​    个人的实验报告，放上来给大家参考。</p><p>​    Malloc lab 需要我们编写一个类似 libc malloc 的动态内存分配器，其主要考察动态内存分配器的原理设计以及堆内存的结构组织，同时需要比较强的 DEBUG 能力。最后在不使用BST以及其他全局数据结构的情况下我的方法达到了 97/100 的分数</p><p><a href="https://github.com/ZiYang-xie/Malloc_Lab">ZiYang-xie/Malloc_Lab: CMU Malloc Lab Repo (github.com)</a></p><h2 id="一、空闲块组织结构"><a href="#一、空闲块组织结构" class="headerlink" title="一、空闲块组织结构"></a>一、空闲块组织结构</h2><p>​    在结构设计上我采用了分离存储的显示链表形式来进行组织空闲块，在书上说明了分离存储的思想，但没有具体说明实现方法。在此我使用称为 <strong>Segregated Free List</strong> 的空闲块组织设计，即在堆的低地址分配数量等于 <code>SEG_LEN</code> 的指针，每个指针分别对应着一个大小类，指向正式堆块中的空闲块，相当于 <code>SEG_LEN</code> 个链表。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gquqskpijgj30ff07cdg2.jpg" alt="Segregated Free List"></p><p>​    在我的代码设计中，我以2的幂次分割大小类，由于空闲块最小块大小为16 bytes （包括头尾标记以及前后指针）因此其设计为 {2^4 ~ 2^5} \ {2^5 ~ 2^6} \ {2^6 ~ 2^7} …(类推)</p><p> 为了区分某一空闲块应该被放置在哪个类中，我们需要一个 <strong>get_index</strong> 函数，正常设计也十分简单，即通过一个循环右移，计算位数。在这里我参考了 <strong>Bit twiddling hacks</strong> 著名位运算<em>奇技淫巧</em> 网站，采用了一个位运算的 log2 方式，其可以在 O(1) 的复杂度计算出 log2(x)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get_index</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> v)</span> </span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 本质上是位运算的 log 2, O(1)复杂度</span><br>    <span class="hljs-comment">// 参考 &#x27;Bit twiddling hacks&#x27;</span><br>    <span class="hljs-comment">// Linking: https://graphics.stanford.edu/~seander/bithacks.html#IntegerLogLookup</span><br>    <br>    <span class="hljs-keyword">size_t</span> r, shift;<br>    r = (v &gt; <span class="hljs-number">0xFFFF</span>)   &lt;&lt; <span class="hljs-number">4</span>; v &gt;&gt;= r;<br>    shift = (v &gt; <span class="hljs-number">0xFF</span>) &lt;&lt; <span class="hljs-number">3</span>; v &gt;&gt;= shift; r |= shift;<br>    shift = (v &gt; <span class="hljs-number">0xF</span>)  &lt;&lt; <span class="hljs-number">2</span>; v &gt;&gt;= shift; r |= shift;<br>    shift = (v &gt; <span class="hljs-number">0x3</span>)  &lt;&lt; <span class="hljs-number">1</span>; v &gt;&gt;= shift; r |= shift;<br>                                          r |= (v &gt;&gt; <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">// 从 2^4 开始 (空闲块最小 16 bytes)</span><br>    <span class="hljs-keyword">int</span> x = (<span class="hljs-keyword">int</span>)r - <span class="hljs-number">4</span>;<br>    <span class="hljs-keyword">if</span>(x &lt; <span class="hljs-number">0</span>) <br>        x = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(x &gt;= SEG_LEN) <br>        x = SEG_LEN - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二、堆内存设计"><a href="#二、堆内存设计" class="headerlink" title="二、堆内存设计"></a>二、堆内存设计</h2><p>​    在空闲块指针之上，分配正常的堆块，正常的堆块由<strong>序言块</strong> （一个已分配大小为8的块），以及<strong>结尾块</strong>（一个已分配大小为0的块）前后包围，这样可以很方便的检验边界情况，当后继块大小为0，那么便可判断其达到了结尾。之后便记录下全局的开始地址 <code>global_list_start_ptr</code> 即可</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 空闲块 */</span><br><span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; SEG_LEN; ++i)<br>  PUT(heap_listp + i*WSIZE, <span class="hljs-literal">NULL</span>);            <span class="hljs-comment">// 初始化空闲块大小类头指针</span><br><br><span class="hljs-comment">/* 分配块 */</span><br>PUT(heap_listp + (i+<span class="hljs-number">0</span>)*WSIZE, PACK(DSIZE, ALLOCATED));  <span class="hljs-comment">/* 序言块头部 */</span><br>PUT(heap_listp + (i+<span class="hljs-number">1</span>)*WSIZE, PACK(DSIZE, ALLOCATED));  <span class="hljs-comment">/* 序言块尾部 */</span><br>PUT(heap_listp + (i+<span class="hljs-number">2</span>)*WSIZE, PACK(<span class="hljs-number">0</span>, ALLOCATED));      <span class="hljs-comment">/* 结尾块头部 */</span><br><br>global_list_start_ptr = heap_listp;<br>heap_listp += (i+<span class="hljs-number">1</span>)*WSIZE; <span class="hljs-comment">// 对齐到起始块有效载荷</span><br></code></pre></td></tr></table></figure><h2 id="三、具体设计"><a href="#三、具体设计" class="headerlink" title="三、具体设计"></a>三、具体设计</h2><p>​    接下来以函数为单位详细介绍实现过程</p><pre><code>### mm_init 初始化堆</code></pre><p>​    堆内存设计块节中以及包含大部分，mm_init 代码，在组织完堆初始化的指针之后就可以进行分配栈空间以一个初始化的空闲块，这涉及到了 extend_heap 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* 扩展空栈至 CHUNKSIZE bytes */</span><br>    <span class="hljs-keyword">if</span>(extend_heap(CHUNKSIZE) == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><h3 id="extend-heap-堆扩展"><a href="#extend-heap-堆扩展" class="headerlink" title="extend_heap 堆扩展"></a>extend_heap 堆扩展</h3><p>​    对于堆扩展，我们调用 mm_sbrk 函数将lab中设计好的抽象 program breaker 上移扩展堆大小，其返回空闲块的头指针，我们设置好它的头尾标记，并通过 coalesce 函数在进行前后空闲块合并之后插入到空闲块链表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">extend_heap</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> asize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">char</span> *bp;<br>    <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>)(bp = mem_sbrk(asize)) == <span class="hljs-number">-1</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    <br>    <span class="hljs-comment">/* 初始化空闲块的头尾和结尾块的头部 */</span><br>    PUT(HDRP(bp), PACK(asize, FREE));                <span class="hljs-comment">/* 空闲块头部 */</span><br>    PUT(FTRP(bp), PACK(asize, FREE));                <span class="hljs-comment">/* 空闲块尾部 */</span><br>    PUT(HDRP(NEXT_BLKP(bp)), PACK(<span class="hljs-number">0</span>, ALLOCATED));    <span class="hljs-comment">/* 结尾块头部 */</span><br><br>    <span class="hljs-keyword">return</span> coalesce(bp);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="coalesce-合并块"><a href="#coalesce-合并块" class="headerlink" title="coalesce 合并块"></a>coalesce 合并块</h3><p>​    合并块的模式包含四种情况，并且在我的设计模式中，在合并后将空闲块插入到空闲链表中去，形成一体化操作。</p><ul><li><strong>Case1: 前后均不空闲</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; next_alloc)&#123;                   <span class="hljs-comment">/* 前后非空闲 */</span><br>  insert_free_block(bp);<br>  <span class="hljs-keyword">return</span> bp;<br>&#125;<br></code></pre></td></tr></table></figure><p>前后均不空闲的时候就直接插入当前空闲块，并返回bp</p><ul><li><strong>Case2: 后空闲</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; !next_alloc)&#123;             <span class="hljs-comment">/* 后空闲 */</span><br>  size += NEXT_BLKSZ(bp);<br>  delete_free_block(NEXT_BLKP(bp));<br>  PUT(HDRP(bp), PACK(size, FREE));<br>  PUT(FTRP(bp), PACK(size, FREE));<br>  PUT(PRED(bp), <span class="hljs-literal">NULL</span>);<br>  PUT(SUCC(bp), <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    后空闲的时候就从空闲链表中删除后方空闲块，并把当前块的头部和后部块的尾部大小设计为扩展后大小 <em>( 由于 FTRP 中调用了 HDRP，所以先设计HDRP的size之后FTRP能够正确定位到尾部 )</em> 并且设置空闲块前驱后继指针为NULL做好清理。</p><ul><li><strong>Case3:</strong> 前空闲</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>(!prev_alloc &amp;&amp; next_alloc) &#123;            <span class="hljs-comment">/* 前空闲 */</span><br>  size += PREV_BLKSZ(bp);<br>  delete_free_block(PREV_BLKP(bp));<br><br>  PUT(FTRP(bp), PACK(size, FREE));<br>  PUT(HDRP(PREV_BLKP(bp)), PACK(size, FREE));<br><br>  bp = PREV_BLKP(bp);<br>  PUT(PRED(bp), <span class="hljs-literal">NULL</span>);<br>  PUT(SUCC(bp), <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    前空闲就从空闲链表中删除前方空闲块，并且注意分配的头部标记是前一块的头部标记，其余逻辑和 Case2类似</p><ul><li><strong>Case4:</strong> 前后均非空闲</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">else</span>&#123;<span class="hljs-comment">/* 前后均空闲 */</span><br>  size += NEXT_BLKSZ(bp) + PREV_BLKSZ(bp);<br>  delete_free_block(PREV_BLKP(bp));<br>  delete_free_block(NEXT_BLKP(bp));<br>  PUT(HDRP(PREV_BLKP(bp)), PACK(size, FREE));<br>  PUT(FTRP(NEXT_BLKP(bp)), PACK(size, FREE));<br>  bp = PREV_BLKP(bp);<br>  PUT(PRED(bp), <span class="hljs-literal">NULL</span>);<br>  PUT(SUCC(bp), <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    前两种的结合，不多赘述</p><h3 id="insert-free-block-插入空闲链表"><a href="#insert-free-block-插入空闲链表" class="headerlink" title="insert_free_block 插入空闲链表"></a>insert_free_block 插入空闲链表</h3><p>​    插入空闲链表算是一个比较重要的函数，其关乎着空闲块的组织结构，在这里我采用的是<strong>地址排序</strong>的策略。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert_free_block</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fbp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 地址排序 - Address Order</span><br>    <span class="hljs-keyword">void</span> *succ = root;<br>    <br>    <span class="hljs-keyword">while</span>(SUCC_BLKP(succ))&#123;<br>        succ = (<span class="hljs-keyword">char</span> *)SUCC_BLKP(succ);<br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)succ &gt;= (<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>)fbp)&#123;<br>            <span class="hljs-comment">// 安装地址顺序插入空闲块</span><br>            <span class="hljs-comment">// PRED_BLKP(succ) &lt;-&gt; fbp &lt;-&gt; succ</span><br>            <span class="hljs-keyword">char</span> *tmp = succ;<br>            succ = (<span class="hljs-keyword">char</span> *)PRED_BLKP(succ);<br>            PUT(SUCC(succ), fbp);<br>            PUT(PRED(fbp), succ);<br>            PUT(SUCC(fbp), tmp);<br>            PUT(PRED(tmp), fbp);<br>            <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> INDEBUG</span><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;succ(PRE): %p \t tmp(SUCC): %p \t&quot;</span>, succ, tmp);<br>                print_free_list(<span class="hljs-string">&quot;Insert&quot;</span>);<br>            <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">// Base Case &amp; Last Case </span><br>    <span class="hljs-comment">// 当前大小类无空闲块 或者 在地址分配时当前空闲块地址最大被分配在最后</span><br>    PUT(SUCC(succ), fbp);<br>    PUT(PRED(fbp), succ);<br>    PUT(SUCC(fbp), <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    首先获得目标块的 index，即属于二的几次幂，之后通过 <code>global_list_start_ptr</code> 加上 index 偏移定位到其属于的大小类链表的 root 指针，如果root指针有指向就进行地址顺序的排序，如果找到后部块地址大于插入块，就把该插入块插到上述块的前部。</p><p>​    如果root没有指向，即当前该大小类中没有空闲块，或者按地址序，该块地址大小最大则进行直接的分配在succ之后。</p><h3 id="delete-free-block-删除空闲块"><a href="#delete-free-block-删除空闲块" class="headerlink" title="delete_free_block 删除空闲块"></a>delete_free_block 删除空闲块</h3><p>​    删除空闲块要注意，这里常见的bug是和 insert_free_block 一同出现的指针维护不良，导致删除不存在的块，或者访问 nullptr 的前后继以及指针越界问题。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">delete_free_block</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *fbp)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// NORMAL: GOT A SUCCESSOR AND PREDECESSOR</span><br>    <span class="hljs-keyword">if</span>(SUCC_BLKP(fbp) &amp;&amp; PRED_BLKP(fbp))&#123;<br>        PUT(SUCC(PRED_BLKP(fbp)), SUCC_BLKP(fbp));<br>        PUT(PRED(SUCC_BLKP(fbp)), PRED_BLKP(fbp));<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(PRED_BLKP(fbp))&#123; <span class="hljs-comment">// LAST BLOCK</span><br>        PUT(SUCC(PRED_BLKP(fbp)), <span class="hljs-literal">NULL</span>);<br>    &#125;<br><br>    PUT(SUCC(fbp), <span class="hljs-literal">NULL</span>);<br>    PUT(PRED(fbp), <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    正常情况是当前块是链表中间节点，重新连接好前后，把其从链表上脱离即可。如果是最后一个节点，就直接把前继节点的后继指针置为空。最后做好当前删除块的清理工作，把其前后继指针置为NULL</p><h3 id="mm-malloc-分配空闲块"><a href="#mm-malloc-分配空闲块" class="headerlink" title="mm_malloc 分配空闲块"></a>mm_malloc 分配空闲块</h3><p>​    mm_malloc 是该lab中的主要函数，用于控制分配内存块的工作。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mm_malloc</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> asize = align_size(size);    <span class="hljs-comment">/* 调整后的块大小 */</span><br>    <span class="hljs-keyword">size_t</span> extendsize;                  <span class="hljs-comment">/* 扩展堆大小 */</span><br>    <span class="hljs-keyword">char</span> *bp;<br><br>    <span class="hljs-comment">/* Trivial Case */</span><br>    <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-comment">/* 寻找适配 */</span><br>    <span class="hljs-keyword">if</span>((bp = find_fit(asize, get_index(asize))) != <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> place(bp, asize);<br><br>    <span class="hljs-comment">/* 未找到适配，分配更多堆空间 */</span><br>    extendsize = MAX(asize, CHUNKSIZE);<br>    <span class="hljs-keyword">if</span>((bp = extend_heap(extendsize)) == <span class="hljs-literal">NULL</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br>    <span class="hljs-keyword">return</span> place(bp, asize);<br>&#125;<br></code></pre></td></tr></table></figure><p>​    首先要做好分配大小的对齐，这里定义了一个util函数 align_size 用来对齐块大小。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">size_t</span> <span class="hljs-title">align_size</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">/* 调整块大小 */</span><br>    <span class="hljs-keyword">if</span>(size &lt;= DSIZE) <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>*DSIZE;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> DSIZE * ((size + (DSIZE) + (DSIZE - <span class="hljs-number">1</span>)) / DSIZE);<br><br>    <span class="hljs-comment">// Code Never Went Here</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    之后逻辑就是通过 find_fit 在空闲链表中寻找适配，如果没找到适配就进行 heap_extend，每次最小扩展 <code>CHUNKSIZE</code> bytes，这里我将 <code>CHUNKSIZE</code> 设为 512</p><p> <strong>(有讲究，如果大于520就会导致realloc2的第一次分配 512 就能够成功，这样之后alloc的块就跟在512块后，就不能成功的将 realloc 的 0 号 block 安排在块位，导致无法通过 extend_heap 来提高性能)</strong></p><p>最后放置空闲块，使用place函数进行分配和分割</p><h3 id="find-fit-寻找适配"><a href="#find-fit-寻找适配" class="headerlink" title="find_fit 寻找适配"></a>find_fit 寻找适配</h3><p>​    我使用的是简单的首次适配，即从小到大遍历分离空闲链表，找到第一块适合的空闲块。由于每个空闲链表内部是按地址顺序排列而非大小排列，所以其效果并非严格等同于 best_fit 但是由于大小分块的组织结构，其效果又好于完全不按空间大小排序的适配方式。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">find_fit</span><span class="hljs-params">(<span class="hljs-keyword">size_t</span> size, <span class="hljs-keyword">int</span> seg_idx)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// First Fit</span><br>    <span class="hljs-keyword">char</span>* res;<br>    <span class="hljs-keyword">while</span>(seg_idx &lt; SEG_LEN)&#123;<br>        <span class="hljs-keyword">char</span> *root = global_list_start_ptr + seg_idx * WSIZE;<br>        <span class="hljs-keyword">char</span> *bp = (<span class="hljs-keyword">char</span> *)SUCC_BLKP(root);<br>        <span class="hljs-keyword">while</span>(bp)&#123;<br>            <span class="hljs-keyword">if</span>((<span class="hljs-keyword">size_t</span>)CRT_BLKSZ(bp) &gt;= size)<br>                <span class="hljs-keyword">return</span> bp;<br>            <br>            bp = (<span class="hljs-keyword">char</span> *)SUCC_BLKP(bp);<br>        &#125;<br>        <span class="hljs-comment">// 在这类中未找到适合，在更大类中寻找</span><br>        seg_idx++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="place-分配块"><a href="#place-分配块" class="headerlink" title="place 分配块"></a>place 分配块</h3><p>​    分配块这里有说法了，第一层是分配空闲块的时候，如果当前适配的块大小比需要分配的大很多（超出最小空闲块大小 16bytes）那么我们就可以通过分割来减小内部碎片。</p><p>​    并且这个分割也是很有讲究，我们可以设计当需要分配的空间较大时例如大于64 bytes，我们就将其分配在空闲块的后部，将前部分割出来作为新的空闲块。如果小于就直接分配在当前空闲块的前部，将后部分割出来作为新的空闲块。这样的组织方式有两方面好处，</p><ul><li>一方面是其进行了大小分类，有利于块的合并</li><li>另一方面是对于 realloc2 的测试 trace，我们通过前部切分的方式，使 512 块后再次分配的两 128 块占用前部空间，这样可以使 512 块始终是最后一块即其后继块是结尾块，那么在 realloc 它的时候我们就可以直接通过 extend_heap 达到如此一来可以大大提高内存利用率，<strong>将realloc1、2的util提升至近100%！</strong></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> *<span class="hljs-title">place</span><span class="hljs-params">(<span class="hljs-keyword">char</span> *bp, <span class="hljs-keyword">size_t</span> asize)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">size_t</span> blk_size = CRT_BLKSZ(bp);<br>    <span class="hljs-keyword">size_t</span> rm_size = blk_size - asize;<br><br>    <span class="hljs-keyword">if</span>(!GET_ALLOC(HDRP(bp)))<br>        delete_free_block(bp);<br>    <span class="hljs-comment">// 剩余空间大于最小块大小的可分割的情况</span><br>    <span class="hljs-keyword">if</span>(rm_size &gt;= <span class="hljs-number">2</span>*DSIZE)&#123;<br>        <span class="hljs-comment">// 当块大小大于 64 时将其有效载荷放在空闲块后部，前部切分出来作为空闲块</span><br>        <span class="hljs-keyword">if</span>(asize &gt; <span class="hljs-number">64</span>)&#123;<br>            PUT(HDRP(bp), PACK(rm_size, FREE));<br>            PUT(FTRP(bp), PACK(rm_size, FREE));<br>            PUT(HDRP(NEXT_BLKP(bp)), PACK(asize, ALLOCATED));<br>            PUT(FTRP(NEXT_BLKP(bp)), PACK(asize, ALLOCATED));<br>            coalesce(bp);<br>            <span class="hljs-keyword">return</span> NEXT_BLKP(bp);<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            PUT(HDRP(bp), PACK(asize, ALLOCATED));<br>            PUT(FTRP(bp), PACK(asize, ALLOCATED));<br>            PUT(HDRP(NEXT_BLKP(bp)), PACK(rm_size, FREE));<br>            PUT(FTRP(NEXT_BLKP(bp)), PACK(rm_size, FREE));<br><br>            coalesce(NEXT_BLKP(bp));<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 不可分割情况</span><br>    <span class="hljs-keyword">else</span>&#123;<br>        PUT(HDRP(bp), PACK(blk_size, ALLOCATED));<br>        PUT(FTRP(bp), PACK(blk_size, ALLOCATED));<br>    &#125;<br>    <span class="hljs-keyword">return</span> bp;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mm-free-释放块"><a href="#mm-free-释放块" class="headerlink" title="mm_free 释放块"></a>mm_free 释放块</h3><p>​    直接设置空闲，并释放同时合并，没什么好说的</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mm_free</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">ifdef</span> DEBUG</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Freeing.....\n&quot;</span>);<br>    <span class="hljs-meta">#<span class="hljs-meta-keyword">endif</span></span><br>    <span class="hljs-keyword">char</span> *bp = ptr;<br>    <span class="hljs-keyword">size_t</span> size = CRT_BLKSZ(bp);<br><br>    PUT(HDRP(bp), PACK(size, FREE));<br>    PUT(FTRP(bp), PACK(size, FREE));<br>    coalesce(bp);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mm-realloc-重分配块"><a href="#mm-realloc-重分配块" class="headerlink" title="mm_realloc 重分配块"></a>mm_realloc 重分配块</h3><p>​    mm_realloc 能否做好是分数能否上 90 的关键，其主要策略有两个</p><ul><li><p><strong>空闲块融合</strong></p><p>一在重分配的时候，如果后方有空闲块可以进行融合，再看空间够不够，如果够了就不用释放再分配了。</p><p>（同时前融合也应当有相应的效果，前融合要注意内部载荷数据的移动，但其实观察 trace 文件下的block组织表现，发现其实前融合很少甚至没有，对性能影响不大，之后便在代码中删除了）</p></li><li><p><strong>尾部堆扩展</strong></p><p>就是之前提到的如果要重分配的块是尾部块就执行 extend_heap 就行了，不需要释放再分配。同时注意到了 trace 文件中反复 realloc 首次分配的块，于是和 place 中提到的策略相互结合可以达到将首次分配的块移动到末尾的效果。</p></li></ul><p>其余就是一些基础写法，在注释中已经体现，还有需要注意一下<strong>分配大小的对齐</strong>和特殊情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mm_realloc</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *ptr, <span class="hljs-keyword">size_t</span> size)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 如果 ptr == NULL 直接分配</span><br>    <span class="hljs-keyword">if</span>(ptr == <span class="hljs-literal">NULL</span>)    <br>        <span class="hljs-keyword">return</span> mm_malloc(size);<br>    <span class="hljs-comment">// 如果 size == 0 就释放</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)&#123;<br>        mm_free(ptr);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">size_t</span> asize = align_size(size), old_size = CRT_BLKSZ(ptr);<br>    <span class="hljs-keyword">size_t</span> mv_size = MIN(asize, old_size);<br>    <span class="hljs-keyword">char</span> *oldptr = ptr;<br>    <span class="hljs-keyword">char</span> *newptr;<br><br>    <span class="hljs-keyword">if</span>(old_size == asize)<br>        <span class="hljs-keyword">return</span> ptr;<br>    <br>    <span class="hljs-keyword">size_t</span> prev_alloc =  GET_ALLOC(FTRP(PREV_BLKP(ptr)));<br>    <span class="hljs-keyword">size_t</span> next_alloc =  GET_ALLOC(HDRP(NEXT_BLKP(ptr)));<br>    <span class="hljs-keyword">size_t</span> next_size = NEXT_BLKSZ(ptr);<br>    <span class="hljs-keyword">char</span> *next_bp = NEXT_BLKP(ptr);<br>    <span class="hljs-keyword">size_t</span> total_size = old_size;<br><br>    <span class="hljs-keyword">if</span>(prev_alloc &amp;&amp; !next_alloc &amp;&amp; (old_size + next_size &gt;= asize))&#123;    <span class="hljs-comment">// 后空闲  </span><br>        total_size += next_size;<br>        delete_free_block(next_bp);<br>        PUT(HDRP(ptr), PACK(total_size, ALLOCATED));<br>        PUT(FTRP(ptr), PACK(total_size, ALLOCATED));<br>        place(ptr, total_size);<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(!next_size &amp;&amp; asize &gt;= old_size)&#123;   <span class="hljs-comment">// 如果后部是结尾块，则直接 extend_heap</span><br>        <span class="hljs-keyword">size_t</span> extend_size = asize - old_size;<br>        <span class="hljs-keyword">if</span>((<span class="hljs-keyword">long</span>)(mem_sbrk(extend_size)) == <span class="hljs-number">-1</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <br>        <br>        PUT(HDRP(ptr), PACK(total_size + extend_size, ALLOCATED));<br>        PUT(FTRP(ptr), PACK(total_size + extend_size, ALLOCATED));<br>        PUT(HDRP(NEXT_BLKP(ptr)), PACK(<span class="hljs-number">0</span>, ALLOCATED)); <br>        place(ptr, asize);<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;   <span class="hljs-comment">// 直接分配</span><br>        newptr = mm_malloc(asize);<br>        <span class="hljs-keyword">if</span>(newptr == <span class="hljs-literal">NULL</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">memcpy</span>(newptr, ptr, MIN(old_size, size));<br>        mm_free(ptr);<br>        <span class="hljs-keyword">return</span> newptr;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="关于DEBUG"><a href="#关于DEBUG" class="headerlink" title="关于DEBUG"></a>关于DEBUG</h2><p>​    代码中为了 DEBUG 定义了大量 debug util 函数和 Error Handler，如果想清晰的看清楚堆块的组织结构，调用它们是很有帮助的。还有 debug 要善用 gdb…</p><h2 id="四、实验结果"><a href="#四、实验结果" class="headerlink" title="四、实验结果"></a>四、实验结果</h2><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqqcdfltwxj309s088aal.jpg"></p><p>​    在不使用BST和全局数据结构的情况下达到了 97/100 的分数，还不错。</p><h2 id="五、结语"><a href="#五、结语" class="headerlink" title="五、结语"></a>五、结语</h2><p>​    这个Lab用了我2、3天的时间，是比较难的，需要用心 DEBUG 考验 gdb的使用。Malloc Lab 还是很好玩的，ddl之后我可能会考虑进一步优化，采用BST结构尽量做到接近 100/100</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Malloc</tag>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 动态内存分配机制详解</title>
    <link href="/AcceptedHelper/2021/05/21/Dynamic%20Memory%20Allocation/"/>
    <url>/AcceptedHelper/2021/05/21/Dynamic%20Memory%20Allocation/</url>
    
    <content type="html"><![CDATA[<p>​    动态内存分配是虚拟内存组织中的核心概念，理解它对于帮助整个linux虚拟内存的组织以及堆上内存分配过程。本文会系统介绍动态内存的分配机制以及内存堆块的组织形式，并最后以 CMU CSAPP Malloc Lab 为例来详细讲解。</p><p><strong>Malloc Lab 代码：<a href="https://github.com/ZiYang-xie/Malloc_Lab">ZiYang-xie/Malloc_Lab: CMU Malloc Lab Repo (github.com)</a></strong> </p><p>在开始介绍 malloc 机制前，我们先看一下虚拟内存的组织形式。</p><h1 id="【序】虚拟内存组织形式"><a href="#【序】虚拟内存组织形式" class="headerlink" title="【序】虚拟内存组织形式"></a>【序】虚拟内存组织形式</h1><p>​    linux虚拟内存形式安装堆栈形式组织，栈位于内存高地址，分为内核栈和用户栈，增长方向从高到低。而堆位于内存的低地址，是程序员进行动态内存分配的空间，增长方向由低到高。堆和栈中间是共享映射空间，用于共享库在内存中的映射，这样每次如果有不同代码调用相同的共享库，就不需要再次向内存中复制一份副本，节省了时间和空间。</p><p>​    栈内存的更高地址用于存放一些全局数据结构</p><p>​    堆内存的更低地址按地址从低到高放置着代码段（.text）、已分配数据段（.data）、未分配数据段（.bss）。你可能还听说过 COMMON 段专门储存未初始化全局变量，真正的.bss存储未初始化的静态变量以及初始化为0的全局和静态变量 [1]，组织形式如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c">SECTIONS &#123; <br>  .text : &#123; *(.text) &#125;<br>  .data : &#123; *(.data) &#125; <br>  .bss :  &#123; *(.bss)  *(COMMON) &#125; <br>&#125; <br></code></pre></td></tr></table></figure><p>虚拟内存的大致组成形式如下图所示。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqr0n9olxfj30e80e0gn3.jpg"></p><p>​    可以看到代码段从 <em>0x40000000</em> 处开始，从0到0x40000000的内存地址单纯是未被映射，代码段和0地址之间相隔一段距离在早期是为了防止 nullptr 对代码段的修改<em>（此处仅凭记忆，真实性需要进一步验证</em>）。但如今权限设计更加完善，上述意义已不再成立，这就变成了一种约定俗成的规则。</p><p>在了解了虚拟内存的大致组织模式之后，我们便可以开始讲解 Malloc 的基本机制。</p><h1 id="【一】动态内存分配的实现方式"><a href="#【一】动态内存分配的实现方式" class="headerlink" title="【一】动态内存分配的实现方式"></a>【一】动态内存分配的实现方式</h1><p>​    Linux动态内存分配的实现方式是由 mmap, munmap 以及 brk, sbrk 这四个系统函数联合完成的。</p><h2 id="mmap-与-munmap"><a href="#mmap-与-munmap" class="headerlink" title="mmap 与 munmap"></a>mmap 与 munmap</h2><p><strong>mmap</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">mmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">size_t</span> length, <span class="hljs-keyword">int</span> prot, <span class="hljs-keyword">int</span> flags,</span></span><br><span class="hljs-function"><span class="hljs-params">           <span class="hljs-keyword">int</span> fd, <span class="hljs-keyword">off_t</span> offset)</span></span>;<br></code></pre></td></tr></table></figure><p>mmap 创建一个新的虚拟内存空间和文件设备之间的映射。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNgy1gqr27vczrhj30jd0a9tah.jpg"></p><p>​    其中 addr 代表分配开始地址，fd是相应文件描述符，len是指文件存储部分映射的长度，offset指的是从文件头开始offset距离开始分配。</p><ul><li>prot包含权限位</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">PROT_EXEC <span class="hljs-comment">// 可执行</span><br>PROT_READ <span class="hljs-comment">// 可读</span><br>PROT_WRITE <span class="hljs-comment">// 可写</span><br>PROT_NONE <span class="hljs-comment">// 不可访问</span><br></code></pre></td></tr></table></figure><ul><li>Flags 表示映射对象类型</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c">MAP_ANON <span class="hljs-comment">// 匿名请求二进制零的</span><br>MAP_PRIVATE <span class="hljs-comment">// 私有的</span><br>MAP_SHARED <span class="hljs-comment">// 共享的</span><br></code></pre></td></tr></table></figure><p><strong>munmap</strong></p><p>取消相应地址内存块的映射</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">munmap</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr, <span class="hljs-keyword">size_t</span> length)</span></span>;<br></code></pre></td></tr></table></figure><p>很好理解取消开始地址为 addr 长度为 length 的内存映射。</p><h2 id="brk-与-sbrk"><a href="#brk-与-sbrk" class="headerlink" title="brk 与 sbrk"></a>brk 与 sbrk</h2><p>​    brk, sbrk 用来移动 program break 指向的指针来扩展堆内存，program break 位于堆顶未初始化数据段末尾之后，通过移动 program break 指针来动态控制堆的大小。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqri33m8lkj30ic0huq62.jpg" style="zoom:50%;" /><p><strong>brk</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">brk</span><span class="hljs-params">(<span class="hljs-keyword">void</span> *addr)</span></span>;<br></code></pre></td></tr></table></figure><p>​    brk 会在允许的情况下简单的将 program break 设为 addr 地址，来控制堆内存大小。相当于 program break 的绝对移动</p><p><strong>sbrk</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">sbrk</span><span class="hljs-params">(<span class="hljs-keyword">intptr_t</span> increment)</span></span>;<br></code></pre></td></tr></table></figure><p>​    sbrk 会在允许的情况下将 program break 指针加 increment 值，返回扩展前的 program break 地址。当<code>increment</code>为正值时，堆被扩展；为0时，返回当前 program break 的指针；为负值时，堆被收缩。相当于 program break 的相对移动</p><p>​    值得注意的是，当无法扩展时 (申请了大于允许的内存，或碰到了共享内存段)，sbrk会返回 (void *)-1 并且会设置 errorno 为 <strong>ENOMEM</strong>（ENO Memory）</p><h3 id="关于-sbrk-的更多细节"><a href="#关于-sbrk-的更多细节" class="headerlink" title="关于 sbrk 的更多细节"></a>关于 sbrk 的更多细节</h3><p>​    sbrk 实际上是 linux 的一个上古函数，如今大多数内存分配器都倾向于使用 mmap 而不使用 sbrk，是因为 sbrk 是线程不安全的。由于 sbrk 的组织形式是对 program break 的相对移动来进行对扩展，那么对堆块的组织释放方式只能使用 LIFO。假设 sbrk 函数是原子的，在多进程调用时，如果一个进程要释放一个块，且其正好位于结尾program break处，我们选择 increment 为一个负值进行堆收缩（这是正确的）；但在我们还未释放的时候，另一个进程选择分配内存，调用 sbrk。在分配后我们继续进行释放此时我们需要释放的块后增加了一个新块，再调用 sbrk 会导致另一个进程分配的块被释放从而引发错误。</p><p>​    为了解决这个问题，我们也可以自己设计一个进程安全的 sbrk 函数，称为 sbrk_safe</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">sbrk_safe</span><span class="hljs-params">(<span class="hljs-keyword">intptr_t</span> increment, <span class="hljs-keyword">void</span> *expect_top)</span></span>;<br></code></pre></td></tr></table></figure><p>​    其增加了一个参数expect_top，思想很简单，就是在每次调用 sbrk_safe 的时候将选择释放块的内存地址填入 expect_top，函数中验证其是否是在堆顶，如果不是就返回错误。</p><p>​    （另外 sbrk 可能还有其他问题，比如受到 mmap 分配内存和共享内存的阻碍导致内存分配的间断。这里有待进一步研究探讨）</p><h1 id="【二】动态内存分配器的设计"><a href="#【二】动态内存分配器的设计" class="headerlink" title="【二】动态内存分配器的设计"></a>【二】动态内存分配器的设计</h1><p>​        对于堆上的动态内存分配，我们通常将其组织为“块”的模式，一个块就是指一段连续内存地址，而根据其是否被分配数据又被划分为<strong>空闲块</strong>和<strong>分配块</strong>两种。</p><h2 id="序、内存块结构"><a href="#序、内存块结构" class="headerlink" title="序、内存块结构"></a>序、内存块结构</h2><p>​    首先我们需要了解一个简单的技巧，就是如果有空闲块相邻时我们是可以将其进行合并为一个空闲块的，这样一来我们就可以分配更大的内存，并减少内存的碎片程度。注意到由于我们需要对块进行分配和合并，所以我们必须要知道块的<strong>大小信息</strong>和<strong>块的分类</strong>，因而一个内存块中其并不是所有位置都存储着有效信息。以32位系统为例，双字对齐（8 bytes）我们设计一个块的头部一个字大小（4 bytes）放置着块的大小信息和分配信息，由于是双字对齐的，所以块大小的后3位永远是0（1000）, 因此我们用前29位放大小信息，后3位放置分配信息（实际上是最后一位）001表示已分配、000表示空闲。中间放置有效载荷、即数据段，尾部可有一个填充。</p><p>​    最后注意到我们需要对块进行<strong>合并</strong>（在后文中我们会详细讨论合并策略），所以在尾部也放置一个大小和分配标记有利于下一块相邻块快速找到上一块的分配状态和大小来达成向前合并的操作，所以我们在脚部也增加一个字大小（4 bytes）和头部相同的大小分配标记。这个特征称为<strong>边界标记</strong></p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqrjzzz4iaj30go0dwjyj.jpg" style="zoom:50%;" /><h2 id="一、内存碎片"><a href="#一、内存碎片" class="headerlink" title="一、内存碎片"></a>一、内存碎片</h2><p>​        关于内存分配，首先我们要有一个直观，在组织过程中我们确实可以简单的每次分配内存都创建一个所需大小的块，但经过频繁的分配释放，很快堆上的整块内存就会被划分为十分杂乱的小块。这种情况称之为内存碎片化，内存碎片化是一个十分严重的问题，其可能导致内存极大的浪费，因此要理解动态内存分配器的设计之前首先我们需要理解内存碎片的概念，来帮助我们更好的设计一个性能更加优良的分配器。</p><p>​    关于内存碎片根据其表现形式可以分为两类，内部碎片和外部碎片。</p><h3 id="内部内存碎片"><a href="#内部内存碎片" class="headerlink" title="内部内存碎片"></a>内部内存碎片</h3><p>​    内部内存碎片可以有一个直观的理解（虽然可能有点夸张），就是如果你仅仅需要 1kb 的内存用于存放数据，但是你申请了 2GB 大小的内存空间用来存这 1kb 的数据，那么里面大部分的内存全部都被浪费掉了，这时候如果你再要申请内存，空闲的内存可能就不够了。这就是内部碎片。</p><p>​    这时候有人可能会问，那么我们之间分配需要分配的内存大小就好了啊？那为什么内部碎片还会产生呢？确实说的很对，。但有时候由于内存对齐需要以及分配器策略等影响我们并不能够直接分配正好就是需求大小的内存块，其产生机制我将会在下文中进一步深入讲解</p><h3 id="外部内存碎片"><a href="#外部内存碎片" class="headerlink" title="外部内存碎片"></a>外部内存碎片</h3><p>​    外部内存碎片的产生主要源于频繁的大小不一的内存分配和释放过程。经过一系列的分配释放，最后整块的内存会被切分成空闲块分配块相互交杂的情况，如下图所示，这时候如果我们想要再分配一个 1000 kb 的数据块，可能所有的空闲块加起来是大于 1000 kb 的但是由于没有一个空闲块是大于 1000 kb 的就会导致内存分配的失败。同时由于内存映射已经建立，重整虚拟内存会导致整个程序到虚拟内存，虚拟内存到物理内存的映射表都需要更改，这种花费是我们无法承受的，所以我们需要设计更好的分配方式尽量避免这种碎片化情况的产生。</p><p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqrji3uyl1g30b404l3yd.gif"></p><h2 id="二、空闲块组织模式"><a href="#二、空闲块组织模式" class="headerlink" title="二、空闲块组织模式"></a>二、空闲块组织模式</h2><p>​    关于动态内存分配器的设计其有不同的设计策略，而一种最为常见的区分方式是通过空闲块的组织模式来区分不同的分配器，这里简单介绍两种来自 CSAPP 的空闲块组织模式。</p><h3 id="隐式空闲链表"><a href="#隐式空闲链表" class="headerlink" title="隐式空闲链表"></a>隐式空闲链表</h3><p>​    关于隐式空闲链表，它组织内存空闲块的形式非常简单，可以说是根本没有任何组织，我们可以通过遍历所有堆块（因为我们知道每一个堆块的大小）并验证其是否空闲来找到所有空闲块。所以将这种空闲块组织模式成为隐式空闲链表组织模式。</p><ul><li><p><strong>优点：</strong>简单、无需其他数据结构、节省空间</p></li><li><p><strong>缺点：</strong>时间复杂度高，每次寻找空闲块都需要 O(n) 时间复杂度遍历所有堆块</p></li></ul><h3 id="显示空闲链表"><a href="#显示空闲链表" class="headerlink" title="显示空闲链表"></a>显示空闲链表</h3><p>​    关于显示空闲链表，其是通过在空闲块中间添加两个指针分别指向前趋空闲块和后继空闲块，将空闲块串联成一个链表的模式。这时候我们在全局需要存储一个入口指针指向第一个空闲块，因为其显示的将所有空闲块进行串联，所以我们称这种组织模式为显示空闲链表</p><ul><li><strong>优势：</strong>速度快效率高，只需要 O(m) 遍历所有空闲块</li><li><strong>缺点：</strong>组织复杂，且最小块大小较大（空闲块需要多两个指针的大小）</li></ul><p>在实际的动态内存分配器中我们常常使用显示空闲链表的模式，因为相比于它的效率提升，其多出的空间花费是微不足道的。</p><h2 id="三、空闲块适配模式"><a href="#三、空闲块适配模式" class="headerlink" title="三、空闲块适配模式"></a>三、空闲块适配模式</h2><p>​    说完了空闲块组织模式，我们来谈谈常见的空闲块适配模式，为什么要适配空闲块？当然是因为请求分配一个内存大小的时候要找到一个相应合适的内存块，空闲块适配这个概念和前面讲到的内存碎片有着很大的联系，如果我们选的太大那么就会导致内部碎片的产生（如果没有其他分割策略），如果外部碎片太多，那么我们可能根本找不到合适的空闲块。</p><p>接下来我主要介绍三类空闲块组织模式，首次适配（First Fit）、再次适配（Next Fit)和最佳适配（Best Fit）</p><ul><li><strong>首次适配：</strong> 遍历空闲块找到的第一个合适的空闲块就用来分配 （速度快，内存不一定节省）</li><li><strong>再次适配：</strong>不从头找起，从上一次分配的空闲块继续往下找，找到的第一个适合的空闲块就用来分配 （默认了分配内存的大小基本一致，需要依赖于程序的内存分配特点和空闲块大小组织方式，效率不固定）</li><li><strong>最佳适配：</strong>遍历所有空闲块，找到一个在能够符合分配条件下最小的空闲块来最大化减少内部碎片的产生（内存利用率最佳，但效率较低）</li></ul><h2 id="四、空闲块顺序安排"><a href="#四、空闲块顺序安排" class="headerlink" title="四、空闲块顺序安排"></a>四、空闲块顺序安排</h2><p>​    空闲块顺序安排这个概念是归属于显示空闲链表组织模式下的，隐式空闲链表就完全不会有这个概念（因为根本没有组织xs）</p><p>​    下面来讲讲空闲块的顺序安排，其主要有两种组织形式，LIFO 顺序和地址顺序</p><ul><li><strong>LIFO 顺序：</strong>把释放块插入到空闲链表的开始处，结合首次适配策略，我们便每次会分配适合分配大小的最近释放的空闲块。</li></ul><p>由于我们每次都在空闲块链表开头插入新释放的空闲块，其释放能够在常数时间内 O(1) 完成。</p><ul><li><strong>地址顺序：</strong> 我们也可以简单地按地址顺序安排空闲块链表，即让空闲块链表中空闲块地址从低到高排序，这样符合堆的地址增长方式。</li></ul><p>通常情况下地址顺序结合首次适配的方式比LIFO结合首次适配拥有<strong>更高的内存利用率</strong>，这是从实验中得出的</p><h2 id="五、空闲块的存储技术"><a href="#五、空闲块的存储技术" class="headerlink" title="五、空闲块的存储技术"></a>五、空闲块的存储技术</h2><h3 id="分离适配与分段空闲链表（-Segregated-Free-List-）"><a href="#分离适配与分段空闲链表（-Segregated-Free-List-）" class="headerlink" title="分离适配与分段空闲链表（ Segregated Free List ）"></a>分离适配与分段空闲链表（ Segregated Free List ）</h3><p>​    在实际应用中，我们可以对空闲块的组织模式进行一定的大小分类，通过分类的方式，我们可以进一步减少空闲块的索引时间。</p><p><strong>（这里的思想是运用的分层级的思想，这一思想在计算机科学中无处不在，例如数据库中的多级索引，多级页表的组织等，其实际上就是用分组的形式形成层级结构，通过使用更多的空间来换取索引的时间，是典型的空间换时间模式）</strong></p><p>我们将根据空闲块大小的分类得出的不同类称为大小类，通常在一个最简单的应用中，我们可以使用二的幂次来对其进行表示。在实现上，我们可以将其组织为一个叫做分段空闲链表（Segregated Free List）的组织形式（如下图所示）。</p><img src="https://tva1.sinaimg.cn/large/008i3skNly1gqrl8pm35nj30wc0u0aj5.jpg" style="zoom:40%;" /><p>​    例如我们将空闲块按二的幂次分为 MAX_ORDER 个大小类，每个 index = i 维护一个链表，连接着一类大小位于 $ 2^{i - 1}$ ~ $2^i$ 的空闲块，这样的组织形式，我们就可以先根据分配需求索引大类的大小，定位之后再进入链表根据适配规则适配空闲块。</p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1] <em>Computer Systems: A Programmer’s Perspective</em>, 3/E (CS:APP3e). Randal E. Bryant and David R. O’Hallaron, Carnegie Mellon University.  Page 469</p><p>[2] <a href="https://lifecs.likai.org/2010/02/sbrk-is-not-thread-safe.html">Life of a Computer Scientist: sbrk() is not thread safe (likai.org)</a></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Malloc</tag>
      
      <tag>VM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算理论基础思维导图</title>
    <link href="/AcceptedHelper/2021/04/07/mind-map-for-intro-to-comp-thry/"/>
    <url>/AcceptedHelper/2021/04/07/mind-map-for-intro-to-comp-thry/</url>
    
    <content type="html"><![CDATA[<p>这是计算理论基础前五周的思维导图。(pdf请使用chrome浏览器)</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/FDU19CS/AcceptedHelper@hexo/source/_posts/mind-map-for-intro-to-comp-thry/mind-map-for-intro-to-comp-thry.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>计算理论基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>孙若诗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0324ICSHW问题汇总</title>
    <link href="/AcceptedHelper/2021/03/30/0324ICSHW%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/AcceptedHelper/2021/03/30/0324ICSHW%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h2 id="1-关于作业7-13B，为什么两个文件objdump的结果一样，但是通过diff比较二进制文件得出的结果不同？"><a href="#1-关于作业7-13B，为什么两个文件objdump的结果一样，但是通过diff比较二进制文件得出的结果不同？" class="headerlink" title="1.关于作业7.13B，为什么两个文件objdump的结果一样，但是通过diff比较二进制文件得出的结果不同？"></a>1.关于作业7.13B，为什么两个文件objdump的结果一样，但是通过diff比较二进制文件得出的结果不同？</h2><p>-g主要是加了debug section，它包含了符号表，如果没有-g的内容，用gdb进行debug时，它并不知道每一行是什么内容，也不能print i变量，因为local variable会丢失，它只知道有个内存地址，不知道变量是i，但是如果使用-g选项，就可以添加这些信息。</p><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210330001135.jpg" alt="image-20210329234104958"></p><p><code>objdump</code>相当于只读了.text内容，其他地方都没有读。</p><h2 id="2-关于补充作业题中的链接时出现segmentation-fault"><a href="#2-关于补充作业题中的链接时出现segmentation-fault" class="headerlink" title="2.关于补充作业题中的链接时出现segmentation fault"></a>2.关于补充作业题中的链接时出现<code>segmentation fault</code></h2><h3 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h3><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210330001208.jpg" alt="image-20210329234104958"></p><h3 id="出错原因（此处为tyf的解释，可能复述的有不到位的地方）："><a href="#出错原因（此处为tyf的解释，可能复述的有不到位的地方）：" class="headerlink" title="出错原因（此处为tyf的解释，可能复述的有不到位的地方）："></a>出错原因（此处为tyf的解释，可能复述的有不到位的地方）：</h3><p>-e main是进入到main，但是此前没有执行虚拟内存映射，导致地址出错，出现segmentation fault，进入_start可以，因为 _start中会调用libc_start，（因为源码不公开，所以并不知道这其中做了什么，但是猜想它进行了虚拟内存映射），如果删去-e _start，即为默认值，也是可以正常运行的。</p><p>libc_start是定义在crt1.o中的，只要把它放在main之前，就可以进入。</p><h3 id="用main也可以正常运行的方法："><a href="#用main也可以正常运行的方法：" class="headerlink" title="用main也可以正常运行的方法："></a>用main也可以正常运行的方法：</h3><p>不要链接crt1.o，将entry point设为main，这样会进入main，main会return，return之后立刻会有segmentation fault，此时将return 0 改为 exit 0就可以了，因为exit调用的是system call，会执行一个中断。</p><h2 id="3-程序加载的过程"><a href="#3-程序加载的过程" class="headerlink" title="3.程序加载的过程"></a>3.程序加载的过程</h2><p>在进入main函数之前，首先会有一个程序准备全局变量等，最后来调用main函数，把他的参数传入，执行main函数，会return 0 给一个结束的程序，它会将一些“善后”的工作做完。如果入口是main函数，则上述准备操作均没有做，就return到一个系统不知道在哪儿的位置，所以会segmentation fault，但如果用exit就没有问题。</p><h2 id="4-标准的链接格式"><a href="#4-标准的链接格式" class="headerlink" title="4.标准的链接格式"></a>4.标准的链接格式</h2><p><code>ld -o OUTPUT crt1.o crti.o crtbegin.o [-L paths] [user objects] [gcc libs] [C libs] [gcc libs] crtend.o crtn.o</code></p><p>感谢谭一凡的耐心解答！</p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>曹丝露</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>0324ICSHW答案</title>
    <link href="/AcceptedHelper/2021/03/29/0324ICSHW%E7%AD%94%E6%A1%88/"/>
    <url>/AcceptedHelper/2021/03/29/0324ICSHW%E7%AD%94%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h1 id="ICS作业-链接2参考"><a href="#ICS作业-链接2参考" class="headerlink" title="ICS作业-链接2参考"></a>ICS作业-链接2参考</h1><h2 id="7-10"><a href="#7-10" class="headerlink" title="7.10"></a>7.10</h2><p>A.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ p.o libx.a<br></code></pre></td></tr></table></figure><p>B.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ p.o libx.a liby.a libx.a<br></code></pre></td></tr></table></figure><p>C.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">g++ p.o libx.a liby.a libx.a libz.a<br></code></pre></td></tr></table></figure><h2 id="7-11"><a href="#7-11" class="headerlink" title="7.11"></a>7.11</h2><p>因为有.BSS区域，该区域在可执行文件中并不分配空间；而在加载入内存时进行分配，因此要预留出0x230字节。</p><h2 id="7-12"><a href="#7-12" class="headerlink" title="7.12"></a>7.12</h2><p>A.</p><p>$*refptr = ADDR(r.symbol)+r.addend-refaddr$</p><p>$=0x4004f8-4-(0x4004e0+0xa)=0xa$</p><p>B.</p><p>$*refptr = ADDR(r.symbol)+r.addend-refaddr$</p><p>$=0x400500-4-(0x4004d0+0xa)=0x22$</p><h2 id="7-13"><a href="#7-13" class="headerlink" title="7.13"></a>7.13</h2><h3 id="A"><a href="#A" class="headerlink" title="A."></a>A.</h3><h4 id="寻找libc-a和libm-a"><a href="#寻找libc-a和libm-a" class="headerlink" title="寻找libc.a和libm.a"></a>寻找libc.a和libm.a</h4><p>使用如下的命令，找到库的位置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">gcc --print-file-name=libc.a<br>gcc --print-file-name=libm.a<br></code></pre></td></tr></table></figure><p>得出这两个文件均在<code>/usr/lib/aarch64-linux-gnu</code>目录下</p><h4 id="查找有多少个Object-Files"><a href="#查找有多少个Object-Files" class="headerlink" title="查找有多少个Object Files"></a>查找有多少个Object Files</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /usr/lib/aarch64-linux-gnu<br>ar -t libc.a | wc -l<br>ar -t libm.a | wc -l<br></code></pre></td></tr></table></figure><p>得出结论，在libc.a下有1616个Object file，在libm.a下有576个Object file</p><h3 id="B"><a href="#B" class="headerlink" title="B."></a>B.</h3><p>他们产生的二进制文件是不同的，-g会携带更多的debug和符号信息。</p><p>使用如下命令即可看出他们之间的差别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">xxd main&gt;main.binary<br>xxd maing&gt;maing.binary<br>colordiff -y main.binary maing.binary<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210329221556.png"></p><p>事实上，添加的部分为debug section，可以用readelf读出来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">readelf -wi main # No output<br>readelf -wi maing<br></code></pre></td></tr></table></figure><blockquote><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs excel">i<br>=<span class="hljs-built_in">info</span><br></code></pre></td></tr></table></figure><p>Displays the contents of the ‘.debug_info’ section. Note: the output from this option can also be restricted by the use of the –dwarf-depth and –dwarf-start options.</p></blockquote><h4 id="C"><a href="#C" class="headerlink" title="C."></a>C.</h4><p>使用ldd分析任意一个可执行文件，可看出在我的电脑上(Ubuntu20.04 aarch64)，动态链接库如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash">ldd /usr/bin/ls</span>                <br>linux-vdso.so.1 (0x0000ffff81faf000)<br>libselinux.so.1 =&gt; /lib/aarch64-linux-gnu/libselinux.so.1 (0x0000ffff81f05000)<br>libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6 (0x0000ffff81d92000)<br>/lib/ld-linux-aarch64.so.1 (0x0000ffff81f7f000)<br>libpcre2-8.so.0 =&gt; /lib/aarch64-linux-gnu/libpcre2-8.so.0 (0x0000ffff81d04000)<br>libdl.so.2 =&gt; /lib/aarch64-linux-gnu/libdl.so.2 (0x0000ffff81cf0000)<br>libpthread.so.0 =&gt; /lib/aarch64-linux-gnu/libpthread.so.0 (0x0000ffff81cc0000)<br></code></pre></td></tr></table></figure><ul><li>linux-vdso.so.1</li><li>libselinux.so.1 =&gt; /lib/aarch64-linux-gnu/libselinux.so.1 </li><li>libc.so.6 =&gt; /lib/aarch64-linux-gnu/libc.so.6</li><li>/lib/ld-linux-aarch64.so.1</li><li>libpcre2-8.so.0 =&gt; /lib/aarch64-linux-gnu/libpcre2-8.so.0 </li><li>libdl.so.2 =&gt; /lib/aarch64-linux-gnu/libdl.so.2</li><li>libpthread.so.0 =&gt; /lib/aarch64-linux-gnu/libpthread.so.0 </li></ul><h2 id="补充习题"><a href="#补充习题" class="headerlink" title="补充习题"></a>补充习题</h2><h3 id="1-补充源码"><a href="#1-补充源码" class="headerlink" title="1.补充源码"></a>1.补充源码</h3><p>源码和Makefile见附带的文件</p><p>编译成功后的截图如下</p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210329195524.png" style="zoom:50%;" /><h3 id="2-手动编译"><a href="#2-手动编译" class="headerlink" title="2. 手动编译"></a>2. 手动编译</h3><p>使用了两种方法，第一种直接使用<code>gcc -v</code>的编译参数，第二种使用更简单的手动链接</p><h4 id="gcc-v式的"><a href="#gcc-v式的" class="headerlink" title="gcc -v式的"></a>gcc -v式的</h4><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210329200556.png"></p><p>能正常编译并运行</p><h4 id="手动链接式的"><a href="#手动链接式的" class="headerlink" title="手动链接式的"></a>手动链接式的</h4><p>在我们进行链接之前，需要先解释各个系统库有什么用，才能进行选择性的简化链接</p><ul><li>libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f3496d10000) - C标准库动态共享对象</li><li>/lib64/ld-linux-x86-64.so.2 (0x00007f3497303000) - 动态链接器/加载器</li><li>crt1.o：包含入口函数_start(该函数执行了上一节所描述的整个程序执行过程)，以及未定义的符号__libc_start_main、main</li><li>crti.o: 提供.init节和.fini节的序言(function prologs)</li><li>crtn.o: 提供.init节和.fini节的尾言(function epilogs)</li><li>crtbegin.o: 提供构造函数的首地址(但在本题中，因为没有构造函数，因此不需要链接)</li><li>crtend.o: 提供析构函数的首地址(同上)</li></ul><p>具体到本题中，使用如下命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">crt1.o=/usr/lib/x86_64-linux-gnu/crt1.o<br>crti.o=/usr/lib/x86_64-linux-gnu/crti.o<br>crtn.o=/usr/lib/x86_64-linux-gnu/crtn.o<br>crtbeginS.o=/usr/lib/gcc/x86_64-linux-gnu/7/crtbeginS.o<br>crtendS.o=/usr/lib/gcc/x86_64-linux-gnu/7/crtendS.o<br>ld.so=/lib64/ld-linux-x86-64.so.2<br>libc.so=/usr/lib/x86_64-linux-gnu/libc.so<br>ld -dynamic-linker $(ld.so) -o main $(crt1.o) $(crti.o) main.o BubbleSort.o add.o printResult.o $(libc.so) $(crtn.o)<br></code></pre></td></tr></table></figure><h3 id="3-OBJDUMP进行反汇编"><a href="#3-OBJDUMP进行反汇编" class="headerlink" title="3.OBJDUMP进行反汇编"></a>3.OBJDUMP进行反汇编</h3><p>使用<code>objdump -S main.o &gt; main.S</code>将反编译形成的汇编码写入<code>main.S</code>文件中</p><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210329201203.png"></p><h3 id="4-生成调试信息后，使用GDB进行调试"><a href="#4-生成调试信息后，使用GDB进行调试" class="headerlink" title="4. 生成调试信息后，使用GDB进行调试"></a>4. 生成调试信息后，使用GDB进行调试</h3><p>使用了list, break, start, run, continue, info等多种命令进行了调试，在此处限于截图篇幅，仅截取部分</p><p><img src="https://cdn.jsdelivr.net/gh/Outsider565/ImageBed@master/20210329201939.png"></p><h3 id="5-相关问题"><a href="#5-相关问题" class="headerlink" title="5. 相关问题"></a>5. 相关问题</h3><ol><li><p>分析同一个源程序在不同机器上生成的可执行目标代码是否相同</p><ol><li>ISA: 在arm处理器和x86处理器上，显然有不同的可执行目标文件代码</li><li>OS：在windows和linux上有不同的寄存器分配规则，在windows64上的函数调用采用<code>RCX</code>,<code>RDX</code>,<code>R8</code>,<code>R9</code>的寄存器调用顺序，在Linux64上采用的函数调用寄存器为<code>RDI</code>,<code>RSI</code>,<code>RDX</code>,<code>RCX</code>,<code>R8</code>,<code>R9</code></li><li>编译器：不同编译器会采用不同的优化策略，生成的可执行目标代码可能不同</li></ol></li><li><p>你能在可执行目标文件中找出函数printf ()对应的机器代码段吗？能的话，请标示出来。</p><p>不能，printf函数所对应的机器代码段在libc.so中，是在运行时调用的，因此无法找到。</p><p>事实上，的确有printf@plt（Procedure linkage table)这一函数，但这仅仅是一个找到真实printf代码的stub</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">0000000000000710 &lt;printf@plt&gt;:<br> 710:ff 25 9a 18 20 00    jmpq   *0x20189a(%rip)        # 201fb0 &lt;printf@GLIBC_2.2.5&gt;<br> 716:68 03 00 00 00       pushq  $0x3<br> 71b:e9 b0 ff ff ff       jmpq   6d0 &lt;.plt&gt;<br></code></pre></td></tr></table></figure></li><li><p>为什么源程序文件的内容和可执行目标文件的内容完全不同？</p><p>源程序文件的内容为文本文件，是编程语言代码；可执行目标文件为CPU可以运行的二进制代码，自然不同。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>王少文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Code for ICS HW4</title>
    <link href="/AcceptedHelper/2021/03/28/Code-for-ICS-HW4/"/>
    <url>/AcceptedHelper/2021/03/28/Code-for-ICS-HW4/</url>
    
    <content type="html"><![CDATA[<p>本文提供了ICS HW4补充作业中需要的初始代码。</p><h4 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;add.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;BubbleSort.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;printResult.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;time.h&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> bool char</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> true 1</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> false 0</span><br><span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> LENGTH 10</span><br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">int</span> a[LENGTH],i;<br>    <span class="hljs-keyword">int</span> b[LENGTH];<br>    <span class="hljs-keyword">int</span> randValue = <span class="hljs-number">0</span>;<br>    srand(time(<span class="hljs-literal">NULL</span>));<br>    <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;LENGTH;i++)&#123;<br>        randValue = <span class="hljs-number">1</span> + (<span class="hljs-keyword">int</span>)rand()%LENGTH;<br>        a[i] = randValue;<br>        b[i] = a[i];<br>    &#125;<br>    printResult(a,LENGTH,<span class="hljs-string">&quot;\nrandom array: &quot;</span>);<br>    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">while</span>(flag)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n1.Bubble Sort\n2.sum\n3.print result\n4.exit&quot;</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nchoose a number:&quot;</span>);<br>        <span class="hljs-keyword">int</span> number = <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;number);<br>        <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">switch</span>(number)<br>        &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                BubbleSort(a,LENGTH);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>                sum = add(a,LENGTH);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nresult of sum: %d\n&quot;</span>,sum);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>:<br>                printResult(b,LENGTH,<span class="hljs-string">&quot;\noriginal array:\t&quot;</span>);<br>                printResult(a,LENGTH,<span class="hljs-string">&quot;\nsorted array:\t&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>:<br>                flag = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nplease choose a correct number and continue!&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\nDone!\n\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="add-c"><a href="#add-c" class="headerlink" title="add.c"></a>add.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;add.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[],<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">//Write your code here</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="add-h"><a href="#add-h" class="headerlink" title="add.h"></a>add.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[],<span class="hljs-keyword">int</span> n)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="BubbleSort-c"><a href="#BubbleSort-c" class="headerlink" title="BubbleSort.c"></a>BubbleSort.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;BubbleSort.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[], <span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-comment">//Write your code here</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="BubbleSort-h"><a href="#BubbleSort-h" class="headerlink" title="BubbleSort.h"></a>BubbleSort.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">BubbleSort</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[], <span class="hljs-keyword">int</span> n)</span></span>;<br></code></pre></td></tr></table></figure><h4 id="printResult-c"><a href="#printResult-c" class="headerlink" title="printResult.c"></a>printResult.c</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&quot;printResult.h&quot;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[],<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">char</span>* str)</span></span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>,str);<br>    <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>;i&lt;n;i++)&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%5d&quot;</span>,s[i]);<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="printResult-h"><a href="#printResult-h" class="headerlink" title="printResult.h"></a>printResult.h</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span><span class="hljs-meta-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printResult</span><span class="hljs-params">(<span class="hljs-keyword">int</span> s[],<span class="hljs-keyword">int</span> n,<span class="hljs-keyword">char</span>* str)</span></span>;<br></code></pre></td></tr></table></figure><p><del>愿天堂没有用word图片发布的作业代码。</del></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>祁昊</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>离散数学作业答案</title>
    <link href="/AcceptedHelper/2021/03/25/answer_of_discrete_math/"/>
    <url>/AcceptedHelper/2021/03/25/answer_of_discrete_math/</url>
    
    <content type="html"><![CDATA[<p>此处的答案为2020年春网课学期助教所发布的答案，可能与今年布置的作业有所出入，请同学们务必<strong>不要外传</strong>。第12章和13章的答案如下(需要用电脑版的Chrome浏览器访问):</p><div class="row">    <embed src="https://cdn.jsdelivr.net/gh/FDU19CS/AcceptedHelper@hexo/source/_posts/answer_of_discrete_math/discrete_math_12_13.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>离散数学</category>
      
    </categories>
    
    
    <tags>
      
      <tag>王少文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELF头简介</title>
    <link href="/AcceptedHelper/2021/03/23/Readelf/"/>
    <url>/AcceptedHelper/2021/03/23/Readelf/</url>
    
    <content type="html"><![CDATA[<p>​    在linux中我们常用readelf指令来读取ELF (Executable and Linkable Format) 文件中的信息，本文主要介绍ELF头的基本信息</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/7/77/Elf-layout--en.svg/260px-Elf-layout--en.svg.png" alt="ELF文件结构"></p><h3 id="ELF头"><a href="#ELF头" class="headerlink" title="ELF头"></a>ELF头</h3><p>elf头是位于elf文件的头部，里面存储着一些机器和该ELF文件的基本信息。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>        <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">char</span>   e_ident[EI_NIDENT];<br>        Elf64_Half      e_type;<br>        Elf64_Half      e_machine;<br>        Elf64_Word      e_version;<br>        Elf64_Addr      e_entry;<br>        Elf64_Off       e_phoff;<br>        Elf64_Off       e_shoff;<br>        Elf64_Word      e_flags;<br>        Elf64_Half      e_ehsize;<br>        Elf64_Half      e_phentsize;<br>        Elf64_Half      e_phnum;<br>        Elf64_Half      e_shentsize;<br>        Elf64_Half      e_shnum;<br>        Elf64_Half      e_shstrndx;<br>&#125; Elf64_Ehdr;<br></code></pre></td></tr></table></figure><p>我们分别介绍其含义</p><hr><h4 id="1、e-ident"><a href="#1、e-ident" class="headerlink" title="1、e_ident"></a>1、e_ident</h4><ul><li><strong>长度：16字节</strong></li><li><strong>简介：包含着文件和操作系统信息</strong></li><li><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosklimwgzj30m00fmq55.jpg" style="zoom:50%;" /></li></ul><h5 id="Magic-Num-e-ident-0-3"><a href="#Magic-Num-e-ident-0-3" class="headerlink" title="Magic Num - e_ident[0:3]"></a>Magic Num - e_ident[0:3]</h5><p>​    前四个字节包含着一个 magic number，表示该文件是一个 ELF 文件</p><h5 id="EI-Class-e-ident-4"><a href="#EI-Class-e-ident-4" class="headerlink" title="EI_Class - e_ident[4]"></a>EI_Class - e_ident[4]</h5><p>​    指示文件类型，是ELF32还是ELF64位</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskl3oqhyj30dq05qq3h.jpg" style="zoom:50%;" /><h5 id="EI-DATA-e-ident-5"><a href="#EI-DATA-e-ident-5" class="headerlink" title="EI_DATA - e_ident[5]"></a>EI_DATA - e_ident[5]</h5><p>​    指示文件的编码方式，是大端法还是小端法</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskkp5pdjj30fy05ggm5.jpg" style="zoom:50%;" /><p>​    <strong>ELFDATA2LSB - 小端法</strong></p><p>​    <strong>ELFDATA2MSB - 大端法</strong></p><h5 id="EI-Version-e-ident-6"><a href="#EI-Version-e-ident-6" class="headerlink" title="EI_Version - e_ident[6]"></a>EI_Version - e_ident[6]</h5><p>​    标识ELF Version, 该值等于EV_CURRENT，目前为1</p><h5 id="EI-OSABI-e-ident-7"><a href="#EI-OSABI-e-ident-7" class="headerlink" title="EI_OSABI - e_ident[7]"></a>EI_OSABI - e_ident[7]</h5><p>​    表示着该文件运行的操作系统</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1goskk8xx2wj30oi0jmadb.jpg" alt="操作系统类型对应" style="zoom:50%;" /><h5 id="EI-ABIVERSION-e-ident-8"><a href="#EI-ABIVERSION-e-ident-8" class="headerlink" title="EI_ABIVERSION - e_ident[8]"></a>EI_ABIVERSION - e_ident[8]</h5><p>​    标志着 ABI （应用二进制接口）的版本，ABI相当于硬件层级的API（见下图）</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosknnji29j31400u0qd8.jpg" alt="ABI解释" style="zoom:40%;" /><h5 id="EI-PAD-e-ident-8-15"><a href="#EI-PAD-e-ident-8-15" class="headerlink" title="EI_PAD - e_ident[8:15]"></a>EI_PAD - e_ident[8:15]</h5><p>​    填充位，用零填充用以对齐，可以预留给未来使用</p><h4 id="2、e-type"><a href="#2、e-type" class="headerlink" title="2、e_type"></a>2、e_type</h4><ul><li><p><strong>长度：2字节</strong></p></li><li><p><strong>简介：</strong>指示文件类型</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosm36oov3j30he0da40a.jpg" style="zoom:50%;" /></li></ul><p>​    </p><h4 id="3、e-machine"><a href="#3、e-machine" class="headerlink" title="3、e_machine"></a>3、e_machine</h4><ul><li><p><strong>长度：2字节</strong></p></li><li><p><strong>简介：</strong>指示机器类型</p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosm42l3lxj30u00x2wkc.jpg" alt="部分机器类型" style="zoom:50%;" /></li></ul><h4 id="4、e-version"><a href="#4、e-version" class="headerlink" title="4、e_version"></a>4、e_version</h4><p>​    <strong>长度：4字节</strong></p><p>​    <strong>简介：指示文件版本</strong></p><img src="https://tva1.sinaimg.cn/large/008eGmZEly1gosm8c0knij30dk04gglx.jpg" style="zoom:50%;" /><h4 id="5、e-entry"><a href="#5、e-entry" class="headerlink" title="5、e_entry"></a>5、e_entry</h4><p>​    <strong>长度：4字节（32位）/8字节（64位）</strong></p><p>​    <strong>简介：进程开始的虚拟地址</strong></p><h4 id="6、e-phoff"><a href="#6、e-phoff" class="headerlink" title="6、e_phoff"></a>6、e_phoff</h4><p>​    <strong>长度：4字节（32位）/8字节（64位）</strong></p><p>​    <strong>简介：指向程序头部表的开始</strong>    </p><h4 id="7、e-shoff"><a href="#7、e-shoff" class="headerlink" title="7、e_shoff"></a>7、e_shoff</h4><p>​    <strong>长度：4字节（32位）/8字节（64位）</strong></p><p>​    <strong>简介：指向节头部表的开始</strong>    </p><h4 id="8、e-flags"><a href="#8、e-flags" class="headerlink" title="8、e_flags"></a>8、e_flags</h4><p>​    <strong>长度：4字节</strong></p><p>​    <strong>简介：意义取决于目标架构</strong>    </p><h4 id="9、e-ehsize"><a href="#9、e-ehsize" class="headerlink" title="9、e_ehsize"></a>9、e_ehsize</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：该文件头部的大小</strong></p><h4 id="10、e-phentsize"><a href="#10、e-phentsize" class="headerlink" title="10、e_phentsize"></a>10、e_phentsize</h4><p>​    <strong>长度：2字节</strong>    </p><p><strong>简介：程序头部的大小</strong>    </p><h4 id="11、e-phnum"><a href="#11、e-phnum" class="headerlink" title="11、e_phnum"></a>11、e_phnum</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：程序头部的条目数</strong></p><h4 id="12、e-shentsize"><a href="#12、e-shentsize" class="headerlink" title="12、e_shentsize"></a>12、e_shentsize</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：节头部表的大小</strong></p><h4 id="13、e-shnum"><a href="#13、e-shnum" class="headerlink" title="13、e_shnum"></a>13、e_shnum</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：节头部表的条目数</strong></p><h4 id="14、e-shstrndx"><a href="#14、e-shstrndx" class="headerlink" title="14、e_shstrndx"></a>14、e_shstrndx</h4><p>​    <strong>长度：2字节</strong>    </p><p>​    <strong>简介：节头部表的条目和其位置 (idx) 的对应关系</strong></p><hr><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>[1] <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">https://en.wikipedia.org/wiki/Executable_and_Linkable_Format</a></p><p>[2] <a href="https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html">https://refspecs.linuxfoundation.org/elf/gabi4+/ch4.eheader.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ICS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>谢子飏</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/AcceptedHelper/2021/03/18/hello_world/"/>
    <url>/AcceptedHelper/2021/03/18/hello_world/</url>
    
    <content type="html"><![CDATA[<h2 id="第一篇用以测试"><a href="#第一篇用以测试" class="headerlink" title="第一篇用以测试"></a>第一篇用以测试</h2><h3 id="一、-下面是一段C-代码"><a href="#一、-下面是一段C-代码" class="headerlink" title="一、 下面是一段C++代码"></a>一、 下面是一段C++代码</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;iostream&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> <span class="hljs-built_in">std</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">cout</span> &lt;&lt; <span class="hljs-string">&quot;Hello World!&quot;</span> &lt;&lt; <span class="hljs-built_in">endl</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、-下面是一段表格"><a href="#二、-下面是一段表格" class="headerlink" title="二、 下面是一段表格"></a>二、 下面是一段表格</h3><table><thead><tr><th align="center">0</th><th align="center">1</th><th align="center">2</th><th align="center">3</th><th align="center">4</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">x</td><td align="center">x</td></tr></tbody></table><h3 id="三、-下面是一段-Latex"><a href="#三、-下面是一段-Latex" class="headerlink" title="三、 下面是一段 Latex"></a>三、 下面是一段 Latex</h3><p>$$E= mc^2$$</p><h3 id="四、下面是一张图片"><a href="#四、下面是一张图片" class="headerlink" title="四、下面是一张图片"></a>四、下面是一张图片</h3><p><img src="https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcRP-ciAYVH8UlH3ZaZC3NkN3ow9CrG36O5crg&usqp=CAU"></p>]]></content>
    
    
    <categories>
      
      <category>测试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>None</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
