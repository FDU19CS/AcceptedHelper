---
title: 计算理论基础复习笔记
date: 2021-06-24 17:36:24
index_img: /img/ITOCv3-Michael_Sipser_2012.bmp
category: [计算理论基础]
---

# 计算理论基础复习笔记

待更新

## 预备知识与基本文法理论（讲义第一章、第二章）

第一章大部分内容在其他课程里讲过了，新的内容只有：

> 前缀性质：L 中任何字符串都不是另一个字符串的真前缀

第二章讲了文法的基本概念。

> **文法** $G$ 是四元组 $(V, T, P, S)$， V 是变元的有限集，T 是终结符有限集，P 是生成式有限集， S 是开始符号。

> => 关系为**直接派生**，多步直接派生为**派生**。

> 文法 $G$ 产生的**语言** $L(G)$ 是 S 派生出来的终结符号串的全体。

> 0型文法（短语结构文法 PSG ）：对生成式无限制。
>
> 1型文法（上下文有关文法 CSG ）：每个生成式左侧长度≤右侧长度
>
> 1°型文法（上下文有关文法的另一种形式）：每个生成式，左侧至少包含一个变元，删去该变元后的前缀与后缀（可为空）也是右侧的前缀与后缀。$\alpha_1A\alpha_2 \rarr \alpha1\beta\alpha_2, \beta不为空$，前缀$\alpha_1$和后缀$\alpha_2$即为上下文。
>
> 2型文法（上下文无关文法 CFG ）：每个生成式左侧仅包含一个变元
>
> 3型文法（正规文法 RG ）：每个生成式左侧仅包含一个变元，且右侧必须形如 $a$ 或 $aB$ ，$a \in T \ 或a为空串$

将1型文法转为1°型文法：

1. 对所有终结符$a$，添加变元$[a]$。
2. 将原有生成式中所有终结符替换为对应新变元（如将$a$替换为$[a]$）。此时，所有生成式都只含变元。
3. 对所有终结符$a$，添加生成式$[a]\rarr a$。
4. 对所有不符合1°型文法的生成式，若左侧为$A_1A_2\ ...\ A_n$，右侧为$B_1B_2...B_m$ ，则添加$n$个变元，用新的 $2n$ 个生成式替换这个生成式。新的生成式中：
   * 第 $i+1$ 个生成式的左侧是第 $i$ 个生成式的右侧；
   * 前 $n$ 个生成式将 $A_1A_2...A_n$ 逐渐替换为 $C_1C_2...C_n$，每个生成式替换一个最靠前的 $A$（第一个生成式为$A_1A_2...A_n\rarr C_1A_2...A_n$）；
   * 接下来的 $n-1$ 个生成式将 $C_1C_2...C_n$ 逐渐替换为 $B_1B_2...B_{n-1}C_n$， 每个生成式替换一个最靠前的 $C$ （第 $n+1$个生成式为$C_1C_2...C_n\rarr B_1C_2...C_n$）；
   * 最后的生成式将 $C_n$ 替换为 $B_nB_{n+1}...B_m$ 。

2型文法的**派生树**：根节点为 S ；内部节点为变元；某个节点（有标记A）的孩子从左到右收集而成的字符串s，必有$A\rarr s$属于生成式集合（对应*直接派生*）；**边缘**是叶子节点从左到右收集而成的字符串（对应*派生*）。派生树可对应一个字符串从 S 开始的派生过程。

**最左派生**：派生过程每一步都只替换最左边的变元。（同理有**最右派生**）

**多义**：某个字符串有两种不同派生过程。

## 有穷自动机、正规表达式、正规集（讲义第三、四章，MIT教材第一章）

> **有穷自动机** （FA） 是五元组 $(Q,\Sigma,\delta,q_0,F)$，分别对应：有穷状态集、有穷输入字符表、转移函数、初始状态、终结状态集。
>
> 转移函数的输入为单个字符，可扩充为字符串。
>
> FA 接收的字符串 s ：以 s 作为 FA 的输入，状态从初始的 $q_0$ 转移到 F 里的状态。

**四种变换**：

1. $DFA \rarr Regular\ Expression$

   讲义上的方法是：

   * 如果有 $k$ 个状态，算出 $k^3$ 个正规表达式 $r_{ij}^k$，表示输入串使状态机从状态 i 到 j 中间不经过编号高于 k 的状态。

   * $k = 0$ 时，状态图中若有从状态 i 到状态 j 的箭头，就把箭头上的字符加到集合里。$i == j$ 时，这个集合里还要包含空串。
   * $k \ne 0$ 时，有递推式 $r_{ij}^k = r_{ik}^{k-1}(r_{kk}^{k-1})^*r_{kj}^{k-1} \cup r_{ij}^{k-1}$

   MIT 教材上的方法是：

   * 将 DFA 转为 GNFA （GNFA的转换条件可以是正规表达式）：添加两个状态 s 和 t ，s 为新的初始状态，t 为新的终结状态。s 通过 $\epsilon$ 动作到原有的每个初始状态，原有的每个终结状态通过 $\epsilon$ 动作到 t
   * 将 GNFA 的状态数缩减到2：下面的 RE 三种四句的反向操作，可将状态数减1
   * 将 2-state GNFA 转换为 RE：转换条件即为所求

2. $Regular Expression \rarr \epsilon-NFA$

   处理三种类型的子句即可。讲义 p65-p66 的三张图

   * $r_1+r_2$：两路分叉、两路归并
   * $r_1r_2$：前面的终结状态指向后面的初始状态
   * $r_1^*$：终结状态回到初始状态

3. $\epsilon-NFA \rarr NFA$

   讲义 p59

   先检查 $q_0$ 是否为终结状态。

   转移函数取一个闭包。

4. $NFA \rarr DFA$

   讲义 p55

   NFA 中，$\delta(q, a)$ 的结果是一个状态集。建立状态集到状态元组双射，把状态元组看作一个新的状态。将状态元组作为 $\delta$ 的输入，结果为元组中状态作为输入的结果的并集。一直做下去，直到不产生新的状态。

正规文法转为 $\epsilon-NFA$：

* 每个变元为状态，每个终结符为输入字符
* 转移函数的输入：派生左侧的变元、派生右侧的终结符（或 $\epsilon$）；输出为派生右侧的变元（或终结状态）

DFA 转为正规文法：同上。

**正规集缩胀**

